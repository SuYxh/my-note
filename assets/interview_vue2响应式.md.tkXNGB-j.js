import{_ as e,c as o,o as c,V as d}from"./chunks/framework.hxTji2_l.js";const D=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue2响应式.md","filePath":"interview/vue2响应式.md","lastUpdated":1718195154000}'),l={name:"interview/vue2响应式.md"},t=d('<p>vue2 响应式</p><p><img src="https://qn.huat.xyz/mac/202401041238362.png" alt="image-20240104123820325"></p><p><img src="https://qn.huat.xyz/mac/202401041321654.png" alt="image-20240104132155626"></p><p><img src="https://qn.huat.xyz/mac/202401041331942.png" alt="image-20240104133158887"></p><p><img src="https://qn.huat.xyz/mac/202401041334903.png" alt="image-20240104133431879"></p><p>在 Vue 2 中，<code>Observer</code>、<code>Dep</code>、<code>Watcher</code> 和 <code>data</code> 是 Vue 响应式系统的核心部分。它们之间的关系和联系是相当紧密且协同工作的。以下是它们的定义和它们之间的关系：</p><ol><li><p><strong>data</strong>:</p><ul><li>在Vue组件中，<code>data</code> 是一个包含各种属性的对象，这些属性是组件的状态。当这些属性的值改变时，视图会自动更新。</li></ul></li><li><p><strong>Observer</strong>:</p><ul><li><code>Observer</code> 是一个类，它的职责是将 <code>data</code> 中的属性转换成可观察的对象。它会遍历 <code>data</code> 对象的所有属性，并使用 <code>Object.defineProperty</code> 把这些属性转换为 getter/setter。这样，Vue 就能够追踪属性值的变化。</li></ul></li><li><p><strong>Dep (Dependency)</strong>:</p><ul><li><code>Dep</code> 是一个用于管理依赖的类，它维护了一个数组，用来收集当前属性的依赖关系（即 <code>Watcher</code> 的实例）。每个被 <code>Observer</code> 观察的属性都有一个对应的 <code>Dep</code> 实例。</li><li>当属性被读取（getter）时，<code>Dep</code> 会收集依赖（即添加 <code>Watcher</code>），而当属性被修改（setter）时，<code>Dep</code> 通知它的所有 <code>Watcher</code> 更新。</li></ul></li><li><p><strong>Watcher</strong>:</p><ul><li><code>Watcher</code> 是一个类，它的作用是作为一个中介，它订阅了 <code>Dep</code> 的变化（即数据的变化）。当数据变化时，<code>Dep</code> 通知 <code>Watcher</code>，然后 <code>Watcher</code> 会执行相应的更新函数，从而更新视图。</li><li>在Vue组件中，每个组件实例都至少有一个 <code>Watcher</code>，用于更新组件的渲染。此外，计算属性和监听器也各自有对应的 <code>Watcher</code>。</li></ul></li></ol><p>关系和联系：</p><ul><li>当你在组件的 <code>data</code> 中声明一个属性时，Vue 会使用 <code>Observer</code> 将其转换为可响应的对象。</li><li>每个响应式属性都通过 <code>Observer</code> 关联一个 <code>Dep</code> 实例，用于跟踪这个属性的所有依赖（即哪些 <code>Watcher</code> 依赖于这个属性）。</li><li>当属性被访问或修改时，<code>Dep</code> 负责通知所有订阅了这个属性的 <code>Watcher</code>，告诉它们数据已经改变，需要重新评估或执行更新函数（比如重新渲染组件）。</li></ul><p>简而言之，这个系统使得Vue能够以高效的方式更新DOM来响应数据的改变。每当数据变化时，只有依赖于这些数据的组件会被重新渲染，而不是整个DOM树，这大大提高了性能和效率。</p><h3 id="watcher" tabindex="-1">Watcher <a class="header-anchor" href="#watcher" aria-label="Permalink to &quot;Watcher&quot;">​</a></h3><p>在 Vue.js 的响应式系统中，<code>Watcher</code> 是一个非常重要的概念。它是一个对象，负责执行以下两个主要任务：</p><ol><li><p><strong>依赖收集</strong>：当渲染函数或计算属性被求值时，它们会访问响应式数据。每个访问的响应式数据都会记录当前正在执行的 <code>Watcher</code> 作为其依赖。这意味着，当这些数据发生变化时，<code>Watcher</code> 能够被通知。</p></li><li><p><strong>响应更新</strong>：当 <code>Watcher</code> 所依赖的数据发生变化时，它会执行回调函数来进行相应的更新操作。这通常涉及重新计算计算属性的值或重新渲染组件。</p></li></ol><p>具体来说，<code>Watcher</code> 在 Vue.js 中的角色可以这样理解：</p><ul><li><strong>组件的渲染</strong>：每个 Vue 组件实例都有一个对应的 <code>Watcher</code> 实例，用于渲染组件并在组件的依赖数据发生变化时触发重新渲染。</li><li><strong>计算属性</strong>：每个计算属性也有一个对应的 <code>Watcher</code>，当依赖的数据发生变化时，这个 <code>Watcher</code> 会重新计算该属性的值。</li><li><strong>侦听器</strong>：Vue 的 <code>watch</code> 选项允许你指定当某些数据变化时执行的回调函数，每个这样的侦听器背后也是通过一个 <code>Watcher</code> 实例来实现的。</li></ul><p>在 Vue 的内部实现中，<code>Watcher</code> 的作用是连接响应式数据和视图之间的桥梁。它使得 Vue 能够以高效和精确的方式更新 DOM，仅当实际需要时才进行更新，从而优化性能并避免不必要的计算。</p><h3 id="dep" tabindex="-1">Dep <a class="header-anchor" href="#dep" aria-label="Permalink to &quot;Dep&quot;">​</a></h3><ul><li><code>Dep</code> 类是 Vue 响应式系统中用于依赖跟踪的关键组件。每个响应式数据项（如 <code>data</code> 的属性）都关联一个 <code>Dep</code> 实例。</li><li>当组件或计算属性等访问这些数据时，它们的 <code>Watcher</code> 实例会被添加到相应的 <code>Dep</code> 的 <code>subs</code> 数组中。</li><li>当数据变化时，<code>Dep</code> 通过调用每个 <code>Watcher</code> 的 <code>update</code> 方法通知变化，从而触发组件的重新渲染或计算属性的重新计算。</li></ul><h3 id="为什么还要把这个-dep-实例添加到这个-watcher-的依赖中-有什么用处呢" tabindex="-1">为什么还要把这个 Dep 实例添加到这个 Watcher 的依赖中 ？ 有什么用处呢？ <a class="header-anchor" href="#为什么还要把这个-dep-实例添加到这个-watcher-的依赖中-有什么用处呢" aria-label="Permalink to &quot;为什么还要把这个 Dep 实例添加到这个 Watcher 的依赖中 ？ 有什么用处呢？&quot;">​</a></h3><p>将 <code>Dep</code> 实例添加到 <code>Watcher</code> 的依赖中是 Vue 响应式系统的一个关键步骤，它有几个重要的用途：</p><ol><li><p><strong>双向依赖跟踪</strong>:</p><p>在 Vue 的响应式系统中，依赖跟踪是双向的。一个 <code>Dep</code> 实例代表一个响应式数据属性，而 <code>Watcher</code> 实例代表一个消费这些数据的消费者（如组件或计算属性）。当一个组件访问某个数据属性时，不仅该数据的 <code>Dep</code> 需要知道哪些 <code>Watcher</code> 依赖于它（以便在数据改变时通知它们），而且每个 <code>Watcher</code> 也需要知道它依赖哪些 <code>Dep</code>。</p><ul><li><strong>从 <code>Dep</code> 到 <code>Watcher</code></strong>: 当组件或计算属性访问某个响应式数据时（例如，在模板或计算属性中使用），该数据的 <code>Dep</code> 实例会收集当前活跃的 <code>Watcher</code>（即组件或计算属性的 <code>Watcher</code>）。这样，当数据变化时，<code>Dep</code> 知道要通知哪些 <code>Watcher</code> 更新。</li><li><strong>从 <code>Watcher</code> 到 <code>Dep</code></strong>: 同时，每个 <code>Watcher</code> 也需要知道它依赖于哪些数据。这样，如果组件被销毁或计算属性依赖的数据改变，<code>Watcher</code> 可以避免不必要的更新，或者从不再需要的 <code>Dep</code> 中清理自己。</li></ul></li><li><p><strong>避免重复收集</strong>:</p><p>每个 <code>Dep</code> 实例会有多个 <code>Watcher</code> 订阅它，但同一个 <code>Watcher</code> 不应该重复订阅同一个 <code>Dep</code>。当 <code>Dep</code> 实例被添加到 <code>Watcher</code> 的依赖中时，<code>Watcher</code> 可以管理这些依赖并避免重复收集。</p><ul><li>当多次访问同一个数据时，不需要重复将同一个 <code>Watcher</code> 添加到 <code>Dep</code> 中。<code>Watcher</code> 中会检查是否已经收集了对应的 <code>Dep</code>，从而避免重复收集。</li><li>当组件销毁或依赖关系改变时，<code>Watcher</code> 可以从其依赖的 <code>Dep</code> 中移除自己，防止不必要的更新。</li></ul></li><li><p><strong>优化性能</strong>:</p><ul><li>当组件或计算属性需要重新计算或重新渲染时，Vue 不需要重新计算所有的依赖关系。由于每个 <code>Watcher</code> 知道其依赖的确切 <code>Dep</code> 实例，Vue 可以精确地确定哪些数据变化需要触发哪些 <code>Watcher</code>，从而避免不必要的计算和渲染，提高应用程序的效率和性能。</li></ul></li><li><p><strong>清理和更新依赖</strong>:</p><ul><li>在组件的生命周期中，依赖可能会变化（例如，条件渲染可能会访问不同的数据）。<code>Watcher</code> 知道自己的所有依赖，使得在需要时可以清理旧的依赖并建立新的依赖关系。</li></ul></li><li><p><strong>响应式系统的核心机制</strong>:</p><ul><li>这种依赖收集机制是 Vue 响应式系统能够高效且准确地响应数据变化的核心。它允许 Vue 在数据变化时仅更新那些真正依赖变化数据的部分，而不是整个应用，从而提高了性能和用户体验。</li></ul></li></ol><p>总之，将 <code>Dep</code> 实例添加到 <code>Watcher</code> 的依赖中，使 Vue 能够建立一个精确且高效的响应式系统，这对于管理复杂的应用状态和确保高效的更新至关重要。</p><h3 id="在-watcher-的-class-中-为何需要有-2-个-dep-实例数组呢-this-deps-this-newdeps-this-depids-new-set-this-newdepids-new-set" tabindex="-1">在 Watcher 的 class 中 为何需要有 2 个 Dep 实例数组呢？ this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() <a class="header-anchor" href="#在-watcher-的-class-中-为何需要有-2-个-dep-实例数组呢-this-deps-this-newdeps-this-depids-new-set-this-newdepids-new-set" aria-label="Permalink to &quot;在 Watcher 的 class 中  为何需要有 2 个 Dep 实例数组呢？ this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set()&quot;">​</a></h3><p>在 Vue.js 的 <code>Watcher</code> 类中，存在两组 <code>Dep</code> 实例数组（<code>this.deps</code> 和 <code>this.newDeps</code>）以及对应的 <code>Set</code>（<code>this.depIds</code> 和 <code>this.newDepIds</code>）。这种设计是为了高效且准确地管理依赖收集和清理过程。让我们来探讨一下这些数组和集合的作用和原因。</p><ol><li><p><strong>this.deps 和 this.depIds</strong>：</p><ul><li><code>this.deps</code> 用于存储 <code>Watcher</code> 当前所依赖的所有 <code>Dep</code> 实例。</li><li><code>this.depIds</code> 是一个 <code>Set</code>，用于存储 <code>this.deps</code> 中每个 <code>Dep</code> 实例的唯一标识符（id）。这个 <code>Set</code> 主要用于快速检查 <code>Watcher</code> 是否已经收集了特定的 <code>Dep</code> 实例，从而避免重复收集。</li></ul></li><li><p><strong>this.newDeps 和 this.newDepIds</strong>：</p><ul><li><code>this.newDeps</code> 在每次 <code>Watcher</code> 重新求值时用于临时存储新的 <code>Dep</code> 实例。</li><li><code>this.newDepIds</code> 作为 <code>Set</code> 存储 <code>this.newDeps</code> 中每个 <code>Dep</code> 实例的唯一标识符（id），用于快速检查避免重复收集。</li></ul></li></ol><p>这种设计的原因是：</p><ul><li><p><strong>避免重复收集</strong>：在组件重新渲染或计算属性重新计算时，<code>Watcher</code> 可能会再次访问相同的响应式数据。通过这两组集合，Vue 可以确保不会重复收集相同的依赖。</p></li><li><p><strong>清理不再需要的依赖</strong>：当 <code>Watcher</code> 的依赖发生变化时（例如，组件的模板或计算属性的依赖项更改），需要移除那些不再需要的依赖。通过比较 <code>this.deps</code> 和 <code>this.newDeps</code>，Vue 可以识别出哪些依赖不再需要，并相应地进行清理。</p></li></ul><p>在每次依赖收集的结束时，Vue 会执行以下操作：</p><ul><li>将 <code>this.newDeps</code> 赋值给 <code>this.deps</code>，以便在下一次求值时使用。</li><li>清空 <code>this.newDeps</code> 和 <code>this.newDepIds</code> 以备下次使用。</li><li>使用 <code>this.depIds</code> 和 <code>this.newDepIds</code> 来确保不会重复收集依赖和正确地移除不再需要的依赖。</li></ul><p>这种机制确保了 Vue 的响应式系统既高效又准确，能够根据组件的实际需要动态调整其依赖关系。</p><h3 id="不要-dep-属性直接关联-watcher-可以吗-属性变了-然后通知-watcher-进行更新" tabindex="-1">不要 Dep，属性直接关联 watcher 可以吗？ 属性变了，然后通知 watcher 进行更新？ <a class="header-anchor" href="#不要-dep-属性直接关联-watcher-可以吗-属性变了-然后通知-watcher-进行更新" aria-label="Permalink to &quot;不要 Dep，属性直接关联 watcher 可以吗？ 属性变了，然后通知 watcher 进行更新？&quot;">​</a></h3><p>您提出的这个想法，即属性直接关联 <code>Watcher</code> 而不经由 <code>Dep</code> 实例，理论上是可行的。但在实际应用中，使用 <code>Dep</code> 实例作为中间层有几个重要的优点，这些优点在 Vue 的设计中起到了关键作用：</p><ol><li><p><strong>解耦数据和观察者</strong>：</p><ul><li>使用 <code>Dep</code> 实例作为中介，可以将数据属性和依赖于这些属性的观察者（<code>Watcher</code>）解耦。这意味着数据层不需要直接知道谁在观察它，也不需要知道观察者具体需要执行哪些操作。</li></ul></li><li><p><strong>管理多对多的关系</strong>：</p><ul><li>在复杂的应用中，一个 <code>Watcher</code> 可能依赖多个数据属性，同样一个属性也可能被多个 <code>Watcher</code> 所依赖。<code>Dep</code> 实例作为中间层可以更高效地管理这种多对多的关系。</li></ul></li><li><p><strong>避免重复收集依赖</strong>：</p><ul><li>通过 <code>Dep</code> 实例，Vue 可以有效地避免重复收集依赖。当一个 <code>Watcher</code> 被多次触发相同属性的 getter 时，<code>Dep</code> 实例确保这个 <code>Watcher</code> 只被添加一次。</li></ul></li><li><p><strong>优化依赖更新</strong>：</p><ul><li>当属性发生变化时，<code>Dep</code> 实例可以有效地通知所有相关的 <code>Watcher</code> 进行更新。如果没有 <code>Dep</code> 层，每个属性直接管理它的 <code>Watcher</code> 列表可能会导致效率低下，特别是在涉及大量数据和观察者时。</li></ul></li><li><p><strong>灵活性和可维护性</strong>：</p><ul><li>使用 <code>Dep</code> 实例作为中间层提供了更好的灵活性和可维护性。这种模式使得 Vue 的内部机制更容易扩展和优化，同时对开发者而言，这种抽象也使得框架的使用更简单、更直观。</li></ul></li></ol><p>总之，虽然属性直接关联 <code>Watcher</code> 在某些方面看似简化了设计，但实际上使用 <code>Dep</code> 实例为中间层在管理复杂依赖关系、优化性能、提高代码的灵活性和可维护性方面提供了显著优势。这是 Vue.js 响应式系统设计的一个关键部分。</p><h3 id="挂载更新" tabindex="-1">挂载更新 <a class="header-anchor" href="#挂载更新" aria-label="Permalink to &quot;挂载更新&quot;">​</a></h3><p><img src="https://qn.huat.xyz/mac/202401031144373.png" alt="img"></p><h3 id="编译相关" tabindex="-1">编译相关 <a class="header-anchor" href="#编译相关" aria-label="Permalink to &quot;编译相关&quot;">​</a></h3><p><img src="https://qn.huat.xyz/mac/202401042241828.png" alt="image-20240104224138741"></p><p><img src="https://qn.huat.xyz/mac/202401042254279.png" alt="image-20240104225457248"></p><h3 id="初始渲染过程" tabindex="-1">初始渲染过程 <a class="header-anchor" href="#初始渲染过程" aria-label="Permalink to &quot;初始渲染过程&quot;">​</a></h3><ol><li><strong>实例化 Vue</strong>：</li></ol><ul><li><ul><li>创建一个新的 Vue 实例。</li><li>初始化实例属性、事件等。</li></ul></li></ul><ol><li><strong>初始化阶段</strong> (<code>init</code> 方法)：</li></ol><ul><li><ul><li>设置数据观察者（<code>Observer</code>），将 <code>data</code> 中的属性转换为响应式属性。</li><li>编译模板，将模板（字符串或 DOM 元素）转换为渲染函数（<code>render</code> 函数）。</li></ul></li></ul><ol><li><strong>挂载阶段</strong> (<code>vm.$mount</code> 方法)：</li></ol><ul><li><ul><li>如果未提供渲染函数，Vue 会将模板编译成 <code>render</code> 函数。</li><li>创建一个 <code>Watcher</code> 实例来监听数据变化，并在首次调用 <code>render</code> 函数生成虚拟 DOM。</li></ul></li></ul><ol><li><strong>虚拟 DOM 渲染</strong> (<code>render</code> 函数)：</li></ol><ul><li><ul><li>根据实例的状态生成虚拟 DOM。</li></ul></li></ul><ol><li><strong>真实 DOM 渲染</strong> (<code>_update</code> 方法)：</li></ol><ul><li><ul><li>调用 <code>patch</code> 函数，将虚拟 DOM 转换为真实 DOM，并挂载到指定的挂载点。</li></ul></li></ul><h3 id="更新过程" tabindex="-1">更新过程 <a class="header-anchor" href="#更新过程" aria-label="Permalink to &quot;更新过程&quot;">​</a></h3><ol><li><strong>数据变化</strong>：</li></ol><ul><li><ul><li>当响应式数据发生变化时，触发依赖该数据的 <code>Watcher</code>。</li></ul></li></ul><ol><li><strong>重新渲染</strong> (<code>Watcher</code> 的回调函数)：</li></ol><ul><li><ul><li><code>Watcher</code> 检测到数据变化，会再次调用 <code>render</code> 函数生成新的虚拟 DOM。</li></ul></li></ul><ol><li><strong>虚拟 DOM 重新渲染</strong> (<code>render</code> 函数)：</li></ol><ul><li><ul><li>根据最新的组件状态生成新的虚拟 DOM。</li></ul></li></ul><ol><li><strong>DOM 更新</strong> (<code>_update</code> 方法)：</li></ol><ul><li><ul><li>再次调用 <code>patch</code> 函数，比较新旧虚拟 DOM 的差异。</li></ul></li></ul><ol><li><strong>虚拟 DOM Diff 算法</strong> (<code>patch</code> 方法)：</li></ol><ul><li><ul><li>使用 diff 算法比较新旧虚拟 DOM 树的差异。</li><li>调用 <code>updateChildren</code> 等方法来高效地更新子节点。</li></ul></li></ul><ol><li><strong>应用 DOM 更新</strong>：</li></ol><ul><li><ul><li>根据 diff 算法的结果，执行实际的 DOM 更新操作（如节点的添加、删除、更新）。</li><li>如果涉及组件，执行相关的生命周期钩子（如 <code>beforeUpdate</code> 和 <code>updated</code>）。</li></ul></li></ul><ol><li><strong>更新完成</strong>：</li></ol><ul><li><ul><li>完成所有 DOM 更新后，视图与组件的最新状态保持一致。</li></ul></li></ul><p>在这个过程中，Vue 的响应式系统、虚拟 DOM 和 diff 算法共同工作，确保只有必要的组件进行重渲染，并且 DOM 操作是高效的。这种机制使得 Vue 在处理复杂界面时仍能保持良好的性能。</p>',66),i=[t];function r(a,s,p,h,n,u){return c(),o("div",null,i)}const W=e(l,[["render",r]]);export{D as __pageData,W as default};
