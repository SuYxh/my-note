import{_ as s,c as i,o as a,V as e}from"./chunks/framework.hxTji2_l.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/构建.md","filePath":"interview/构建.md","lastUpdated":1716803380000}'),n={name:"interview/构建.md"},p=e(`<p>构建</p><h3 id="_1、webpack-如何配置热更新" tabindex="-1">1、webpack 如何配置热更新 <a class="header-anchor" href="#_1、webpack-如何配置热更新" aria-label="Permalink to &quot;1、webpack 如何配置热更新&quot;">​</a></h3><p>Webpack的热更新（Hot Module Replacement 或 HMR）允许在运行时更新各种模块，而无需进行完全刷新。要配置Webpack以使用HMR，你可以按照以下步骤进行：</p><ol><li><p><strong>安装webpack-dev-server</strong>（如果你还没有的话）:</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install --save-dev webpack-dev-server</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p><strong>修改webpack配置文件</strong>（通常是<code>webpack.config.js</code>）:</p><ul><li>确保你已经在配置中包括了<code>webpack</code>：<div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> webpack</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;webpack&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li>在你的<code>webpack.config.js</code>文件中添加<code>devServer</code>对象：<div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">devServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  contentBase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;dist&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  hot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div>其中<code>contentBase</code>指定了服务器资源的根目录，<code>hot</code>启用HMR，<code>open</code>将打开浏览器。</li></ul></li><li><p><strong>使用HotModuleReplacementPlugin插件</strong>:</p><p>这个插件是webpack内置的，用来启动HMR功能。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">plugins</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> webpack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HotModuleReplacementPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p><strong>在你的入口文件中添加HMR逻辑</strong>:</p><p>这通常是你的主JavaScript文件，例如<code>index.js</code>。你需要添加代码来接受热更新的模块。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./someModule&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 当someModule更新时的逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li><li><p><strong>启动webpack-dev-server</strong>:</p><p>修改你的<code>package.json</code>来包含一个script来启动dev server：</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;scripts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;start&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;webpack serve --hot --config webpack.config.js&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>然后在命令行运行：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li></ol><p>请注意，以上步骤会根据你的项目和配置的具体情况而有所不同。确保你已经安装了webpack及其相关的loader和插件。而且，对于生产环境，你通常不会启用HMR，它主要用于开发环境来提高开发效率。</p><p>这段代码是Webpack中用于实现模块热替换（Hot Module Replacement，简称HMR）的一个示例。当你在开发模式下运行Webpack时，这段代码允许Webpack在某个模块更新后，只替换变更的部分而无需重新加载整个页面。具体来说：</p><ul><li><p><code>module.hot</code>：这是一个布尔值，当Webpack运行在HMR模式下时为<code>true</code>。这意味着你的环境支持热模块替换。</p></li><li><p><code>module.hot.accept</code>：这是一个函数，它告诉Webpack当前模块(<code>module</code>)如何处理模块内部的更新。它接受两个参数：</p><ul><li>第一个参数是一个路径字符串，指向你想要热更新的模块文件。</li><li>第二个参数是一个回调函数，当上述模块或其任何依赖发生更新时，这个回调函数将被执行。</li></ul></li></ul><p>在这个回调函数内部，你通常会包含处理更新的逻辑。这可能包括替换旧模块的引用、重新渲染UI组件或是其他必要的清理工作。</p><p>例如，假设你有一个模块<code>someModule.js</code>，它导出了一个函数。你可以这样使用<code>module.hot.accept</code>来确保在这个模块更新时能够热替换：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 当someModule更新时的逻辑</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./someModule&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 取得更新后的模块</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> updatedModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./someModule&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 使用更新后的模块执行某些操作，比如重新渲染一个组件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    renderComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(updatedModule);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这个机制是现代前端开发中常用的高效开发特性，能显著提升开发者的体验。</p><h3 id="_2、vite-hmr" tabindex="-1">2、vite hmr <a class="header-anchor" href="#_2、vite-hmr" aria-label="Permalink to &quot;2、vite hmr&quot;">​</a></h3><p>Vite 是一个现代前端构建工具，它利用原生的 ES 模块导入特性（ESM）来提供一种极速的开发服务器，并支持热模块替换（HMR）。Vite 的热更新处理与基于Webpack的<code>vue-loader</code>有所不同，但在开发者的角度看来，它们提供了类似的体验：无需手动设置，直接编辑和保存文件即可看到更新。</p><p>Vite 的 HMR 优势在于它不需要打包操作，它将服务器启动时间和更新时间减少到几乎可以忽略不计的程度。对于 Vue 3，Vite 使用 <code>@vitejs/plugin-vue</code> 来处理 <code>.vue</code> 文件的热更新，而对于 Vue 2，可以使用官方提供的 <code>@vitejs/plugin-vue2</code>。</p><p>这些插件在内部处理了以下功能：</p><ol><li><strong>快速更新</strong>：当你更改一个 <code>.vue</code> 文件时，Vite 只重新编译改动的文件，然后通过 WebSocket 将更新推送到浏览器，实现局部刷新。</li><li><strong>状态保留</strong>：在组件逻辑更改时，如果组件导出了 <code>setup</code> 函数，Vite 尝试只替换改变的部分并保留组件状态，而不是重新加载整个组件。</li><li><strong>样式和模板的即时更新</strong>：样式和模板更改通常可以做到即时反映，无需刷新页面或丢失状态。</li></ol><p>在 Vite 中，你通常不需要配置任何特殊的HMR逻辑。当你启动 Vite 开发服务器时（通常使用 <code>vite</code> 命令），HMR 默认就已经启用了。如果你需要在 Vite 中进行特定的HMR处理，Vite 提供了一个 API 来定义自定义的 HMR 行为：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 使用 newModule 更新当前模块逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Vite 为开发者提供了一个非常流畅和快速的开发体验，尤其是在大型项目中，相比传统的Webpack HMR可以感受到更明显的速度提升。</p><h3 id="_3、vite-原理" tabindex="-1">3、vite 原理 <a class="header-anchor" href="#_3、vite-原理" aria-label="Permalink to &quot;3、vite 原理&quot;">​</a></h3><p>Vite 的核心原理在于利用现代浏览器支持的原生 ES 模块（ESM）导入功能来提供服务。这使得它与传统的基于打包的构建工具（如Webpack）有很大不同。以下是 Vite 的主要工作原理：</p><ol><li><p><strong>启动速度快</strong>：</p><ul><li><strong>无捆绑开发</strong>：在开发模式下，Vite 作为一个开发服务器，提供了一个无需打包的开发环境。它为每个请求的模块进行即时的转换和加载，而不是像传统工具那样预先打包所有模块。</li><li><strong>原生 ESM</strong>：Vite 利用了浏览器的原生 ES 模块加载，这意味着代码可以在没有打包的情况下直接运行在浏览器中。它请求服务器按需加载模块，而服务器在接到请求后会即时编译并返回单个模块。</li></ul></li><li><p><strong>快速热更新（HMR）</strong>：</p><ul><li>Vite 优化了其热模块替换的性能。由于没有打包过程，模块的更新可以快速传输到浏览器并应用，大大提升了更新速度。</li></ul></li><li><p><strong>构建时优化</strong>：</p><ul><li><strong>预构建依赖</strong>：在生产构建前，Vite 会对你的 <code>node_modules</code> 目录进行预打包。这样做的原因是因为许多 NPM 包发布的是 CommonJS 格式，或者即使是 ESM，也不是为了高效加载而设计的。Vite 使用 Rollup 来预打包这些依赖，这样在生产环境下它们能够更快地被浏览器解析。</li><li><strong>生产打包</strong>：虽然 Vite 在开发时不打包代码，但在构建生产版本时，它使用 Rollup 来打包应用，这样可以利用 Rollup 的高效打包和树摇（tree-shaking）功能来优化应用。</li></ul></li><li><p><strong>插件系统</strong>：</p><ul><li>Vite 提供了一个丰富的插件接口，允许开发者利用 Rollup 插件生态，这意味着可以重用大量已经存在的插件。</li></ul></li><li><p><strong>模块解析和转换</strong>：</p><ul><li>对于使用新的 JavaScript 特性（如 JSX、TypeScript 或其他编译到 JavaScript 的语言），Vite 会使用 esbuild 预处理器来进行快速转换。esbuild 是用 Go 编写的极速 JavaScript 编译器和打包器，它的速度远超传统的 JavaScript 编译器，如 Babel。</li></ul></li></ol><p>总结来说，Vite 的设计充分利用了现代技术的优势，提供了无需打包的快速开发环境，同时通过预构建依赖和使用 Rollup 进行生产打包，保证了生产环境的性能和效率。这种结合了开发时高效率和生产时优化的策略，使 Vite 成为现代前端开发的有力工具。</p><h3 id="_4、vite-为什么那么快" tabindex="-1">4、vite 为什么那么快？ <a class="header-anchor" href="#_4、vite-为什么那么快" aria-label="Permalink to &quot;4、vite 为什么那么快？&quot;">​</a></h3><p>Vite 之所以快，归功于其几个关键的设计决策：</p><ol><li><p><strong>原生 ES 模块导入</strong>：Vite 利用浏览器支持的 ES 模块导入特性，实现无捆绑的模块加载。这意味着在开发时，源代码可以被浏览器直接解析，无需通过一个打包步骤。这极大减少了启动和热更新的时间，因为只有实际需要的代码才会被加载和编译。</p></li><li><p><strong>按需编译</strong>：传统的打包工具在开发模式下会对整个应用进行打包，哪怕是微小的更改也需要重新打包整个应用。Vite 只对改变的文件进行编译，然后立即通过 HMR 推送更新到浏览器，这显著提高了更新速度。</p></li><li><p><strong>esbuild 预处理</strong>：Vite 使用 esbuild 进行 TypeScript 和 JSX 的转换。esbuild 是一个非常快的 JavaScript 编译器和打包器，它的速度要比传统的工具（如 Babel）快很多，因为 esbuild 使用 Go 编写，而不是 JavaScript，这使得编译过程极为迅速。</p></li><li><p><strong>预构建依赖</strong>：对于 <code>node_modules</code> 中的依赖，Vite 会在第一次运行时进行一次预打包。由于依赖不经常改变，这个步骤通常只在第一次启动时需要较长时间，后续启动将利用缓存，大幅减少启动时间。</p></li><li><p><strong>智能缓存</strong>：Vite 会缓存转换后的模块，所以在重启开发服务器时，已经处理过的模块可以直接从缓存中快速加载。</p></li><li><p><strong>并行加载</strong>：由于 Vite 利用的是原生 ESM，浏览器可以并行加载模块。这和传统的打包工具形成对比，后者通常会生成少数几个大的捆绑文件，这些文件必须按顺序加载。</p></li><li><p><strong>优化的生产构建</strong>：虽然 Vite 在开发模式下不打包代码，但它在生产构建时使用 Rollup（一个高效的模块打包器），结合预构建依赖和树摇（tree-shaking）来生成优化过的代码。</p></li></ol><p>所有这些因素综合起来，使得 Vite 在开发过程中提供了非常快的重载和热更新，同时保证了生产构建的优化和效率。</p><p>Vite 之所以快速，主要归功于其独特的设计理念和技术实现，这些特点使得它在前端开发中表现出色，特别是在项目的启动和热更新方面。下面是 Vite 快速的主要原因：</p><ol><li><p><strong>原生 ES 模块加载（ESM）</strong>：Vite 利用现代浏览器支持的原生 ECMAScript 模块（ESM）来直接加载模块。这意味着在开发过程中，Vite 不需要对代码进行打包和构建，从而大大减少了启动时间。</p></li><li><p><strong>按需编译</strong>：传统的打包工具在开发过程中会对整个应用进行打包，这可能会很慢，特别是对于大型项目。而 Vite 只会在浏览器请求时才编译这个模块，未被请求的模块不会被编译，从而大大加快了加载速度。</p></li><li><p><strong>快速热模块替换（HMR）</strong>：由于 Vite 使用 ESM，所以可以实现更快速的热模块替换。只有实际更改的模块会被重新加载和更新，而不是整个页面或整个应用，这使得开发过程中的响应时间更短。</p></li><li><p><strong>优化的依赖预构建</strong>：对于那些不支持 ESM 的依赖，Vite 会在第一次启动时进行预构建，并缓存结果。这意味着重复的构建时间被大大减少，因为只有在依赖项发生变化时才需要重新构建。</p></li><li><p><strong>高效的生产构建</strong>：尽管 Vite 在开发过程中避免了完整的打包过程，但它在生产环境构建时使用 Rollup 进行高效的代码打包和优化。Rollup 是一个高效的打包工具，能够生成最小化和优化的代码，进一步提高应用的性能。</p></li></ol><p>综上所述，Vite 的设计和实现方式使其成为了一个快速、高效的现代前端开发工具。</p>`,30),l=[p];function t(h,r,k,d,o,c){return a(),i("div",null,l)}const u=s(n,[["render",t]]);export{E as __pageData,u as default};
