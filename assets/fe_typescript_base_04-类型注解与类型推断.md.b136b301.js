import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.fb3766a7.js";const B=JSON.parse('{"title":"类型注解与类型推断","description":"","frontmatter":{},"headers":[],"relativePath":"fe/typescript/base/04-类型注解与类型推断.md","lastUpdated":1707145808000}'),p={name:"fe/typescript/base/04-类型注解与类型推断.md"},e=l(`<h1 id="类型注解与类型推断" tabindex="-1">类型注解与类型推断 <a class="header-anchor" href="#类型注解与类型推断" aria-label="Permalink to &quot;类型注解与类型推断&quot;">​</a></h1><p>上一个小节中，给大家留了一个思考题，那就是如何把两个空间联系到一起？主要采用类型注解来实现的。</p><h2 id="类型注解" tabindex="-1">类型注解 <a class="header-anchor" href="#类型注解" aria-label="Permalink to &quot;类型注解&quot;">​</a></h2><p>通过把变量空间与类型空间结合在一起的操作，就叫做类型注解，具体语法是通过冒号连接在一起的。</p><div class="language-typescript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> a</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//也可以通过类型别名进行连接</span></span>
<span class="line"><span style="color:#C792EA;">type</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> a</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这样定义的 a 变量就具备了字符串类型，那么我们尝试给 a 修改成其他类型就会报错，现在就强制 a 的类型为字符串了，这也是 TS 强制类型的特点。</p><p>那么我们不去进行类型注解，是不是就不会强制类型了呢？其实也会强制类型的，因为 TS 可以进行自动类型推断的。</p><h2 id="类型推断" tabindex="-1">类型推断 <a class="header-anchor" href="#类型推断" aria-label="Permalink to &quot;类型推断&quot;">​</a></h2><p>TS 中会对不进行类型注解的变量，进行自动类型推断的，如下：</p><div class="language-ts line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// let a: string  -&gt;  类型推断</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">a </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">123</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// error</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>所以在 TS 中不管是类型注解还是自动类型推断，对于类型都不能轻易的做修改，这样可以保证变量的类型稳定，从而减少 BUG 的产生。</p>`,11),o=[e];function t(r,c,i,y,D,F){return a(),n("div",null,o)}const _=s(p,[["render",t]]);export{B as __pageData,_ as default};
