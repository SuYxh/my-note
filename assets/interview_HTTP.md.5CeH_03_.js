import{_ as t,c as i,o as l,V as s}from"./chunks/framework.hxTji2_l.js";const P=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/HTTP.md","filePath":"interview/HTTP.md","lastUpdated":1708932782000}'),a={name:"interview/HTTP.md"},e=s(`<h3 id="如何理解osi七层模型" tabindex="-1">如何理解OSI七层模型？ <a class="header-anchor" href="#如何理解osi七层模型" aria-label="Permalink to &quot;如何理解OSI七层模型？&quot;">​</a></h3><p>OSI (open system Interconnect) 模型全称为开放式通信系统互连参考模型 ， 是国际标准化组织 (ISO) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。</p><p><img src="https://qn.huat.xyz/mac/202402082245965.png" alt="图像(1).png"></p><p>物理层（Physical Layer）：负责媒体、信号和二进制数据传输。主要协议和技术包括RJ45、Ethernet（以太网）、光纤、USB、蓝牙等。 数据链路层（Data Link Layer）：负责在物理网络中建立、维护和解除链路。常见协议包括Ethernet（以太网）、PPP（点对点协议）、Switching（交换）、ARP（地址解析协议）等。 网络层（Network Layer）：负责在不同网络之间的数据传输和路由选择。常用的协议有IP（互联网协议）、ICMP（互联网控制消息协议）、IGMP（互联网组管理协议）、路由协议如OSPF、BGP等。 传输层（Transport Layer）：负责提供端到端的数据传输服务。这里的关键协议有TCP（传输控制协议）和UDP（用户数据报协议）。 会话层（Session Layer）：负责建立、管理和终止会话。这一层涉及的协议不如其他层那样知名，但包括NetBIOS和RPC（远程过程调用）。 表示层（Presentation Layer）：确保数据在网络中流动的格式是可理解的。常见的技术包括加密、压缩、数据转换等。例如，JPEG、ASCII、MPEG等。 应用层（Application Layer）：为最终用户提供网络服务。常见的应用层协议包括HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）和DNS（域名系统)等。</p><p><img src="https://qn.huat.xyz/mac/202402082246463.png" alt="图像(1).png"></p><ul><li>应用层报文被传送到运输层</li><li>在最简单的情况下 ，运输层收取到报文并附上附加信息 ，该首部将被接收端的运输层使用</li><li>应用层报文和运输层首部信息一道构成了运输层报文段 。附加的信息可能包括： 允许接收端运输层</li></ul><p>向上向适当的应用程序交付报文的信息以及差错检测位信息 。该信息让接收端能够判断报文中的比特是否在途中已被改变</p><ul><li>运输层则向网络层传递该报文段， 网络层增加了如源和目的端系统地址等网络层首部信息， 生成了网络层数据报</li><li>网络层数据报接下来被传递给链路层 ， 在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧</li><li>在物理层数据帧被封装成比特流， 之后通过传输介质传送到对端</li><li>对端再-步步解开封装 获取到传送的数据</li></ul><h3 id="如何理解tcp-ip协议" tabindex="-1">如何理解TCP/IP协议？ <a class="header-anchor" href="#如何理解tcp-ip协议" aria-label="Permalink to &quot;如何理解TCP/IP协议？&quot;">​</a></h3><p>TCP/IP，传输控制协议/网际协议，是指能够在多个不同网络间实现信息传输的协议簇</p><ul><li>TCP (传输控制协议)： 种面向连接的、可靠的、基于字节流的传输层通信协议</li><li>IP (网际协议)： 用于封包交换数据网络的协议</li></ul><p>TCP/IP协议不仅仅指的是 TCP和IP 两个协议，而是指一个由 FTP、SMTP、TCP、UDP、IP 等协议构成的协议簇,只是因为在TCP/IP 协议中TCP协议和 IP 协议最具代表性，所以通称为TCP/IP协议族(英语:TCP/IP Protocol Suite，或TCP/IP Protocols）</p><table><thead><tr><th>层次名称</th><th>单位</th><th>功 能</th><th>协 议</th></tr></thead><tbody><tr><td>网络接口层</td><td>帧</td><td>负责实际数据的传输，对应OSI参考模型的下两层</td><td>HDLC (高级链路控制协议) PPP (点对点协议) SLIP (串行线路接口协议)</td></tr><tr><td>网络层</td><td>数据报</td><td>负责网络间的寻址数据传输 对应OSI参考模型的第三层</td><td>IP (网际协议) ICMP(网际控制消息协议) ARP (地址解析协议)RARP (反向地址解析协议)</td></tr><tr><td>传输层</td><td>报文段</td><td>负责提供可靠的传输服务 ，对应OSI参考模型的第四层</td><td>TCP (控制传输协议) UDP (用户数据报协议)</td></tr><tr><td>应用层</td><td></td><td></td><td></td></tr><tr><td>负责实现一切与应用程序相关的功能， 对应OSI参考模型的上三层</td><td>FTP (文件传输协议) HTTP (超文本传输协议) DNS (域名服务器协议) SMTP (简单邮件传输协议) NFS(网络文件系统协议)</td><td></td><td></td></tr></tbody></table><h3 id="如何理解udp-和-tcp-区别-应用场景" tabindex="-1">如何理解UDP 和 TCP? 区别？ 应用场景？ <a class="header-anchor" href="#如何理解udp-和-tcp-区别-应用场景" aria-label="Permalink to &quot;如何理解UDP 和 TCP?  区别？ 应用场景？&quot;">​</a></h3><p>UDP (User Datagram Protocol)，用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层也就是说无论应用层交给UDP多长的报文，它统统发送，一次发送一个报文而对接收方，接到后直接去除首部，交给上面的应用层就完成任务UDP 报头包括4个字段，每个字段占用2个字节 (即16个二进制位)，标题短，开销小。特点如下：</p><ul><li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务</li><li>传输途中出现丢包，UDP 也不负责重发</li><li>当包的到达顺序出现乱序时，UDP没有纠正的功能.</li><li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为</li></ul><p>TCP (Transmission Control Protocol)，传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”(缓存区)，等到可以发送的时候就发送不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小TCP报文首部有20个字节，额外开销大</p><ul><li>TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有</li><li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费</li><li>根据 TCP 的这些机制，在IP 这种无连接的网络上也能够实现高可靠性的通信( 主要通过检验和.序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现)</li></ul><p><img src="https://qn.huat.xyz/mac/202402082246494.png" alt="image.png"></p><p>应用场景</p><p><img src="https://qn.huat.xyz/mac/202402082246329.png" alt="图片.png"></p><p>可以看到，TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景</p><h3 id="get-和-post-的区别" tabindex="-1">GET 和 POST 的区别？ <a class="header-anchor" href="#get-和-post-的区别" aria-label="Permalink to &quot;GET 和 POST 的区别？&quot;">​</a></h3><p>GET： GET方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据 POST：POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用</p><blockquote><p>本质上都是 TCP链接，并无差别。但是由于 HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别：参数位置、参数长度、安全、数据包</p></blockquote><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求</li><li>GET产生的URL地址可以被Bookmark，而POST不可以</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行ur编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li><li>对于 GET 方式的请求，浏览器会把 http header和;data一并发送出去，服务器响应200 (返回数据)</li><li>对于 GET方式的请求，浏览器会把 http header和:data一并发送出去，服务器响应200 (返回数据）；对于 POST，浏览器先发送 header，服务器响应100 continue，浏览器再发送:data，服务器响应200 ok。并不是所有浏览器都会在POST中发送两次包，Firefox;就只发送一次</li></ul><h3 id="说说tcp为什么需要三次握手和四次挥手" tabindex="-1">说说TCP为什么需要三次握手和四次挥手？ <a class="header-anchor" href="#说说tcp为什么需要三次握手和四次挥手" aria-label="Permalink to &quot;说说TCP为什么需要三次握手和四次挥手？&quot;">​</a></h3><h3 id="说说-http-常见的请求头有哪些-作用" tabindex="-1">说说 HTTP 常见的请求头有哪些?作用? <a class="header-anchor" href="#说说-http-常见的请求头有哪些-作用" aria-label="Permalink to &quot;说说 HTTP 常见的请求头有哪些?作用?&quot;">​</a></h3><table><thead><tr><th>字段名</th><th></th><th>说明</th><th></th><th>示例</th></tr></thead><tbody><tr><td>Accept</td><td></td><td>能够接受的回应内容类型(content-Types)</td><td></td><td>Accept： text/plain</td></tr><tr><td>Accept-charset</td><td></td><td>能够接受的字符集</td><td></td><td>Accept-charset: utf~~ ~~8</td></tr><tr><td>Accept-Encoding</td><td></td><td>能够接受的编码方式列表</td><td></td><td>Accept-Encodng： gzip deflate</td></tr><tr><td>Accept-Language</td><td></td><td>能够接受的回应内容的自然语言列表</td><td></td><td>Accept-Language: en-Us</td></tr><tr><td>Authorization</td><td></td><td>用于超文本传输协议的认证的认证信息</td><td></td><td>Authorization： Basic QwxhzGRpbjpvcGvulHNC2FtZQ==</td></tr><tr><td>cache-control</td><td></td><td>用来指定在这次的请求/响应中的所有缓存机制都必须遵守的指令</td><td></td><td>cache-control： no-cache</td></tr><tr><td>connection</td><td></td><td>该浏览器想要优先使用的连接类型</td><td></td><td>connection: keep-alive</td></tr><tr><td>connection： upgrade</td><td></td><td></td><td></td><td></td></tr><tr><td>cookie</td><td></td><td>服务器通过 set-cookie 发送的一个 超文本传输协议cookie</td><td></td><td>cookie： $version =1;skin-new；</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>content-Length</td><td></td><td>以八位字节数组(8位的字节表示的请求体的长度</td><td></td><td>content-Length: 348</td></tr><tr><td>content-Type</td><td></td><td>请求体的多媒体类型</td><td></td><td>content-Type： application/x-</td></tr><tr><td>www-form-urlencoded</td><td></td><td></td><td></td><td></td></tr><tr><td>Date</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>发送该消息的日期和时间</td><td></td><td>Date: Tue, 15 Nov 1994 08:12：31 GMT</td><td></td></tr><tr><td>Expect</td><td></td><td>表明客户端要求服务器做出特定的行为</td><td></td><td>Expect： 100-continue</td></tr><tr><td>Host</td><td></td><td>服务器的域名(用于虚拟主机) , 以及服务器所监听的传输控制协议端口号</td><td></td><td>Host: en.wikipedia.org: 80</td></tr><tr><td>Host: en.wikipedia. org</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>| lf-Match | 仅当客户端提供的实体与服务器上对应的实体相匹配时 ， 才进行对应的操作 。主要作用: 像 PUT 这样的方法中 ， 仅当从用户上次更新某个资源以来，该资源未被修改的情况下才更新该资源 | lf-Match： &quot;737060cd8c284d8af7ad3082f209582d &quot; | | --- | --- | --- | | If-Modified-since | 允许在对应的内容未被修改的情况下返回304未修改 | lf-Modified-since： sat, 29oct 1994 19：43：31 GMT | | lf-None-Match | 允许在对应的内容未被修改的情况下返回304未修改 | lf-None-Match: &quot;37060cd8c284d8af7ad3082f209582d &quot; | | lf-Range | 如果该实体未被修改过 ，则向我发送我所缺少的那 一个或多个部分； 否则 ， 发送整个新的实体 | f-Range： &quot;737060cd8c284d8af7ad3082f209582d &quot; | | Range | 仅请求某个实体的一部分 | Range: bytes=500 - 999 | | user-Agent | 浏览器的浏览器身份标识字符 串 | user-Agent: Mozilla/5 . 0 (x11 Lnu X86.64； rv：12 0) Gecko/20100101 Firefox/21 . 0 | | origin | 发起一个针对 跨来源资源共享的请求 | origin： http：//www. example-social-network. com |</p><h3 id="说说http-常见的状态码有哪些-适用场景" tabindex="-1">说说HTTP 常见的状态码有哪些，适用场景? <a class="header-anchor" href="#说说http-常见的状态码有哪些-适用场景" aria-label="Permalink to &quot;说说HTTP 常见的状态码有哪些，适用场景?&quot;">​</a></h3><p>状态码第一位数字决定了不同的响应状态，有如下 1 表示消息 2 表示成功 3 表示重定向 4 表示请求错误 5 表示服务器错误</p><p>1xx 代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束常见的有:</p><ul><li>100(客户端继续发送请求，这是临时响应》: 这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</li><li>101:服务器根据客户端的请求切换协议，主要用于websocket或http2升级</li></ul><p>2xx 代表请求已成功被服务器接收、理解、并接受 常见的有:</p><ul><li>200 (成功): 请求已成功，请求所希望的响应头或数据体将随此响应返回</li><li>201 (已创建) : 请求成功并且服务器创建了新的资源</li><li>202 (已创建) : 服务器已经接收请求，但尚未处理</li><li>203(非授权信息) : 服务器已成功处理请求，但返回的信息可能来自另一来源 204 (无内容) : 服务器成功处理请求，但没有返回任何内容</li><li>205 (重置内容) : 服务器成功处理请求，但没有返回任何内容</li><li>206 (部分内容) : 服务器成功处理了部分请求</li></ul><p>3xx 表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向 常见的有:</p><ul><li>300 (多种选择) : 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent)选择项操作，或提供操作列表供请求者选择</li><li>301 (永久移动) : 请求的网页已永久移动到新位置。服务器返回此响应 (对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置</li><li>302(临时移动): 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>303(查看其他位置): 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li><li>305(使用代理): 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求</li></ul><p>者应使用代理</p><ul><li>307 (临时重定向) :服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li></ul><p>4xx 代表了客户端看起来可能发生了错误，妨碍了服务器的处理常见的有:</p><ul><li>400 (错误请求) :服务器不理解请求的语法</li><li>401 (未授权) :i请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应</li><li>403 (禁止) :服务器拒绝请求</li><li>404 (未找到) : 服务器找不到请求的网页</li><li>405 (方法禁用) : 禁用请求中指定的方法</li><li>406 (不接受) : 无法使用请求的内容特性响应请求的网页</li><li>407(需要代理授权) : 此状态代码与 401 (未授权)类似，但指定请求者应当授权使用代理</li><li>408(请求超时) : 服务器等候请求时发生超时</li></ul><p>5xx 表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生 常见的有:</p><ul><li>500 (服务器内部错误) : 服务器遇到错误，无法完成请求</li><li>501 (尚未实施): 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此 code</li><li>502 (错误网关) :服务器作为网关或代理，从上游服务器收到无效响应</li><li>503 (服务不可用) :服务器目前无法使用 (由于超载或停机维护</li><li>504 (网关超时) :服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li><li>505(HTTP 版本不受支持) : 服务器不支持请求中所用的 HTTP 协议版本</li></ul><p>下面给出一些状态码的适用场景:</p><ul><li>100: 客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传</li><li>206:一般用来做断点续传，或者是视频文件等大文件的加载</li><li>301: 永久重定向会缓存。新域名替换旧域名，日的域名不再使用时，用户访问旧域名时用301就重</li></ul><p>定向到新的域名</p><ul><li>302: 临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面</li><li>304:协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分</li><li>400:参数有误，请求无法被服务器识别</li><li>403: 告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回</li><li>404:服务器找不到资源时，或者服务器拒绝请求又不想说明理由时</li><li>503:服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503</li><li>504:网关超时</li></ul><h3 id="说说-http1-0-11-2-0-的区别" tabindex="-1">说说 HTTP1.0/11/2.0 的区别? <a class="header-anchor" href="#说说-http1-0-11-2-0-的区别" aria-label="Permalink to &quot;说说 HTTP1.0/11/2.0 的区别?&quot;">​</a></h3><p>HTTP1.0 HTTP 协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本HTTP 1.0 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个 TCP 连接服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求简单来讲，每次与服务器交互，都需要新开一个连接</p><p><img src="https://qn.huat.xyz/mac/202402082251323.png" alt="图片 (2)"></p><p>例如，解析 htmL 文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接最终导致，一个 htmL文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接这种形式明显造成了性能上的缺陷。如果需要建立长连接，需要设置一个非标准的Connection字段Connection: keep-alive</p><p>HTTP1.1 在 HTTP1.1 中，默认支持长连接(Connection: keep-alive)，即在一个TCP连接上可以传送多个:HTTP请求和响应，减少了建立和关闭连接的消耗和延迟建立一次连接，多次请求均由这个连接完成</p><p><img src="https://qn.huat.xyz/mac/202402082252674.png" alt="图片 (3)"></p><p>这样，在加载htmL;文件的时候，文件中多个请求和响应就可以在一个连接中传输同时，HTTP 1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间 同时，HTTP1.1 在 HTTP1.0 的基础上，增加更多的请求头和响应头来完善的功能，如下·</p><ul><li>引入了更多的缓存控制策略，如f-Unmodified-Since,lf-Match,If-None-Match等缓存头来控制缓存策略</li><li>引入range，允许值请求资源某个部分</li><li>引入host，实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点</li></ul><p>并且还添加了其他的请求方法 options、put、delete...</p><p>HTTP2.0 在相比之前版本，性能上有很大的提升，如添加了一个特性:</p><ul><li>多路复用</li><li>二进制分帧</li><li>首部压缩</li><li>服务器推送</li></ul><p>多路复用 HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞</p><p>二进制分帧 帧是HTTP2 通信中最小单位信息 HTTP2采用二进制格式传输数据，而非HTTP 1.x的文本格式，解析起来更高效将请求和响应数据分割为更小的顿，并且它们采用二进制编码 HTTP2中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件</p><p>首部压缩 HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新 例如:下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销</p><p><img src="https://qn.huat.xyz/mac/202402082252759.png" alt="图片 (4)"></p><p>服务器推送 HTTP2:引入服务器推送，允许服务端推送资源给客户端 服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源。免得客户端再次创建连接发送请求到服务器端获取 这种方式非常合适加载静态资源</p><p><img src="https://qn.huat.xyz/mac/202402082250846.png" alt="图片.png"></p><p>9.4.总结 HTTP1.0:</p><ul><li>浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接</li></ul><p>HTTP1.1:</p><ul><li>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用</li><li>在同一个TCP连接里面，客户端可以同时发送多个请求</li><li>虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等</li><li>新增了一些请求方法</li><li>新增了一些请求头和响应头</li></ul><p>HTTP2.0:</p><ul><li>采用二进制格式而非文本格式</li><li>完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行</li><li>使用报头压缩，降低开销</li><li>服务器推送</li></ul><h3 id="为什么说https比http安全-https是如何保证安全的" tabindex="-1">为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的? <a class="header-anchor" href="#为什么说https比http安全-https是如何保证安全的" aria-label="Permalink to &quot;为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的?&quot;">​</a></h3><p>在上篇文章中，我们了解到 :HTTP 在通信过程中，存在以下问题:</p><ul><li>通信使用明文 (不加密)，内容可能被窃听。</li><li>不验证通信方的身份，因此有可能遭遇伪装</li></ul><p>而HTTPS|的出现正是解决这些问题，HTTPS 是建立在 SSL 之上，其安全性由 SSL 来保证在采用 SSL后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能</p><blockquote><p>SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全 (Transport Laver Security,TLS) 是为网络通信提供安全及数据完整性的一种安全协议</p></blockquote><p><img src="https://qn.huat.xyz/mac/202402082250018.png" alt="图片.png"></p><p>如何做 SSL的实现这些功能主要依赖于三种手段</p><ul><li>对称加密: 采用协商的密钥对数据加密</li><li>非对称加密: 实现身份认证和密钥协商</li><li>摘要算法:验证信息的完整性</li><li>数字签名:身份验证</li></ul><p>对称加密 对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性</p><p><img src="https://qn.huat.xyz/mac/202402082250857.png" alt="图片.png"></p><p>非对称加密 非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密。公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密</p><p><img src="https://qn.huat.xyz/mac/202402082250477.png" alt="图片.png"></p><p>摘要算法 实现完整性的手段主要是摘要算法，也就是常说的散列函数、哈希函数可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”</p><p><img src="https://qn.huat.xyz/mac/202402082250164.png" alt="图片.png"></p><p>摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性 比如，你发了条消息:“转账 1000 元”，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改</p><p><img src="https://qn.huat.xyz/mac/202402082250609.png" alt="图片.png"></p><p>数字签名 数字签名能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名原理其实很简单，就是用私钥加密，公钥解密签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的</p><p><img src="https://qn.huat.xyz/mac/202402082250730.png" alt="图片.png"></p><p>和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥 这时候就需要一个第三方，就是证书验证机构</p><p>CA验证机构 数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场 CA 对公钥的签名认证要求包括序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”</p><p><img src="https://qn.huat.xyz/mac/202402082251912.png" alt="图片.png"></p><ul><li>服务器的运营人员向数字证书认证机构提出公开密钥的申请</li><li>数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名</li><li>然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起</li><li>服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，则证明</li><li>认证服务器的公开密钥的是真实有效的数字证书认证机构</li><li>服务器的公开密钥是值得信赖的</li></ul><p>可以看到,:HTTPS与HTTP 虽然只差一个 SSL:，但是通信安全得到了大大的保障，通信的四大特性 都以解决，解决方式如下:</p><ul><li>机密性: 混合算法</li><li>完整性: 摘要算法</li><li>身份认证:数字签名</li><li>不可否定: 数字签名</li></ul><h3 id="如何理解cdn-说说实现原理" tabindex="-1">如何理解CDN? 说说实现原理? <a class="header-anchor" href="#如何理解cdn-说说实现原理" aria-label="Permalink to &quot;如何理解CDN? 说说实现原理?&quot;">​</a></h3><p>CDN (全称 Content Delivery Network)，即内容分发网络 构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。 CDN:的关键技术主要有内容存储和分发技术 简单来讲,CDN 就是根据用户位置分配最近的资源 于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫边缘节点，其实就是缓存了源站内容的代理服务器。如下图:</p><p><img src="https://qn.huat.xyz/mac/202402082251680.png" alt="图片.png"></p><p>原理分析 在没有应用:CDN:时，我们使用域名访问某一个站点时的路径为 用户提交域名 --&gt; 浏览器对域名进行解释--&gt;DNS解析得到目的主机的IP地址--&gt;根据IP地址访问发出请求--&gt;得到请求数据并回复 应用 CDN 后，DNS返回的不再是 IP 地址，而是一个 CNAME:(Canonical Name)别名记录，指向:CDN:的全局负载均衡 CNAME 实际上在域名解析的过程中承担了中间人 (或者说代理)的角色，这是 CDN 实现的关键</p><p>负载均衡系统 由于没有返回 IP 地址，于是本地 DNS 会向负载均衡系统再发送请求则进入到:CDN:的全局负载均，衡系统进行智能调度:</p><ul><li>看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点</li><li>看用户所在的运营商网络，找相同网络的边缘节点</li><li>检查边缘节点的负载情况，找负载较轻的节点</li><li>其他，比如节点的“健康状况”、服务能力、带宽、响应时间等</li></ul><p>结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问:CDN 的缓存代理</p><p>缓存代理 缓存系统是CDN 的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源 其中有两个衡量:CDN 服务质量的指标:</p><ul><li>命中率:用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比。</li><li>回源率: 缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比</li></ul><p>缓存系统也可以划分出层次，分成一级缓存节点和二级缓存节点。一级缓存配置高一些，直连源站.级缓存配置低一些，直连用户 回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源现在的商业CDN命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上</p><p>CDN目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度 CDN:构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速通过:CDN的负载均衡系统，智能调度边缘节点提供服务，相当于CDN 服务的大脑，而缓存系统相当于:CDN:的心脏，缓存命中直接返回给用户，否则回源</p><h3 id="说说对websocket的理解-应用场景" tabindex="-1">说说对WebSocket的理解?应用场景? <a class="header-anchor" href="#说说对websocket的理解-应用场景" aria-label="Permalink to &quot;说说对WebSocket的理解?应用场景?&quot;">​</a></h3><p>WebSocket，是一种网络传输协议，位于:0SI 模型的应用层。可在单个 TCP 连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅 客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输</p><p><img src="https://qn.huat.xyz/mac/202402082251157.png" alt="图片.png"></p><p>从上图可见:websocket 服务器与客户端通过握手连接，连接成功后，两者都能主动的向对方发送或接受数据。而在websocket出现之前，开发实时 web应用的方式为轮询。不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和CPU资源</p><p>特点 全双工 通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合例如指 A-B 的同时 B-&gt;A ，是瞬时同步的 二进制帧 采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比 http/2，WebSocket 更侧重于“实时通信”，而 HTTP/2更侧重于提高传输效率，所以两者的顿结构也有很大的区别 不像 HTTP/2，那样定义流，也就不存在多路复用、优先级等特性 自身就是全双工，也不需要服务器推送 协议名 引入ws和wss分别代表明文和密文的:websocket 协议，且默认端口使用80或443，几乎与http一致 握手 WebSocket 也要有一个握手过程，然后才能正式收发数据。客户端发送数据格式如下</p><div class="language-jsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GET</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">chatHTTP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Host</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: server.example.com</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Upgrade</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: websocket</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Connection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Upgrade</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Sec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WebSocket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: dGhlIHNhbXBsZSBub25jZQ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Origin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//example.com</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Sec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WebSocket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Protocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: chat, superchat</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Sec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WebSocket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Version</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>Connection: 必须设置Upgrade，表示客户端希望连接升级</li><li>Upgrade: 必须设置Websocket，表示希望升级到Websocket协议</li><li>Sec-WebSocket-Key: 客户端发送的一个 base64 编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept应答，否则客户端会抛出错误，并关闭连接</li><li>Sec-WebSocket-Version :表示支持的Websocket版本</li></ul><p>服务端返回的数据格式</p><div class="language-jsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HTTP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1101</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Switching Protocols</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Upgrade</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: websocket</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Connection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Upgrade</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Sec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WebSocket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: s3pPLMBiTxaQ9kYGzzhZRbK</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xOo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Sec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WebSocket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Protocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: chat</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>HTTP/1.1 101 Switching Protocols: 表示服务端接受 WebSocket 协议的客户端连接。S</li><li>ec-WebSocket-Accep: 验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里“Sec-WebSocket-Key”的值，加上一个专用的 UUID，再计算摘要</li></ul><p>优点</p><ul><li>较少的控制开销: 数据包头部协议较小，不同于http每次请求需要携带完整的头部</li><li>更强的实时性:相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少</li><li>保持创连接状态:创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证</li><li>更好的二进制支持:定义了二进制顿，更好处理二进制内容</li><li>支持扩展:用户可以扩展websocket协议、实现部分自定义的子协议</li><li>更好的压缩效果: Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li></ul><p>应用场景 基于websocket的事实通信的特点，其存在的应用场景大概有:</p><ul><li>弹幕</li><li>媒体聊天</li><li>协同编辑</li><li>基于位置的应用</li><li>体育实况更新</li><li>股票基金报价实时更新</li></ul>`,120),p=[e];function n(d,h,r,c,o,k){return l(),i("div",null,p)}const u=t(a,[["render",n]]);export{P as __pageData,u as default};
