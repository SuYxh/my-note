import{_ as e,c as a,o as t,V as r}from"./chunks/framework.hxTji2_l.js";const f=JSON.parse('{"title":"React18 与 Vue3 对比之组件通信-逻辑复用-内容分发-DOM 操作等功能","description":"","frontmatter":{},"headers":[],"relativePath":"frame/different/05-React18与Vue3对比之组件通信_逻辑复用_内容分发_DOM操作等功能.md","filePath":"frame/different/05-React18与Vue3对比之组件通信_逻辑复用_内容分发_DOM操作等功能.md","lastUpdated":1716774476000}'),_={name:"frame/different/05-React18与Vue3对比之组件通信_逻辑复用_内容分发_DOM操作等功能.md"},o=r('<h1 id="react18-与-vue3-对比之组件通信-逻辑复用-内容分发-dom-操作等功能" tabindex="-1">React18 与 Vue3 对比之组件通信-逻辑复用-内容分发-DOM 操作等功能 <a class="header-anchor" href="#react18-与-vue3-对比之组件通信-逻辑复用-内容分发-dom-操作等功能" aria-label="Permalink to &quot;React18 与 Vue3 对比之组件通信-逻辑复用-内容分发-DOM 操作等功能&quot;">​</a></h1><h2 id="组件通信对比" tabindex="-1">组件通信对比 <a class="header-anchor" href="#组件通信对比" aria-label="Permalink to &quot;组件通信对比&quot;">​</a></h2><p>Vue 父子 props，子父 emits</p><p>React 父子 props，子父回调函数</p><p>emits 自定义事件和回调函数，但实际上是一样的思想。</p><p>跨组件的通信方案也很类似，都是一种依赖注入的方式来实现的。</p><h2 id="功能复用处理" tabindex="-1">功能复用处理 <a class="header-anchor" href="#功能复用处理" aria-label="Permalink to &quot;功能复用处理&quot;">​</a></h2><p>Vue 选项式采用：mixins 混入；组合式采用：use 函数</p><p>React 类组件采用：Render Props、HOC；函数组件：use 函数</p><p>可以发现组合式 API 和函数组件都是采用 use 函数，所以基本复用是差不多的思想，这也是两个框架推荐的用法。</p><h2 id="内容分发处理" tabindex="-1">内容分发处理 <a class="header-anchor" href="#内容分发处理" aria-label="Permalink to &quot;内容分发处理&quot;">​</a></h2><p>Vue 通过<code>&lt;slot&gt;</code>插槽，进行接收</p><p>React 通过 props.children，进行接收</p><h2 id="原生-dom-处理" tabindex="-1">原生 DOM 处理 <a class="header-anchor" href="#原生-dom-处理" aria-label="Permalink to &quot;原生 DOM 处理&quot;">​</a></h2><p>Vue 通过 ref 属性</p><p>React 也通过 ref 属性处理</p><p>思路都是差不多的，就是给元素添加 ref 属性，在跟对象或字符串绑定在一起，这样就可以直接获取到 DOM 元素。</p>',17),c=[o];function p(s,d,i,n,l,h){return t(),a("div",null,c)}const m=e(_,[["render",p]]);export{f as __pageData,m as default};
