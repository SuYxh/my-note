import{_ as e,c as i,o as l,V as o}from"./chunks/framework.hxTji2_l.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"fe/basicknowledge/browser/缓存.md","filePath":"fe/basicknowledge/browser/缓存.md","lastUpdated":1721552467000}'),d={name:"fe/basicknowledge/browser/缓存.md"},c=o('<h3 id="浏览器缓存机制" tabindex="-1">浏览器缓存机制 <a class="header-anchor" href="#浏览器缓存机制" aria-label="Permalink to &quot;浏览器缓存机制&quot;">​</a></h3><ul><li>浏览器在发送请求前先判断是否命中强缓存 <ul><li>命中则不发送请求直接使用缓存，否则进行下一步</li></ul></li><li>浏览器发送请求后会由服务器判断是否命中协商缓存 <ul><li>命中则从缓存获取资源，否则进行下一步</li></ul></li><li>浏览器直接使用服务器返回的资源并更新缓存</li></ul><h3 id="强缓存-200-ok" tabindex="-1">强缓存（200 OK） <a class="header-anchor" href="#强缓存-200-ok" aria-label="Permalink to &quot;强缓存（200 OK）&quot;">​</a></h3><ul><li><code>Expires</code> 是服务器告诉浏览器的缓存过期时间（值为 <code>GMT</code> 时间，即格林尼治时间） <ul><li><code>HTTP1.0</code> 的产物</li><li>受本地时间影响</li><li>设置的值为 <code>max-age=xxx</code>（xxx 是 秒）</li></ul></li><li><code>Cache-Control</code> 用于控制缓存的行为 <ul><li>是 <code>HTTP1.1</code> 的产物</li><li>取值 <ul><li><code>public</code>：允许被客户端和代理服务器缓存</li><li><code>private</code>：只允许被客户端缓存（默认值）</li><li><code>no-cache</code>：允许被客户端和代理服务器缓存，但在使用缓存时需要经过协商缓存来验证决定</li><li><code>no-store</code>：所有内容都不会被缓存，即不使用强制缓存也不使用协商缓存每次请求都会下载完整的资源</li><li><code>maxage=xxx</code>：设置客户端和代理服务器的缓存时间，表示缓存内容将在 xxx 秒后失效</li><li><code>s-maxage=xxx</code>：设置代理服务器的缓存时间（优先级比 <code>max-age</code> 高）</li></ul></li></ul></li></ul><div class="warning custom-block"><p class="custom-block-title">Cache-Control 注意点</p><p><code>no-cache</code> 名字存在误导，其并不是不缓存数据，只是在使用缓存时需要经过协商缓存来验证决定<br><code>max-age=0</code> 和 <code>no-cache</code> 效果一致</p></div><h4 id="缓存位置" tabindex="-1">缓存位置 <a class="header-anchor" href="#缓存位置" aria-label="Permalink to &quot;缓存位置&quot;">​</a></h4><ul><li>内存缓存（memory cache） <ul><li>快速读取（内存缓存将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取）</li><li>进程关闭时数据会被清除</li><li>不请求网络资源，资源存在内存中一般 <code>JS</code> 和图片文件会存入内存</li><li>状态码：<code>200（from memory cache）</code></li></ul></li><li>硬盘缓存（disk cache） <ul><li>写入硬盘文件进行 <code>I/O</code> 操作</li><li>进程关闭时数据不会被清除</li><li>速度比 <code>memory cache</code> 慢</li><li>不请求网络资源，资源存在磁盘中一般非脚本会存在磁盘中，如 <code>css</code></li><li>状态码：<code>200（from disk cache）</code></li></ul></li><li>代理服务器缓存（server worker） <ul><li>可以拦截处理页面的所有网络请求</li><li>仅 <code>HTTPS</code> 下可用、存在兼容问题</li><li>状态码：<code>200（from service worker）</code></li></ul></li></ul><h3 id="协商缓存-304-not-modified" tabindex="-1">协商缓存（304 Not Modified） <a class="header-anchor" href="#协商缓存-304-not-modified" aria-label="Permalink to &quot;协商缓存（304 Not Modified）&quot;">​</a></h3><h4 id="last-modified-和-if-modified-since" tabindex="-1">Last-Modified 和 If-Modified-Since <a class="header-anchor" href="#last-modified-和-if-modified-since" aria-label="Permalink to &quot;Last-Modified 和 If-Modified-Since&quot;">​</a></h4><p><code>Last-Modified</code> 表示资源的最后修改时间，值为 <code>GMT</code> 格式时间字符串，精确到秒</p><ul><li>浏览器第一次请求时，服务器会在响应头中返回请求资源的上次更新时间 <code>Last-Modified</code></li><li>当浏览器再次请求时，会在请求头中携带 <code>If-Modified-Since</code> 值为上次请求返回的 <code>Last-Modified</code></li><li>服务器收到请求后，会根据请求头中的 <code>If-Modified-Since</code> 和该资源在服务器的最后被修改时间做对比 <ul><li>大于 <code>If-Modified-Since</code> 重新返回资源文件，状态码为 200</li><li>小于 <code>If-Modified-Since</code> 资源无更新继续使用缓存文件，状态码为 304</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">Last-Modified 存在的问题</p><ul><li>时间精度为秒级会出现误差情况，对文件修改精度有严格要求的场景不能满足</li><li>在集群服务器上各个服务器上的文件时间可能不同</li><li>如果用旧文件覆盖新文件，因为时间更前浏览器不会请求旧文件</li><li>编辑了文件但未修改，会导致缓存失效</li></ul></div><h4 id="etag-和-if-none-match" tabindex="-1">ETag 和 If-None-Match <a class="header-anchor" href="#etag-和-if-none-match" aria-label="Permalink to &quot;ETag 和 If-None-Match&quot;">​</a></h4><p><code>ETag</code> 是服务器通过算法对资源内容计算出的一个唯一标识（文件 <code>hash</code>）其有强弱之分</p><ul><li>强 <code>Etag</code><ul><li><code>ETag: &quot;&lt;etag_value&gt;&quot;</code></li><li>资源发生任何改变都会立刻更新</li><li>难生成，利于比较</li></ul></li><li>弱 <code>Etag</code>（使用 <code>W/</code> 标识） <ul><li><code>ETag: W/&quot;&lt;etag_value&gt;&quot;</code></li><li>只在资源发生本质变化时更新</li><li>易生成，不利于比较</li></ul></li></ul><h5 id="过程" tabindex="-1">过程 <a class="header-anchor" href="#过程" aria-label="Permalink to &quot;过程&quot;">​</a></h5><ul><li>浏览器第一次请求时，服务器会在响应头中返回当前资源文件的一个唯一标识 <code>ETag</code></li><li>当浏览器再次请求时，会在请求头中携带 <code>If-None-Match</code> 值为上次请求返回的 <code>ETag</code></li><li>通过接收的 <code>ETag</code> 和服务器重新生成的 <code>ETag</code> 进行对比 <ul><li>不一致 重新返回资源文件，状态码为 200</li><li>一致 资源无更新继续使用缓存文件，状态码为 304</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">Last-Modified 和 Etag 对比</p><ul><li>精确度上：<code>Etag</code> 优于 <code>Last-Modified</code></li><li>性能上：<code>Etag &lt; Last-Modified</code> 每次生成 <code>ETag</code> 都需要进行读写操作，而 <code>Last-Modified</code> 只需要读取操作</li><li>优先级：服务器校验优先考虑 <code>Etag</code>（先判断 <code>Etag</code> 是否变化，如果 <code>Etag</code> 没有变化再判断 <code>Last-Modified</code>）</li></ul></div><h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><table><thead><tr><th>强缓存</th><th>协商缓存</th></tr></thead><tbody><tr><td>不常变化的文件<br>带 hash 值的 css js 图片</td><td>频繁变动的文件<br>html 文件</td></tr></tbody></table><h3 id="用户行为对缓存的影响" tabindex="-1">用户行为对缓存的影响 <a class="header-anchor" href="#用户行为对缓存的影响" aria-label="Permalink to &quot;用户行为对缓存的影响&quot;">​</a></h3><ul><li>地址栏输入 <ul><li>查找 <code>disk cache</code>（磁盘缓存）中是否有匹配，有则使用缓存，没有则发送网络请求</li></ul></li><li>普通刷新（F5） <ul><li>因为浏览器 <code>tab</code> 标签并没有关闭，因此 <code>memory cache</code> （内存缓存）是可用的，会被优先使用，其次使用 <code>disk cache</code>（磁盘缓存）</li><li>跳过强缓存规则，直接走协商缓存</li></ul></li><li>强制刷新（Ctrl + F5） <ul><li>浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control: no-cache</code> （为了兼容还带了 <code>Pragma: no-cache</code>）服务器直接返回 200 和最新内容。</li><li>跳过所有缓存规则</li></ul></li></ul>',22),a=[c];function t(r,s,u,h,n,f){return l(),i("div",null,a)}const g=e(d,[["render",t]]);export{b as __pageData,g as default};
