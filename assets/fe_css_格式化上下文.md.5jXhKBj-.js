import{_ as e,c as o,o as d,V as c}from"./chunks/framework.hxTji2_l.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"fe/css/格式化上下文.md","filePath":"fe/css/格式化上下文.md","lastUpdated":1718603374000}'),t={name:"fe/css/格式化上下文.md"},l=c('<p><strong>格式化上下文</strong>指决定渲染区域内节点的排版、关系和互相作用的渲染规则。简而言之，网页中有一个<code>&lt;ul&gt;</code>及其多个子节点<code>&lt;li&gt;</code>，<code>格式上下文</code>决定这些<code>&lt;li&gt;</code>如何排版，<code>&lt;li&gt;</code>与<code>&lt;li&gt;</code>间处于何种关系，以及<code>&lt;li&gt;</code>与<code>&lt;li&gt;</code>间如何互相影响。</p><p><code>格式上下文</code>由以下部分组成，其中<strong>块格式化上下文</strong>与<strong>行内格式化上下文</strong>最重要。</p><table><thead><tr><th>上下文</th><th>缩写</th><th>版本</th><th>声明</th></tr></thead><tbody><tr><td><strong>块格式化上下文</strong></td><td><code>BFC</code></td><td><code>2</code></td><td>块级盒子容器</td></tr><tr><td><strong>行内格式化上下文</strong></td><td><code>IFC</code></td><td><code>2</code></td><td>行内盒子容器</td></tr><tr><td><strong>弹性格式化上下文</strong></td><td><code>FFC</code></td><td><code>3</code></td><td>弹性盒子容器</td></tr><tr><td><strong>格栅格式化上下文</strong></td><td><code>GFC</code></td><td><code>3</code></td><td>格栅盒子容器</td></tr></tbody></table><h3 id="块格式化上下文" tabindex="-1">块格式化上下文 <a class="header-anchor" href="#块格式化上下文" aria-label="Permalink to &quot;块格式化上下文&quot;">​</a></h3><p><code>BFC</code>是网页中一个独立且隔离的渲染区域，容器中的子节点不会在布局中影响到外面的节点，反之亦然。</p><p>以下是我意译<code>W3C标准</code>与平时一些开发经验的总结所得，也结合一些自己对<code>BFC</code>的理解。</p><blockquote><p>规则</p></blockquote><ul><li>节点在垂直方向上按顺序排列</li><li>节点的垂直方向距离由<code>margin</code>决定，相邻节点的<code>margin</code>会发生重叠，以最大<code>margin</code>为合并值</li><li>节点的<code>margin-left/right</code>与父节点的<code>左边/右边</code>相接触，即使处于浮动也如此，除非自行形成<code>BFC</code></li><li><code>BFC</code>是一个隔离且不受外界影响的独立容器</li><li><code>BFC</code>不会与同级浮动区域重叠</li><li><code>BFC</code>在计算高度时其浮动子节点也参与计算</li></ul><blockquote><p>成因</p></blockquote><ul><li>根节点：<code>html</code></li><li>非溢出可见节点：<code>overflow:!visible</code></li><li>浮动节点：<code>float:left/right</code></li><li>绝对定位节点：<code>position:absolute/fixed</code></li><li>被定义为块级的非块级节点：<code>display:inline-block/table-cell/table-caption/flex/inline-flex/grid/inline-grid</code></li><li>父节点与正常文档流的子节点(非浮动)自动形成<code>BFC</code></li></ul><blockquote><p>场景</p></blockquote><ul><li>清除浮动</li><li>已知宽度水平居中</li><li>防止浮动节点被覆盖</li><li>防止垂直<code>margin</code>合并</li></ul><p><code>margin塌陷</code>在排版时稍微不注意就会出现，可用<code>BFC</code>的概念回答了。所谓的塌陷其实是两个<code>BFC</code>的相邻盒或父子盒互相作用时产生的效果，两个盒子会取相邻边最大<code>margin</code>作为相邻边的共用<code>margin</code>。</p><p>在此再补充一些<code>margin折叠</code>的计算问题。</p><ul><li>两个盒子相邻边的<code>margin</code>都为正值，取最大值</li><li>两个盒子相邻边的<code>margin</code>都为负值，取最小值，两者会互相重合</li><li>两个盒子相邻边的<code>margin</code>一正一负，取两者相加值，若结果为负，两者会互相重合</li></ul><h3 id="行内格式化上下文" tabindex="-1">行内格式化上下文 <a class="header-anchor" href="#行内格式化上下文" aria-label="Permalink to &quot;行内格式化上下文&quot;">​</a></h3><p><code>IFC</code>的高度由容器中最大高度的子节点的实际高度确定，不受垂直方向的<code>margin/padding</code>的影响。另外，<code>IFC</code>中不能存在块元素，若加入块元素则会产生相应个数的匿名块并互相隔离，即产生相应个数的<code>IFC</code>，每个<code>IFC</code>对外表现为块级元素并垂直排列。</p><p>以下是我意译<code>W3C标准</code>与平时一些开发经验的总结所得，也结合一些自己对<code>IFC</code>的理解。</p><blockquote><p>规则</p></blockquote><ul><li>节点在水平方向上按顺序排列</li><li>节点无法声明宽高，其<code>margin/padding</code>在水平方向有效在垂直方向无效</li><li>节点在垂直方向上以不同形式对齐</li><li>节点宽度由包括块与浮动决定，节点高度由行高决定</li></ul><blockquote><p>成因</p></blockquote><ul><li>声明<code>display:inline[-x]</code>形成行内元素</li><li>声明<code>line-height</code></li><li>声明<code>vertical-align</code></li><li>声明<code>font-size</code></li></ul><h3 id="弹性格式化上下文" tabindex="-1">弹性格式化上下文 <a class="header-anchor" href="#弹性格式化上下文" aria-label="Permalink to &quot;弹性格式化上下文&quot;">​</a></h3><p>声明<code>display</code>为<code>flex</code>或<code>inline-flex</code>时，节点会生成一个<code>FFC</code>的独立容器，主要用于响应式布局。</p><h3 id="格栅格式化上下文" tabindex="-1">格栅格式化上下文 <a class="header-anchor" href="#格栅格式化上下文" aria-label="Permalink to &quot;格栅格式化上下文&quot;">​</a></h3><p>声明<code>display</code>为<code>grid</code>或<code>inline-grid</code>时，节点会生成一个<code>GFC</code>的独立容器，主要用于响应式布局。</p><p><code>GFC</code>有点像<code>&lt;table&gt;</code>，同为二维表格，但<code>GFC</code>有更丰富的属性控制行列、对齐以及更为精细的渲染语义与控制。不过因为兼容性不是特别好，所以也不会讲述基于<code>GFC</code>的格栅布局了。</p>',27),i=[l];function a(r,n,s,p,g,h){return d(),o("div",null,i)}const b=e(t,[["render",a]]);export{_ as __pageData,b as default};
