import{_ as e,c as i,o as a,V as s}from"./chunks/framework.hxTji2_l.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"fe/basicknowledge/browser/页面渲染.md","filePath":"fe/basicknowledge/browser/页面渲染.md","lastUpdated":1718171256000}'),l={name:"fe/basicknowledge/browser/页面渲染.md"},t=s('<h3 id="dom树" tabindex="-1">DOM树 <a class="header-anchor" href="#dom树" aria-label="Permalink to &quot;DOM树&quot;">​</a></h3><p><img src="https://qn.huat.xyz/mac/202406121259105.png" alt="下载"></p><h3 id="cssom树" tabindex="-1">CSSOM树 <a class="header-anchor" href="#cssom树" aria-label="Permalink to &quot;CSSOM树&quot;">​</a></h3><p><img src="https://qn.huat.xyz/mac/202406121300750.png" alt="下载 (1)"></p><h3 id="render-tree渲染树" tabindex="-1">Render-Tree渲染树 <a class="header-anchor" href="#render-tree渲染树" aria-label="Permalink to &quot;Render-Tree渲染树&quot;">​</a></h3><p><img src="https://qn.huat.xyz/mac/202406121300031.png" alt="下载 (2)"></p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li>处理 HTML 标记，构建 DOM 树</li><li>处理 CSS 标记，构建 CSSOM 树</li><li>将 DOM 树和 CSSOM 树融合成渲染树</li><li>根据生成的渲染树，计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流 =&gt; 布局（Layout）或 重排（reflow）</li><li>根据渲染树以及回流得到的几何信息，得到节点的绝对像素 =&gt; 绘制（painting）</li></ul><p><img src="https://qn.huat.xyz/mac/202406121301016.png" alt="下载 (3)"></p><h3 id="优化方案" tabindex="-1">优化方案 <a class="header-anchor" href="#优化方案" aria-label="Permalink to &quot;优化方案&quot;">​</a></h3><ul><li><p>标签语义化和避免深层次嵌套</p></li><li><p>CSS选择器渲染是从右到左</p></li><li><p>尽早尽快地把CSS下载到客户端（充分利用HTTP多请求并发机制）</p><ul><li><code>style</code></li><li><code>link</code></li><li><code>@import</code></li><li>放到顶部</li></ul></li><li><p>避免阻塞的JS加载</p><ul><li><p><code>async</code></p></li><li><p><code>defer</code></p></li><li><p>放到底部</p><p><img src="https://qn.huat.xyz/mac/202406121301724.png" alt="下载 (4)"></p></li></ul></li><li><p>减少DOM的回流和重绘</p></li></ul><h3 id="重绘回流" tabindex="-1">重绘回流 <a class="header-anchor" href="#重绘回流" aria-label="Permalink to &quot;重绘回流&quot;">​</a></h3><p><img src="https://qn.huat.xyz/mac/202406121302709.png" alt="image-20240612130252687"></p><h4 id="回流" tabindex="-1">回流 <a class="header-anchor" href="#回流" aria-label="Permalink to &quot;回流&quot;">​</a></h4><p><strong>回流</strong>又称<strong>重排</strong>，指改变<code>几何属性</code>的渲染。感觉“回流”较高大上，后续统称回流吧。</p><p>可理解为将整个网页填白，对内容重新渲染一次。只不过以人眼的感官速度看浏览器回流是不会有任何变化的，若你拥有闪电侠的感官速度看浏览器回流(<code>实质是将时间调慢</code>)，就会发现每次回流都会将网页清空，从左上角第一个像素点从左到右从上到下这样一点一点渲染，直至右下角最后一个像素点。每次回流都会呈现该过程，只是感受不到而已。</p><p>渲染树的节点发生改变，影响了节点的几何属性，导致节点位置发生变化，此时就会触发浏览器回流并重新生成渲染树。回流意味着节点的几何属性改变，需重新计算并生成渲染树，导致渲染树的全部或部分发生变化。</p><h4 id="重绘" tabindex="-1">重绘 <a class="header-anchor" href="#重绘" aria-label="Permalink to &quot;重绘&quot;">​</a></h4><p><strong>重绘</strong>指改变<code>外观属性</code>而不影响<code>几何属性</code>的渲染。相比回流，重绘在两者中会温和一些，后续谈到的<code>CSS性能优化</code>就会基于该特性展开。</p><p>渲染树的节点发生改变，但不影响节点的几何属性。由此可见，回流对浏览器性能的消耗高于重绘且回流一定伴随重绘，重绘却不一定伴随回流。</p><p>为何回流一定伴随重绘？整个节点的位置都变了，肯定要重新渲染它的外观属性啊！</p><h4 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-label="Permalink to &quot;属性&quot;">​</a></h4><p><strong>几何属性</strong>：包括布局、尺寸等可用数学几何衡量的属性</p><ul><li>布局：<code>display</code>、<code>float</code>、<code>position</code>、<code>list</code>、<code>table</code>、<code>flex</code>、<code>columns</code>、<code>grid</code>等</li><li>尺寸：<code>margin</code>、<code>padding</code>、<code>border</code>、<code>width</code>、<code>height</code>等</li></ul><p><strong>外观属性</strong>：包括界面、文字等可用状态向量描述的属性</p><ul><li>界面：<code>appearance</code>、<code>outline</code>、<code>background</code>、<code>mask</code>、<code>box-shadow</code>、<code>box-reflect</code>、<code>filter</code>、<code>opacity</code>、<code>clip</code>等</li><li>文字：<code>text</code>、<code>font</code>、<code>word</code>等</li></ul><h3 id="避免回流" tabindex="-1">避免回流 <a class="header-anchor" href="#避免回流" aria-label="Permalink to &quot;避免回流&quot;">​</a></h3><p><img src="https://qn.huat.xyz/mac/202406121303420.png" alt="image-20240612130332397"></p><p><img src="https://qn.huat.xyz/mac/202406121303398.png" alt="image-20240612130358372"></p><p><img src="https://qn.huat.xyz/mac/202406121304677.png" alt="image-20240612130414656"></p><p><img src="https://qn.huat.xyz/mac/202406121304794.png" alt="image-20240612130433765"></p><h3 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h3><p>回流重绘在操作节点样式时频繁出现，同时也存在很大程度上的性能问题。回流成本比重绘成本高得多，一个节点的回流很有可能导致子节点、兄弟节点或祖先节点的回流。在一些高性能电脑中可能无影响，但回流发生在手机中(<code>明摆说某些安卓手机</code>)，就会减缓加载速度，增加电量消耗。</p><p>在上章引出一个定向法则：<strong>回流必定引发重绘，重绘不一定引发回流</strong>，可利用该法则解决一些因为回流重绘而引发的性能问题。在优化性能前，需了解什么情况可能产生性能问题，以下罗列一些常见情况。</p><ul><li>改变窗口大小</li><li>修改盒模型</li><li>增删样式</li><li>重构布局</li><li>重设尺寸</li><li>改变字体</li><li>改动文字</li></ul><p>很多同学可能不知，回流重绘其实与浏览器的<code>事件循环</code>有关，以下源自对<a href="https://link.juejin.cn/?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fwebappapis.html%23event-loop-processing-model" title="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noreferrer">HTML文档</a>的理解。</p><ul><li>浏览器刷新频率为<code>60Hz</code>，即每<code>16.6ms</code>更新一次</li><li>执行事件循环完成微任务</li><li>判断<code>document</code>是否需更新</li><li>判断<code>resize/scroll</code>事件是否存在，存在则触发事件</li><li>判断<code>Media Query</code>是否触发</li><li>更新动作并发送事件</li><li>判断<code>document.isFullScreen</code>是否为<code>true</code>(全屏)</li><li>执行<code>requestAnimationFrame</code>回调</li><li>执行<code>IntersectionObserver</code>回调</li><li>更新界面</li></ul><p>上述过程就是浏览器每帧可能会做到的事情，若在一帧中有空闲时间，就会执行<code>requestIdleCallback</code>回调。</p><p>回到正题，通过定向法则<strong>回流必定引发重绘，重绘不一定引发回流</strong>可知，尽量减少回流重绘，就是<code>CSS性能优化</code>中一个很好的指标。</p><blockquote><p>如何减少和避免回流重绘</p></blockquote><h5 id="使用visibility-hidden替换display-none" tabindex="-1">使用visibility:hidden替换display:none <a class="header-anchor" href="#使用visibility-hidden替换display-none" aria-label="Permalink to &quot;使用visibility:hidden替换display:none&quot;">​</a></h5><p>从以下方面对比<code>display:none</code>与<code>visibility:hidden</code>，<code>display:none</code>简称<code>DN</code>，<code>visibility:hidden</code>简称<code>VH</code>。</p><ul><li><strong>占位表现</strong><ul><li>DN不占据空间</li><li>VH占据空间</li></ul></li><li><strong>触发影响</strong><ul><li>DN触发回流重绘</li><li>VH触发重绘</li></ul></li><li><strong>过渡影响</strong><ul><li>DN影响过渡不影响动画</li><li>VH不影响过渡不影响动画</li></ul></li><li><strong>株连效果</strong><ul><li>DN后自身及其子节点全都不可见</li><li>VH后自身及其子节点全都不可见但可声明子节点<code>visibility:visible</code>单独显示</li></ul></li></ul><p>两者的占位表现、触发影响和株连效果就能说明<code>VH</code>代替<code>DN</code>的好处，从两者区别中就能找出恰当的答案了。</p><h5 id="使用transform代替top" tabindex="-1">使用transform代替top <a class="header-anchor" href="#使用transform代替top" aria-label="Permalink to &quot;使用transform代替top&quot;">​</a></h5><p><code>top</code>是几何属性，操作<code>top</code>会改变节点位置引发回流，使用<code>transform:translate3d(x,0,0)</code>代替<code>top</code>，只会引发图层重绘，还会间接启动GPU加速。</p><h5 id="避免使用table布局" tabindex="-1">避免使用Table布局 <a class="header-anchor" href="#避免使用table布局" aria-label="Permalink to &quot;避免使用Table布局&quot;">​</a></h5><p>牵一发而动全身用在<code>Table布局</code>身上就很适合了，可能很小的一个改动就会造成整个<code>&lt;table&gt;</code>回流，有兴趣的同学可用<code>Chrome Devtools</code>的<code>Performance</code>调试看看，在此就不演示了。</p><p>通常可用<code>&lt;ul&gt;</code>、<code>&lt;li&gt;</code>和<code>&lt;span&gt;</code>等标签取代<code>table系列标签</code>生成表格。</p><h5 id="避免规则层级过多" tabindex="-1">避免规则层级过多 <a class="header-anchor" href="#避免规则层级过多" aria-label="Permalink to &quot;避免规则层级过多&quot;">​</a></h5><p>浏览器的<code>CSS解析器</code>解析<code>css文件</code>时，对<code>CSS规则</code>是从右到左匹配查找，样式层级过多会影响回流重绘效率，建议保持<code>CSS规则</code>在<code>3层</code>左右。</p><h5 id="避免节点属性值放在循环中当成循环变量" tabindex="-1">避免节点属性值放在循环中当成循环变量 <a class="header-anchor" href="#避免节点属性值放在循环中当成循环变量" aria-label="Permalink to &quot;避免节点属性值放在循环中当成循环变量&quot;">​</a></h5><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> top</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).style.top; console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(top); }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>呵呵，每次循环操作<code>DOM</code>都会发生回流，应在循环外部使用变量保存一些不会变化的<code>DOM映射值</code>。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> top</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).style.top; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(top); }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h5 id="动态改变类而不改变样式" tabindex="-1">动态改变类而不改变样式 <a class="header-anchor" href="#动态改变类而不改变样式" aria-label="Permalink to &quot;动态改变类而不改变样式&quot;">​</a></h5><p>不要尝试每次操作<code>DOM</code>改变节点样式，这样会频繁触发回流。</p><p>更好的方式是使用新的类名预设节点样式，在执行逻辑操作时收集并确认最终更换的类名集合，在适合时机一次性动态替换原来的类名集合。有点像<code>vue</code>的<code>依赖收集机制</code>，不知这样描述会不会更易理解。</p><p>大家可研究强大的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.runoob.com%2Fjsref%2Fprop-element-classlist.html" title="https://www.runoob.com/jsref/prop-element-classlist.html" target="_blank" rel="noreferrer">classList</a>，它能满足我所说的需求。</p><h5 id="将频繁回流重绘的节点设置为图层" tabindex="-1">将频繁回流重绘的节点设置为图层 <a class="header-anchor" href="#将频繁回流重绘的节点设置为图层" aria-label="Permalink to &quot;将频繁回流重绘的节点设置为图层&quot;">​</a></h5><p>渲染过程最后一步，提到将回流重绘生成的图层逐张合并并显示在屏幕中。可将其理解成<code>Photoshop</code>的图层，若不对图层添加关联，图层间是不会互相影响的。同理，在浏览器中设置频繁回流或重绘的节点为一张新图层，那新图层就能够阻止节点的渲染行为影响别的节点，这张图层中如何变化都无法影响到其他图层。</p><p>设置新图层有两种方式，将节点设置为<code>&lt;video&gt;</code>或<code>&lt;iframe&gt;</code>，为节点声明<code>will-change</code>。<code>will-change</code>是一个很叼的属性，第12章会详细讲述。</p><h5 id="使用requestanimationframe作为动画帧" tabindex="-1">使用requestAnimationFrame作为动画帧 <a class="header-anchor" href="#使用requestanimationframe作为动画帧" aria-label="Permalink to &quot;使用requestAnimationFrame作为动画帧&quot;">​</a></h5><p>动画速度越快，回流次数越多，上述提到浏览器刷新频率为<code>60Hz</code>，即每<code>16.6ms</code>更新一次，而<code>requestAnimationFrame()</code>正是以<code>16.6ms</code>的速度更新一次，所以可用<code>requestAnimationFrame()</code>代替<code>setInterval()</code>。</p>',64),o=[t];function d(n,c,r,h,p,k){return a(),i("div",null,o)}const m=e(l,[["render",d]]);export{u as __pageData,m as default};
