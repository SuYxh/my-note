import{_ as e,c as o,o as i,V as d}from"./chunks/framework.hxTji2_l.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"fe/css/盒模型.md","filePath":"fe/css/盒模型.md","lastUpdated":1721552467000}'),s={name:"fe/css/盒模型.md"},c=d('<div class="tip custom-block"><p class="custom-block-title">什么是盒模型？</p><p>当对一个文档进行布局时，浏览器的渲染引擎会根据标准之一的 <strong><code>CSS</code> 基础框盒模型</strong>（CSS basic box model），将所有元素表示为一个个矩形的盒子；<code>CSS</code> 决定这些盒子的大小、位置以及属性（如颜色、背景、边框尺寸等）</p><p>每个盒子（即盒模型）从外到内由这四个部分组成</p><ul><li><code>margin</code> 外边距（不计入盒子的实际大小）</li><li><code>border</code> 边框</li><li><code>padding</code> 内边距</li><li><code>content</code> 内容</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="noreferrer">CSS 基础框盒模型介绍 - CSS：层叠样式表 | MDN</a></p></div><p>盒模型分为 <strong><code>W3C</code> 标准盒模型</strong>和 <strong><code>IE</code> 盒模型</strong>，其区别只有一个：<strong>计算盒子实际大小（即总宽度/总高度）的方式不一样</strong></p><blockquote><p>以宽度计算来举 🌰</p></blockquote><ul><li><code>W3C</code> 标准盒模型（默认） <ul><li><strong>盒子实际宽 = <code>width</code> + <code>padding</code> + <code>border</code></strong></li><li>其中 <strong><code>width</code> 只包含 <code>content</code></strong>（即内容区域的宽度）</li><li><strong>通过 <code>box-sizing: content-box;</code> 来设置为 <code>W3C</code> 标准盒模型</strong></li></ul></li><li><code>IE</code> 盒模型 <ul><li><strong>盒子实际宽 = <code>width</code></strong></li><li>其中 <strong><code>width</code> = <code>content</code> + <code>border</code> + <code>padding</code></strong></li><li><strong>通过 <code>box-sizing: border-box;</code> 来设置为 <code>IE</code> 盒模型</strong></li></ul></li></ul><h2 id="块级元素" tabindex="-1">块级元素 <a class="header-anchor" href="#块级元素" aria-label="Permalink to &quot;块级元素&quot;">​</a></h2><p>当节点的<code>display</code>声明为<code>block</code>、<code>list-item</code>、<code>table</code>、<code>flex</code>或<code>grid</code>时，该节点被标记为<strong>块级元素</strong>。块级元素默认宽度为<code>100%</code>，在垂直方向上按顺序放置，同时参与<code>块格式化上下文</code>。</p><p>每个块级元素至少生成一个块级盒或一个块容器盒，<code>块级盒</code>描述它与兄弟节点间的表现方式，<code>块容器盒</code>描述它与子节点间的表现方式。</p><p>一个块容器盒只包括其他块级盒或行内盒。可能一段代码中某个块容器盒同时包括块级盒与行内盒的情况，但实质上会产生一种新的匿名块盒解决该问题。</p><h2 id="行内元素" tabindex="-1">行内元素 <a class="header-anchor" href="#行内元素" aria-label="Permalink to &quot;行内元素&quot;">​</a></h2><p>当节点的<code>display</code>声明为<code>inline</code>、<code>inline-block</code>、<code>inline-table</code>、<code>inline-flex</code>或<code>inline-grid</code>时，该节点被标记为<strong>行内元素</strong>。行内元素默认宽度为<code>auto</code>，在水平方向上按顺序放置，同时参与<code>行内格式化上下文</code>。</p><p>当块级盒参与<code>行内格式化上下文</code>后会变成<code>行内盒</code>。另外还有一个称为匿名行内盒的概念，匿名行内盒与匿名块级盒的原理类似，都是浏览器自动生成的补充性盒。</p><p>以下简单使用一段代码理解匿名行内盒是如何产生的。</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;我是&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;大黄&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;，我的公众号是&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;WEB大前端&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>此时<code>我是</code>与<code>，我的公众号是</code>就会生成一个匿名行内盒，然后与两个<code>&lt;span&gt;</code>一起处于<code>&lt;p&gt;</code>参与<code>行内格式化上下文</code>后的行内盒中并保持水平排列。</p><blockquote><p>两者区别</p></blockquote><p>上述概念可能有些绕口，若从两者区别中理解可能更易消化。</p><ul><li>互相转换 <ul><li>块级元素转换行内元素：<code>display:inline</code></li><li>行内元素转换块级元素：<code>display:block</code></li></ul></li><li>占位表现 <ul><li>块级元素默认独占一行，默认宽度为父节点的<code>100%</code>，可声明边距、填充和宽高</li><li>行内元素默认不独占一行(<code>一行可多个</code>)，默认宽度随内容自动撑开，可声明水平边距或填充，不可声明垂直边距或宽高</li></ul></li><li>包括关系 <ul><li>块级元素可包括块级元素与行内元素</li><li>行内元素可包括行内元素，不能包括块级元素</li></ul></li></ul>',17),l=[c];function t(a,n,p,r,h,g){return i(),o("div",null,l)}const E=e(s,[["render",t]]);export{u as __pageData,E as default};
