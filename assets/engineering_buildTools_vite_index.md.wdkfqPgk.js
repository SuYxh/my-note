import{_ as e,c as o,o as c,V as d}from"./chunks/framework.hxTji2_l.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/buildTools/vite/index.md","filePath":"engineering/buildTools/vite/index.md","lastUpdated":1718171256000}'),i={name:"engineering/buildTools/vite/index.md"},l=d('<h2 id="前端工程都有哪些痛点呢" tabindex="-1">前端工程都有哪些痛点呢 <a class="header-anchor" href="#前端工程都有哪些痛点呢" aria-label="Permalink to &quot;前端工程都有哪些痛点呢&quot;">​</a></h2><p>如今的前端构建工具可谓<code>乱花渐欲迷人眼</code>，有远古时代的<code>browserify</code>、<code>grunt</code>，有传统的<code>Webpack</code>、<code>Rollup</code>、<code>Parcel</code>，也有现代的<code>Esbuild</code>、<code>Vite</code> 等等，不仅种类繁多，更新也很快。<strong>无论工具层面如何更新，它们解决的核心问题，即前端工程的痛点是不变的</strong>。因此，想要知道哪个工具更好用，就要看它解决前端工程痛点的效果。</p><p>首先是前端的<strong>模块化需求</strong>。业界的模块标准非常多，包括 ESM、CommonJS、AMD 和 CMD 等等。前端工程一方面需要落实这些模块规范，保证模块正常加载。另一方面需要兼容不同的模块规范，以适应不同的执行环境。</p><p>其次是<strong>兼容浏览器，编译高级语法</strong>。由于浏览器的实现规范所限，只要高级语言/语法（TypeScript、 JSX 等）想要在浏览器中正常运行，就必须被转化为浏览器可以理解的形式。这都需要工具链层面的支持，而且这个需求会一直存在。</p><p>再者是<strong>线上代码的质量</strong>问题。和开发阶段的考虑侧重点不同，生产环境中，我们不仅要考虑代码的<code>安全性</code>、<code>兼容性</code>问题，保证线上代码的正常运行，也需要考虑代码运行时的性能问题。由于浏览器的版本众多，代码兼容性和安全策略各不相同，线上代码的质量问题也将是前端工程中长期存在的一个痛点。</p><p>同时，<code>开发效率</code><strong>也不容忽视。</strong> 我们知道，<strong>项目的冷启动/二次启动时间</strong>、<strong>热更新时间</strong>都可能严重影响开发效率，尤其是当项目越来越庞大的时候。因此，提高项目的启动速度和热更新速度也是前端工程的重要需求。</p><p>那么，前端构建工具是如何解决以上问题的呢？</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f54b17dcae4c49adb558b760048c3603~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt=""></p><ul><li>模块化方面，提供模块加载方案，并兼容不同的模块规范。</li><li>语法转译方面，配合 <code>Sass</code>、<code>TSC</code>、<code>Babel</code> 等前端工具链，完成高级语法的转译功能，同时对于静态资源也能进行处理，使之能作为一个模块正常加载。</li><li>产物质量方面，在生产环境中，配合 <code>Terser</code>等压缩工具进行代码压缩和混淆，通过 <code>Tree Shaking</code> 删除未使用的代码，提供对于低版本浏览器的语法降级处理等等。</li><li>开发效率方面，构建工具本身通过各种方式来进行性能优化，包括<code>使用原生语言 Go/Rust</code>、<code>no-bundle</code>等等思路，提高项目的启动性能和热更新的速度。</li></ul><h2 id="为什么-vite-是当前最高效的构建工具" tabindex="-1">为什么 Vite 是当前最高效的构建工具 <a class="header-anchor" href="#为什么-vite-是当前最高效的构建工具" aria-label="Permalink to &quot;为什么 Vite 是当前最高效的构建工具&quot;">​</a></h2><p>我们可以根据上面说的四个维度来审视它。</p><p>首先是开发效率。传统构建工具普遍的缺点就是太慢了，与之相比，Vite 能将项目的启动性能提升一个量级，并且达到毫秒级的瞬间热更新效果。就拿 Webpack 来说，我在工作中发现，一般的项目使用 Webpack 之后，启动花个几分钟都是很常见的事情，热更新也经常需要等待十秒以上。这主要是因为：</p><ul><li>项目冷启动时必须递归打包整个项目的依赖树</li><li>JavaScript 语言本身的性能限制，导致构建性能遇到瓶颈，直接影响开发效率</li></ul><p>这样一来，代码改动后不能立马看到效果，自然开发体验也越来越差。而其中，最占用时间的就是<code>代码打包</code>和<code>文件编译</code>。而<code> Vite</code> 很好地解决了这些问题。一方面，<code>Vite</code> 在开发阶段基于浏览器原生 ESM 的支持实现了<code>no-bundle</code>服务，另一方面借助 <code>Esbuild</code> 超快的编译速度来做第三方库构建和 <code>TS/JSX</code> 语法编译，从而能够有效提高开发效率。</p><p>除了开发效率，在其他三个维度上， Vite 也表现不俗。</p><ul><li><p>模块化方面，Vite 基于浏览器原生 ESM 的支持实现模块加载，并且无论是开发环境还是生产环境，都可以将其他格式的产物(如 CommonJS)转换为 ESM。</p></li><li><p>语法转译方面，Vite 内置了对 TypeScript、JSX、Sass 等高级语法的支持，也能够加载各种各样的静态资源，如图片、Worker 等等。</p></li><li><p>产物质量方面，Vite 基于成熟的打包工具 <code>Rollup</code> 实现生产环境打包，同时可以配合<code>Terser</code>、<code>Babel</code>等工具链，可以极大程度保证构建产物的质量。</p></li></ul><p><code>Vite</code>不仅解决了传统构建工具的开发效率问题，而且具备一个优秀构建工具的各项要素，还经历了社区大规模的验证与落地。</p><h2 id="带着问题学习" tabindex="-1">带着问题学习 <a class="header-anchor" href="#带着问题学习" aria-label="Permalink to &quot;带着问题学习&quot;">​</a></h2><ul><li><p>第三方库里面含有 CommonJS 代码导致报错了怎么办?</p></li><li><p>想在开发过程中进行 Eslint 代码规范检查怎么办？</p></li><li><p>生产环境打包项目后，如何产出构建产物分析报告？</p></li><li><p>如果要兼容不支持原生 ESM 的浏览器，怎么办？</p></li><li><p>写一个 Esbuild 插件来处理一下问题依赖</p></li><li><p>对于 Rollup 打包产物进行自定义拆包，解决实际场景中经常出现的循环依赖问题</p></li><li><p>使用 Esbuild 的代码转译和压缩功能会出现哪些兼容性问题？如何解决？</p></li><li><p><code>@babel/preset-env</code> 的 <code>useBuiltIns</code> 属性各个取值有哪些区别？</p></li><li><p><code>@babel/polyfill</code> 与 <code>@babel/runtime-corejs</code> 有什么区别？</p></li><li><p><code>@babel/plugin-transform-runtime</code> 与<code>@babel/preset-env</code> 的 <code>useBuiltIn</code> 相比有什么优化？</p></li><li><p>core-js 的作用是什么？其产物有哪些版本？<code>core-js</code> 和 <code>core-js-pure</code> 有什么区别</p></li></ul>',19),t=[l];function p(r,a,n,s,u,b){return c(),o("div",null,t)}const m=e(i,[["render",p]]);export{g as __pageData,m as default};
