import{_ as s,c as a,o as i,V as n}from"./chunks/framework.hxTji2_l.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"subject/mobile/H5唤起APP.md","filePath":"subject/mobile/H5唤起APP.md","lastUpdated":1720969341000}'),e={name:"subject/mobile/H5唤起APP.md"},l=n(`<p>前一段时间在做一些H5页面，需求中落地页占比较大，落地页承担的职责就是引流。引流有两种形式，同时也是我们对唤端的定义：引导已下载用户打开APP，引导未下载用户下载APP。</p><p>引导已下载用户打开APP，从数据上说用户停留在APP中的时间更多了，是在提高用户粘性；从体验上说，APP体验是要比H5好的。引导未下载用户下载APP，可以增加我们的用户量。</p><p>上面其实分别解释了 <strong>什么是唤端</strong> 以及 <strong>为什么要唤端</strong>，那么接下来我们就要聊一聊 <strong>如何唤端</strong> 。</p><h2 id="唤端媒介" tabindex="-1">唤端媒介 <a class="header-anchor" href="#唤端媒介" aria-label="Permalink to &quot;唤端媒介&quot;">​</a></h2><h3 id="url-scheme" tabindex="-1">URL Scheme <a class="header-anchor" href="#url-scheme" aria-label="Permalink to &quot;URL Scheme&quot;">​</a></h3><h4 id="来源" tabindex="-1">来源 <a class="header-anchor" href="#来源" aria-label="Permalink to &quot;来源&quot;">​</a></h4><p>我们的手机上有许多私密信息，联系方式、照片、银行卡信息...我们不希望这些信息可以被手机应用随意获取到，信息泄露的危害甚大。所以，如何保证个人信息在设备所有者知情并允许的情况下被使用，是智能设备的核心安全问题。</p><p>对此，苹果使用了名为 <em>沙盒</em> 的机制：应用只能访问它声明可能访问的资源。但沙盒也阻碍了应用间合理的信息共享，某种程度上限制了应用的能力。</p><p>因此，我们急需要一个辅助工具来帮助我们实现应用通信， URL Scheme 就是这个工具。</p><h4 id="url-scheme-是什么" tabindex="-1">URL Scheme 是什么 <a class="header-anchor" href="#url-scheme-是什么" aria-label="Permalink to &quot;URL Scheme 是什么&quot;">​</a></h4><p>我们来看一下 URL 的组成：</p><div class="language-css vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[scheme:][//</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">authority</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][?</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">query</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][#</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fragment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>我们拿 <code>https://www.baidu.com</code> 来举例，scheme 自然就是 <code>https</code> 了。</p><p>就像给服务器资源分配一个 URL，以便我们去访问它一样，我们同样也可以给手机APP分配一个特殊格式的 URL，用来访问这个APP或者这个APP中的某个功能(来实现通信)。APP得有一个标识，好让我们可以定位到它，它就是 URL 的 Scheme 部分。</p><h4 id="常用app的-url-scheme" tabindex="-1">常用APP的 URL Scheme <a class="header-anchor" href="#常用app的-url-scheme" aria-label="Permalink to &quot;常用APP的 URL Scheme&quot;">​</a></h4><table><thead><tr><th>APP</th><th>微信</th><th>支付宝</th><th>淘宝</th><th>微博</th><th>QQ</th><th>知乎</th><th>短信</th></tr></thead><tbody><tr><td>URL Scheme</td><td>weixin://</td><td>alipay://</td><td>taobao://</td><td>sinaweibo://</td><td>mqq://</td><td>zhihu://</td><td>sms://</td></tr></tbody></table><h4 id="url-scheme-语法" tabindex="-1">URL Scheme 语法 <a class="header-anchor" href="#url-scheme-语法" aria-label="Permalink to &quot;URL Scheme 语法&quot;">​</a></h4><p>上面表格中都是最简单的用于打开 APP 的 URL Scheme，下面才是我们常用的 URL Scheme 格式：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>     行为(应用的某个功能)    </span></span>
<span class="line"><span>            |</span></span>
<span class="line"><span>scheme://[path][?query]</span></span>
<span class="line"><span>   |               |</span></span>
<span class="line"><span>应用标识       功能需要的参数</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="intent" tabindex="-1">Intent <a class="header-anchor" href="#intent" aria-label="Permalink to &quot;Intent&quot;">​</a></h3><p>安卓的原生谷歌浏览器自从 chrome25 版本开始对于唤端功能做了一些变化，URL Scheme 无法再启动Android应用。 例如，通过 iframe 指向 <code>weixin://</code>，即使用户安装了微信也无法打开。所以，APP需要实现谷歌官方提供的 <code>intent:</code> 语法，或者实现让用户通过自定义手势来打开APP，当然这就是题外话了。</p><h4 id="intent-语法" tabindex="-1">Intent 语法 <a class="header-anchor" href="#intent-语法" aria-label="Permalink to &quot;Intent 语法&quot;">​</a></h4><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>intent:</span></span>
<span class="line"><span>   HOST/URI-path // Optional host </span></span>
<span class="line"><span>   #Intent; </span></span>
<span class="line"><span>      package=[string]; </span></span>
<span class="line"><span>      action=[string]; </span></span>
<span class="line"><span>      category=[string]; </span></span>
<span class="line"><span>      component=[string]; </span></span>
<span class="line"><span>      scheme=[string]; </span></span>
<span class="line"><span>   end;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如果用户未安装 APP，则会跳转到系统默认商店。当然，如果你想要指定一个唤起失败的跳转地址，添加下面的字符串在 <code>end;</code> 前就可以了:</p><div class="language-ini vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> S.browser_fallback_url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=[encoded_full_url]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h4><p>下面是打开 Zxing 二维码扫描 APP 的 intent。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>intent:</span></span>
<span class="line"><span>   //scan/</span></span>
<span class="line"><span>   #Intent; </span></span>
<span class="line"><span>      package=com.google.zxing.client.android; </span></span>
<span class="line"><span>      scheme=zxing; </span></span>
<span class="line"><span>   end;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>打开这个 APP ，可以通过如下的方式：</p><div class="language-css vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> href=&quot;intent://scan/</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">#Intent;scheme</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=zxing;package=com</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.google.zxing.client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.android;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.browser_fallback_url=http%3A%2F%2Fzxing.org;end&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Take </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> QR </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="universal-link" tabindex="-1">Universal Link <a class="header-anchor" href="#universal-link" aria-label="Permalink to &quot;Universal Link&quot;">​</a></h3><h4 id="universal-link-是什么" tabindex="-1">Universal Link 是什么 <a class="header-anchor" href="#universal-link-是什么" aria-label="Permalink to &quot;Universal Link 是什么&quot;">​</a></h4><p>Universal Link 是苹果在 WWDC2015 上为 iOS9 引入的新功能，通过传统的 HTTP 链接即可打开 APP。如果用户未安装 APP，则会跳转到该链接所对应的页面。</p><h4 id="为什么要使用-universal-link" tabindex="-1">为什么要使用 Universal Link <a class="header-anchor" href="#为什么要使用-universal-link" aria-label="Permalink to &quot;为什么要使用 Universal Link&quot;">​</a></h4><p>传统的 Scheme 链接有以下几个痛点：</p><ul><li>在 ios 上会有确认弹窗提示用户是否打开，对于用户来说唤端，多出了一步操作。若用户未安装 APP ，也会有一个提示窗，告知我们 “打不开该网页，因为网址无效”</li><li>传统 Scheme 跳转无法得知唤端是否成功，Universal Link 唤端失败可以直接打开此链接对应的页面</li><li>Scheme 在微信、微博、QQ浏览器、手百中都已经被禁止使用，使用 Universal Link 可以避开它们的屏蔽（ 截止到 18年8月21日，微信和QQ浏览器已经禁止了 Universal Link，其他主流APP未发现有禁止 ）</li></ul><h4 id="如何让-app-支持-universal-link" tabindex="-1">如何让 APP 支持 Universal Link <a class="header-anchor" href="#如何让-app-支持-universal-link" aria-label="Permalink to &quot;如何让 APP 支持 Universal Link&quot;">​</a></h4><p>有大量的文章会详细的告诉我们如何配置，你也可以去看<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW2" target="_blank" rel="noreferrer">官方文档</a>，我这里简单的写一个12345。</p><ol><li>拥有一个支持 <strong>https</strong> 的域名</li><li>在 <a href="https://developer.apple.com/" target="_blank" rel="noreferrer">开发者中心</a> ，Identifiers 下 AppIDs 找到自己的 App ID，编辑打开 Associated Domains 服务。</li><li>打开工程配置中的 Associated Domains ，在其中的 Domains 中填入你想支持的域名，必须以 <code>applinks:</code> 为前缀</li><li>配置 <code>apple-app-site-association</code> 文件，文件名必须为 <code>apple-app-site-association</code> ，<strong>不带任何后缀</strong></li><li>上传该文件到你的 HTTPS 服务器的 <strong>根目录</strong> 或者 <code>.well-known</code> 目录下</li></ol><h4 id="universal-link-配置中的坑" tabindex="-1">Universal Link 配置中的坑 <a class="header-anchor" href="#universal-link-配置中的坑" aria-label="Permalink to &quot;Universal Link 配置中的坑&quot;">​</a></h4><p>这里放一下我们在配置过程中遇到的坑，当然首先你在配置过程中必须得严格按照上面的要求去做，尤其是加粗的地方。</p><ol><li><p>跨域问题</p><p>IOS 9.2 以后，必须要触发跨域才能支持 Universal Link 唤端。</p><p>IOS 那边有这样一个判断，如果你要打开的 Universal Link 和 当前页面是同一域名，ios 尊重用户最可能的意图，直接打开链接所对应的页面。如果不在同一域名下，则在你的 APP 中打开链接，也就是执行具体的唤端操作。</p></li><li><p>Universal Link 是空页面</p><p>Universal Link 本质上是个空页面，如果未安装 APP，Universal Link 被当做普通的页面链接，自然会跳到 404 页面，所以我们需要将它绑定到我们的中转页或者下载页。</p></li></ol><h2 id="如何调用三种唤端媒介" tabindex="-1">如何调用三种唤端媒介 <a class="header-anchor" href="#如何调用三种唤端媒介" aria-label="Permalink to &quot;如何调用三种唤端媒介&quot;">​</a></h2><p>通过前面的介绍，我们可以发现，无论是 URL Scheme 还是 Intent 或者 Universal Link ，他们都算是 URL ，只是 URL Scheme 和 Intent 算是特殊的 URL。所以我们可以拿使用 URL 的方法来使用它们。</p><h3 id="iframe" tabindex="-1">iframe <a class="header-anchor" href="#iframe" aria-label="Permalink to &quot;iframe&quot;">​</a></h3><div class="language-ini vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;iframe </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sinaweibo://qrcode&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在只有 URL Scheme 的日子里，iframe 是使用最多的了。因为在未安装 app 的情况下，不会去跳转错误页面。但是 iframe 在各个系统以及各个应用中的兼容问题还是挺多的，不能全部使用 URL Scheme。</p><h3 id="a-标签" tabindex="-1">a 标签 <a class="header-anchor" href="#a-标签" aria-label="Permalink to &quot;a 标签&quot;">​</a></h3><div class="language-css vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> href=&quot;intent://scan/</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">#Intent;scheme</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=zxing;package=com</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.google.zxing.client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.android;end&quot;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">扫一扫&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>前面我们提到 Intent 协议，官方给出的用例使用的就是使用的 a 标签，所以我们跟着一起用就可以了~。</p><p>使用过程中，对于动态生成的 a 标签，使用 <code>dispatch</code> 来模拟触发点击事件，发现很多种 event 传递过去都无效；使用 <code>click()</code> 来模拟触发，部分场景下存在这样的情况，第一次点击过后，回到原先页面，再次点击，点击位置和页面所识别位置有不小的偏移，所以 Intent 协议从 a 标签换成了 window.location。</p><h3 id="window-location" tabindex="-1">window.location <a class="header-anchor" href="#window-location" aria-label="Permalink to &quot;window.location&quot;">​</a></h3><p>URL Scheme 在 ios 9+ 上诸如 safari、UC、QQ浏览器中， iframe 均无法成功唤起 APP，只能通过 window.location 才能成功唤端。</p><p>当然，如果我们的 app 支持 Universal Link，ios 9+ 就用不到 URL Scheme 了。而 Universal Link 在使用过程中，我发现在 qq 中，无论是 iframe 导航 还是 a 标签打开 又或者 window.location 都无法成功唤端，一开始我以为是 qq 和微信一样禁止了 Universal Link 唤端的功能，其实不然，百般试验下，通过 top.location 唤端成功了。</p><h2 id="判断唤端是否成功" tabindex="-1">判断唤端是否成功 <a class="header-anchor" href="#判断唤端是否成功" aria-label="Permalink to &quot;判断唤端是否成功&quot;">​</a></h2><p>如果唤端失败（APP 未安装），我们总是要做一些处理的，可以是跳转下载页，可以是 ios 下跳转 App Store... 但是Js 并不能提供给我们获取 APP 唤起状态的能力，Android Intent 以及 Universal Link 倒是不用担心，它们俩的自身机制允许它们唤端失败后直接导航至相应的页面，但是 URL Scheme 并不具备这样的能力，所以我们只能通过一些很 hack 的方式来实现 APP 唤起检测功能。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 一般情况下是 visibilitychange </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> visibilityChangeProperty</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getVisibilityChangeProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> timer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> hidden</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isPageHidden</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hidden) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    cb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, timeout);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (visibilityChangeProperty) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(visibilityChangeProperty, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    clearTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;pagehide&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  clearTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>APP 如果被唤起的话，页面就会进入后台运行，会触发页面的 visibilitychange 事件。如果触发了，则表明页面被成功唤起，及时调用 clearTimeout ，清除页面未隐藏时的失败函数（callback）回调。</p><p>当然这个事件是有兼容性的，具体的代码实现时做了事件是否需要添加前缀（比如 -webkit- ）的校验。如果都不兼容，我们将使用 pagehide 事件来做兜底处理。</p><h2 id="没有完美的方案" tabindex="-1">没有完美的方案 <a class="header-anchor" href="#没有完美的方案" aria-label="Permalink to &quot;没有完美的方案&quot;">​</a></h2><p>透过上面的几个点，我们可以发现，无论是 <em>唤端媒介</em> 、 <em>调用唤端媒介</em> 还是 <em>判断唤端结果</em> 都没有一个十全十美的方法，我们在代码层上能做的只是在确保最常用的场景（比如 微信、微博、手百 等）唤端无误的情况下，最大化的兼容剩余的场景。</p><p>好的，我们接下来扯一些代码以外的，让我们的 APP 能够在更多的平台唤起。</p><ul><li><p>微信、微博、手百、QQ浏览器等。</p><p>这些应用能阻止唤端是因为它们直接屏蔽掉了 URL Scheme 。接下来可能就有看官疑惑了，微信中是可以打开大众点评的呀，微博里面可以打开优酷呀，那是如何实现的呢？</p><p>它们都各自维护着一个白名单，如果你的域名在白名单内，那这个域名下所有的页面发起的 URL Scheme 就都会被允许。就像微信，如果你是腾讯的“家属”，你就可以加入白名单了，微信的白名单一般只包含着“家属”，除此外很难申请到白名单资质。但是微博之类的都是可以联系他们的渠道童鞋进行申请的，只是条件各不相同，比如微博的就是在你的 APP 中添加打开微博的入口，三个月内唤起超过 100w 次，就可以加入白名单了。</p></li><li><p>腾讯应用宝直接打开 APP 的某个功能</p><p>刚刚我们说到，如果你不是微信的家属，那你是很难进入白名单的，所以在安卓中我们一般都是直接打开腾讯应用宝，ios 中 直接打开 App Store。点击腾讯应用宝中的“打开”按钮，可以直接唤起我们的 APP，但是无法打开 APP 中的某个功能（就是无法打开指定页面）。</p><p>腾讯应用宝对外开放了一个叫做 APP Link 的申请，只要你申请了 APP Link，就可以通过在打开应用宝的时候在应用宝地址后面添加上 <code>&amp;android_schema={your_scheme}</code> ，来打开指定的页面了。</p></li></ul><h2 id="开箱即用的callapp-lib" tabindex="-1">开箱即用的callapp-lib <a class="header-anchor" href="#开箱即用的callapp-lib" aria-label="Permalink to &quot;开箱即用的callapp-lib&quot;">​</a></h2><p>信息量很大！各种问题得自己趟坑验证！内心很崩溃！</p><p>不用愁，已经为你准备好了药方，只需照方抓药即可😏 —— npm 包 <a href="https://www.npmjs.com/package/callapp-lib" target="_blank" rel="noreferrer">callapp-lib</a></p><p>你也可以通过 <code>script</code> 直接加载 cdn 文件：</p><div class="language-xml vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://unpkg.com/callapp-lib&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>它能在大部分的环境中成功唤端，而且炒鸡简单啊，拿过去就可以用啊，还支持很多扩展功能啊，快来瞅瞅它的 <a href="https://github.com/suanmei/callapp-lib" target="_blank" rel="noreferrer">文档</a> 啊~~~</p><blockquote><p>原文 <a href="https://juejin.cn/post/7348249728939130907" target="_blank" rel="noreferrer">https://juejin.cn/post/7348249728939130907</a></p></blockquote><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><ol><li><p><a href="http://web.jobbole.com/86706/" target="_blank" rel="noreferrer">浏览器中唤起 native app，否则跳转到应用商城下载</a></p></li><li><p><a href="http://echozq.github.io/echo-blog/2015/11/13/callapp.html" target="_blank" rel="noreferrer">h5唤起app</a></p></li><li><p><a href="https://sspai.com/post/31500" target="_blank" rel="noreferrer">URL Schemes 使用详解</a></p></li><li><p><a href="https://developer.chrome.com/multidevice/android/intents" target="_blank" rel="noreferrer">Android Intents with Chrome</a></p></li><li><p><a href="https://blog.csdn.net/xttxqjfg/article/details/76019824" target="_blank" rel="noreferrer">常用URL Scheme</a></p></li><li><p><a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.cocoachina.com%2Fios%2F20170904%2F20463.html" title="https://link.juejin.cn?target=http%3A%2F%2Fwww.cocoachina.com%2Fios%2F20170904%2F20463.html" target="_blank" rel="noreferrer">Universal Link 前端部署采坑记</a></p></li><li><p><a href="http://www.cocoachina.com/ios/20170904/20463.html" target="_blank" rel="noreferrer">Support Universal Links</a></p></li><li><p><a href="https://yq.aliyun.com/articles/608583" target="_blank" rel="noreferrer">Universal Link是个骗子</a></p></li></ol>`,72),t=[l];function p(r,h,c,k,d,o){return i(),a("div",null,t)}const u=s(e,[["render",p]]);export{g as __pageData,u as default};
