<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.js"></script>
</head>

<body>
  <script>

    const delay = (time) => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          console.log('intervel', time);
          resolve(time)
        }, time);
      })
    }

    const tasks = [
      () => delay(1000),
      () => delay(1002),
      () => delay(1009),
      () => delay(1006),
      () => delay(1008),
      () => delay(1005),
    ]

    const tasks2 = [
      () => {
        return delay(1000);
      },
      () => {
        return delay(1003);
      },
      () => {
        return delay(1005);
      },
      () => {
        return delay(1002);
      },
      () => {
        return delay(1004);
      },
      () => {
        return delay(1006);
      },
    ];

    class TaskQueue2 {
      pool = 2;
      running = 0;
      queue = [];
      result = [];

      constructor(pool, cb) {
        this.pool = pool || 2;
        this.cb = cb;
        this.promisify = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
      }

      pushTask(task) {
        this.queue.push(task);
        this.next();
      }

      next() {
        while (this.queue.length && this.running < this.pool) {
          this.running++;
          const task = this.queue.shift();

          task()
            .then((res) => {
              this.result.push(res);
            })
            .catch((err) => {
              console.log(err);
              if (this.reject) {
                this.reject(err);
              }
            })
            .finally(() => {
              this.running--;

              this.next();
            });
        }

        if (this.running === 0) {
          if (typeof this.cb === "function") {
            this.cb(this.result);
          }
          if (this.resolve) {
            this.resolve(this.result);
          }
        }
      }

      promise() {
        return this.promisify;
      }
    }


    class TaskQueue {
      running = 0
      queue = []
      result = []

      constructor(pool, cb) {
        this.pool = pool ?? 2
        this.cb = cb
        this.promisify = new Promise((resolve, reject) => {
          this.resolve = resolve
          this.reject = reject
        })
      }


      pushTask(task) {
        this.queue.push(task)

        this.next()
      }


      next() {


        while (this.queue.length && this.running < this.pool) {

          const task = this.queue.shift()
          this.running++

          task().then((res) => {
            this.result.push(res)
          }).catch((err) => {
            this.reject(err)
          }).finally(() => {
            this.running--

            this.next()
          })

        }

        if (this.running === 0) {
          if (typeof this.cb === "function") {
            this.cb(this.result)
          }

          this.resolve(this.result)
        }

      }
    
      promise() {
        return this.promisify
      }
    }

    function limit(tasks, pool, cb) {
      const taskQueue = new TaskQueue(pool, cb)

      tasks.forEach(task => {
        taskQueue.pushTask(task)
      });

      return taskQueue.promise()
    }


    // limit(tasks, 2, (res) => {
    //   console.log('-->', res);
    // })

    limit(tasks, 2).then(res => {
      console.log('res', res);
    })


  </script>
</body>

</html>