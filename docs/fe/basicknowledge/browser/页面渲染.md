### DOM树

![下载](https://qn.huat.xyz/mac/202406121259105.png)





### CSSOM树

![下载 (1)](https://qn.huat.xyz/mac/202406121300750.png)





### Render-Tree渲染树

![下载 (2)](https://qn.huat.xyz/mac/202406121300031.png)





### 总结

- 处理 HTML 标记，构建 DOM 树
- 处理 CSS 标记，构建 CSSOM 树
- 将 DOM 树和 CSSOM 树融合成渲染树
- 根据生成的渲染树，计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流 => 布局（Layout）或 重排（reflow）
- 根据渲染树以及回流得到的几何信息，得到节点的绝对像素 => 绘制（painting）

![下载 (3)](https://qn.huat.xyz/mac/202406121301016.png)





### 优化方案

- 标签语义化和避免深层次嵌套

- CSS选择器渲染是从右到左

- 尽早尽快地把CSS下载到客户端（充分利用HTTP多请求并发机制）

  - `style`
  - `link`
  - `@import`
  - 放到顶部

- 避免阻塞的JS加载

  - `async`

  - `defer`

  - 放到底部

    ![下载 (4)](https://qn.huat.xyz/mac/202406121301724.png)

- 减少DOM的回流和重绘





### 重绘回流

![image-20240612130252687](https://qn.huat.xyz/mac/202406121302709.png)





#### 回流

**回流**又称**重排**，指改变`几何属性`的渲染。感觉“回流”较高大上，后续统称回流吧。

可理解为将整个网页填白，对内容重新渲染一次。只不过以人眼的感官速度看浏览器回流是不会有任何变化的，若你拥有闪电侠的感官速度看浏览器回流(`实质是将时间调慢`)，就会发现每次回流都会将网页清空，从左上角第一个像素点从左到右从上到下这样一点一点渲染，直至右下角最后一个像素点。每次回流都会呈现该过程，只是感受不到而已。

渲染树的节点发生改变，影响了节点的几何属性，导致节点位置发生变化，此时就会触发浏览器回流并重新生成渲染树。回流意味着节点的几何属性改变，需重新计算并生成渲染树，导致渲染树的全部或部分发生变化。

#### 重绘

**重绘**指改变`外观属性`而不影响`几何属性`的渲染。相比回流，重绘在两者中会温和一些，后续谈到的`CSS性能优化`就会基于该特性展开。

渲染树的节点发生改变，但不影响节点的几何属性。由此可见，回流对浏览器性能的消耗高于重绘且回流一定伴随重绘，重绘却不一定伴随回流。

为何回流一定伴随重绘？整个节点的位置都变了，肯定要重新渲染它的外观属性啊！



#### 属性

 **几何属性**：包括布局、尺寸等可用数学几何衡量的属性

- 布局：`display`、`float`、`position`、`list`、`table`、`flex`、`columns`、`grid`等
- 尺寸：`margin`、`padding`、`border`、`width`、`height`等

 **外观属性**：包括界面、文字等可用状态向量描述的属性

- 界面：`appearance`、`outline`、`background`、`mask`、`box-shadow`、`box-reflect`、`filter`、`opacity`、`clip`等
- 文字：`text`、`font`、`word`等



### 避免回流

![image-20240612130332397](https://qn.huat.xyz/mac/202406121303420.png)





![image-20240612130358372](https://qn.huat.xyz/mac/202406121303398.png)





![image-20240612130414656](https://qn.huat.xyz/mac/202406121304677.png)



![image-20240612130433765](https://qn.huat.xyz/mac/202406121304794.png)







### 性能优化

回流重绘在操作节点样式时频繁出现，同时也存在很大程度上的性能问题。回流成本比重绘成本高得多，一个节点的回流很有可能导致子节点、兄弟节点或祖先节点的回流。在一些高性能电脑中可能无影响，但回流发生在手机中(`明摆说某些安卓手机`)，就会减缓加载速度，增加电量消耗。

在上章引出一个定向法则：**回流必定引发重绘，重绘不一定引发回流**，可利用该法则解决一些因为回流重绘而引发的性能问题。在优化性能前，需了解什么情况可能产生性能问题，以下罗列一些常见情况。

-   改变窗口大小
-   修改盒模型
-   增删样式
-   重构布局
-   重设尺寸
-   改变字体
-   改动文字

很多同学可能不知，回流重绘其实与浏览器的`事件循环`有关，以下源自对[HTML文档](https://link.juejin.cn/?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fwebappapis.html%23event-loop-processing-model "https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model")的理解。

-   浏览器刷新频率为`60Hz`，即每`16.6ms`更新一次
-   执行事件循环完成微任务
-   判断`document`是否需更新
-   判断`resize/scroll`事件是否存在，存在则触发事件
-   判断`Media Query`是否触发
-   更新动作并发送事件
-   判断`document.isFullScreen`是否为`true`(全屏)
-   执行`requestAnimationFrame`回调
-   执行`IntersectionObserver`回调
-   更新界面

上述过程就是浏览器每帧可能会做到的事情，若在一帧中有空闲时间，就会执行`requestIdleCallback`回调。

回到正题，通过定向法则**回流必定引发重绘，重绘不一定引发回流**可知，尽量减少回流重绘，就是`CSS性能优化`中一个很好的指标。

> 如何减少和避免回流重绘

##### 使用visibility:hidden替换display:none

从以下方面对比`display:none`与`visibility:hidden`，`display:none`简称`DN`，`visibility:hidden`简称`VH`。

-   **占位表现**
    -   DN不占据空间
    -   VH占据空间
-   **触发影响**
    -   DN触发回流重绘
    -   VH触发重绘
-   **过渡影响**
    -   DN影响过渡不影响动画
    -   VH不影响过渡不影响动画
-   **株连效果**
    -   DN后自身及其子节点全都不可见
    -   VH后自身及其子节点全都不可见但可声明子节点`visibility:visible`单独显示

两者的占位表现、触发影响和株连效果就能说明`VH`代替`DN`的好处，从两者区别中就能找出恰当的答案了。

##### 使用transform代替top

`top`是几何属性，操作`top`会改变节点位置引发回流，使用`transform:translate3d(x,0,0)`代替`top`，只会引发图层重绘，还会间接启动GPU加速。

##### 避免使用Table布局

牵一发而动全身用在`Table布局`身上就很适合了，可能很小的一个改动就会造成整个`<table>`回流，有兴趣的同学可用`Chrome Devtools`的`Performance`调试看看，在此就不演示了。

通常可用`<ul>`、`<li>`和`<span>`等标签取代`table系列标签`生成表格。

##### 避免规则层级过多

浏览器的`CSS解析器`解析`css文件`时，对`CSS规则`是从右到左匹配查找，样式层级过多会影响回流重绘效率，建议保持`CSS规则`在`3层`左右。

##### 避免节点属性值放在循环中当成循环变量

```js
for (let i = 0; i < 10000; i++) { const top = document.getElementById("css").style.top; console.log(top); }
```

呵呵，每次循环操作`DOM`都会发生回流，应在循环外部使用变量保存一些不会变化的`DOM映射值`。

```js
const top = document.getElementById("css").style.top; for (let i = 0; i < 10000; i++) { console.log(top); }
```

##### 动态改变类而不改变样式

不要尝试每次操作`DOM`改变节点样式，这样会频繁触发回流。

更好的方式是使用新的类名预设节点样式，在执行逻辑操作时收集并确认最终更换的类名集合，在适合时机一次性动态替换原来的类名集合。有点像`vue`的`依赖收集机制`，不知这样描述会不会更易理解。

大家可研究强大的[classList](https://link.juejin.cn/?target=https%3A%2F%2Fwww.runoob.com%2Fjsref%2Fprop-element-classlist.html "https://www.runoob.com/jsref/prop-element-classlist.html")，它能满足我所说的需求。

##### 将频繁回流重绘的节点设置为图层

渲染过程最后一步，提到将回流重绘生成的图层逐张合并并显示在屏幕中。可将其理解成`Photoshop`的图层，若不对图层添加关联，图层间是不会互相影响的。同理，在浏览器中设置频繁回流或重绘的节点为一张新图层，那新图层就能够阻止节点的渲染行为影响别的节点，这张图层中如何变化都无法影响到其他图层。

设置新图层有两种方式，将节点设置为`<video>`或`<iframe>`，为节点声明`will-change`。`will-change`是一个很叼的属性，第12章会详细讲述。

##### 使用requestAnimationFrame作为动画帧

动画速度越快，回流次数越多，上述提到浏览器刷新频率为`60Hz`，即每`16.6ms`更新一次，而`requestAnimationFrame()`正是以`16.6ms`的速度更新一次，所以可用`requestAnimationFrame()`代替`setInterval()`。



