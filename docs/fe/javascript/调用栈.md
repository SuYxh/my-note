## 什么是函数调用

函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号。

```js
var a = 2
function add(){
var b = 10
return  a+b
}
add()
```

在执行到函数 add() 之前，JavaScript 引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量，如下：

![下载 (5)](https://qn.huat.xyz/mac/202405231003716.png)

从图中可以看出，代码中全局变量和函数都保存在全局上下文的变量环境中。

执行上下文准备好之后，便开始执行全局代码，当执行到 add 这儿时，JavaScript 判断这是一个函数调用，那么将执行以下操作：

- 首先，从**全局执行上下文**中，取出 add 函数代码。
- 其次，对 add 函数的这段代码进行编译，并创建**该函数的执行上下文**和**可执行代码**。
- 最后，执行代码，输出结果。

完整流程你可以参考下图：

![下载](https://qn.huat.xyz/mac/202405231007574.png)

就这样，当执行到 add 函数的时候，我们就有了两个执行上下文了——全局执行上下文和 add 函数的执行上下文。

也就是说在执行 JavaScript 时，可能会存在多个执行上下文，那么 JavaScript 引擎是如何管理这些执行上下文的呢？

答案是**通过一种叫栈的数据结构来管理的**。



## JavaScript 的调用栈

JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为**执行上下文栈**，又称**调用栈**。

```js
var a = 2
function add(b,c){
  return b+c
}
function addAll(b,c){
var d = 10
result = add(b,c)
return  a+result+d
}
addAll(3,6)
```

### **第一步，创建全局上下文，并将其压入栈底**

![下载 (1)](https://qn.huat.xyz/mac/202405231009692.png)

从图中你也可以看出，变量 a、函数 add 和 addAll 都保存到了全局上下文的变量环境对象中。

全局执行上下文压入到调用栈后，JavaScript 引擎便开始执行全局代码了。首先会执行 a=2 的赋值操作，执行该语句会将全局上下文变量环境中 a 的值设置为 2。设置后的全局上下文的状态如下图所示：

![下载 (2)](https://qn.huat.xyz/mac/202405231013294.png)

### **第二步是调用 addAll 函数**

当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：

![下载 (3)](https://qn.huat.xyz/mac/202405231015140.png)

addAll 函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是 d=10 的赋值操作，执行语句会将 addAll 函数执行上下文中的 d 由 undefined 变成了 10。

### 第三步

**第三步，当执行到 add 函数**调用语句时，同样会为其创建执行上下文，并将其压入调用栈，如下图所示：

![下载 (4)](https://qn.huat.xyz/mac/202405231017508.png)

当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add 函数的返回值，也就是 9。如下图所示：

![下载 (5)](https://qn.huat.xyz/mac/202405231018284.png)

紧接着 addAll 执行最后一个相加操作后并返回，addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：

![下载 (6)](https://qn.huat.xyz/mac/202405231018406.png)

至此，整个 JavaScript 流程执行结束了。

## 总结

- 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。
- 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。
- 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。
- 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。

## 思考

```js
function runStack (n) {
  if (n === 0) return 100;
  return runStack( n- 2);
}
runStack(50000)
```

这是一段递归代码，可以通过传入参数 n，让代码递归执行 n 次，也就意味着调用栈的深度能达到 n，当输入一个较大的数时，比如 50000，就会出现栈溢出的问题，那么你能优化下这段代码，以解决栈溢出的问题吗？





在JavaScript中，递归调用如果过深会导致调用栈溢出，因为JavaScript引擎通常有一个调用栈的大小限制。你提供的代码中，当`n`较大时，确实容易发生这种情况。为了解决这个问题，我们可以将递归改写为循环形式，这样就不会占用额外的调用栈空间。下面是优化后的代码：

```js
function runStack(n) {
  while (n > 0) {
    n -= 2;
  }
  return 100;
}

runStack(50000);
```

这里，我们用`while`循环代替了递归调用。循环会持续进行直到`n`减到0或以下。这种方式避免了递归的栈溢出问题，因为它不会不断地在调用栈上添加新的层级。

