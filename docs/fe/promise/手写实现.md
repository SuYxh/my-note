## 手写实现 Promise

参考 https://github.com/cumt-robin/promises-aplus-robin/

::: details Promise A+
<<< @/fe/promise/code/promise.js#promise
:::

## Promise.prototype.catch

::: details catch
<<< @/fe/promise/code/promiseFn.js#myCatch
:::

## Promise.prototype.myFinally

::: details myFinally
<<< @/fe/promise/code/promiseFn.js#myFinally
:::

这个是有可能考的，比如微信小程序就不支持 finally。可以基于 then 来实现，不管 fulfilled 还是 rejected 都要执行 onFinally。

但是要注意，不管当前 Promise 的状态是 fulfilled 还是 rejected，只要在 onFinally 中没有发生以下任何一条情况， finally 方法返回的新的 Promise 实例的状态就会与当前 Promise 的状态保持一致！这也意味着即使在 onFinally 中返回一个状态为 fulfilled 的 Promise 也不能阻止新的 Promise 实例采纳当前 Promise 的状态或值！

- 返回一个状态为或将为 reiected 的 Promise
- 抛出错误

总的来说，在 finally 情况下，rejected 优先！

## Promise.prototype.myAll

::: details myAll
<<< @/fe/promise/code/promiseFn.js#myAll
:::

这个主要是考察如何收集每一个 Promise 的状态变化，在最后一个 Promise 状态变化时，对外发出信号。

● 判断 iterable 是否空

● 判断 iterable 是否全部不是 Promise

● 遍历，如果某项是 Promise，利用 .then 获取结果，如果 fulfilled，将 value 存在 values 中，并用 fulfillCount 计数；如果是 rejected，直接 reject
reason。

● 如果某项不是 Promise，直接将值存起来，并计数。

● 等所有异步都 fulfilled，fulfillCount 必将是 iterable 的⻓度（在 onFulfilled 中判断 fulfillCount），此时可以 resolve values。
