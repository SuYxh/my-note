vue2 响应式

![image-20240104123820325](https://qn.huat.xyz/mac/202401041238362.png)



![image-20240104132155626](https://qn.huat.xyz/mac/202401041321654.png)





![image-20240104133158887](https://qn.huat.xyz/mac/202401041331942.png)



![image-20240104133431879](https://qn.huat.xyz/mac/202401041334903.png)







在 Vue 2 中，`Observer`、`Dep`、`Watcher` 和 `data` 是 Vue 响应式系统的核心部分。它们之间的关系和联系是相当紧密且协同工作的。以下是它们的定义和它们之间的关系：

1. **data**:
   - 在Vue组件中，`data` 是一个包含各种属性的对象，这些属性是组件的状态。当这些属性的值改变时，视图会自动更新。

2. **Observer**:
   - `Observer` 是一个类，它的职责是将 `data` 中的属性转换成可观察的对象。它会遍历 `data` 对象的所有属性，并使用 `Object.defineProperty` 把这些属性转换为 getter/setter。这样，Vue 就能够追踪属性值的变化。

3. **Dep (Dependency)**:
   - `Dep` 是一个用于管理依赖的类，它维护了一个数组，用来收集当前属性的依赖关系（即 `Watcher` 的实例）。每个被 `Observer` 观察的属性都有一个对应的 `Dep` 实例。
   - 当属性被读取（getter）时，`Dep` 会收集依赖（即添加 `Watcher`），而当属性被修改（setter）时，`Dep` 通知它的所有 `Watcher` 更新。

4. **Watcher**:
   - `Watcher` 是一个类，它的作用是作为一个中介，它订阅了 `Dep` 的变化（即数据的变化）。当数据变化时，`Dep` 通知 `Watcher`，然后 `Watcher` 会执行相应的更新函数，从而更新视图。
   - 在Vue组件中，每个组件实例都至少有一个 `Watcher`，用于更新组件的渲染。此外，计算属性和监听器也各自有对应的 `Watcher`。

关系和联系：
- 当你在组件的 `data` 中声明一个属性时，Vue 会使用 `Observer` 将其转换为可响应的对象。
- 每个响应式属性都通过 `Observer` 关联一个 `Dep` 实例，用于跟踪这个属性的所有依赖（即哪些 `Watcher` 依赖于这个属性）。
- 当属性被访问或修改时，`Dep` 负责通知所有订阅了这个属性的 `Watcher`，告诉它们数据已经改变，需要重新评估或执行更新函数（比如重新渲染组件）。

简而言之，这个系统使得Vue能够以高效的方式更新DOM来响应数据的改变。每当数据变化时，只有依赖于这些数据的组件会被重新渲染，而不是整个DOM树，这大大提高了性能和效率。





### Watcher

在 Vue.js 的响应式系统中，`Watcher` 是一个非常重要的概念。它是一个对象，负责执行以下两个主要任务：

1. **依赖收集**：当渲染函数或计算属性被求值时，它们会访问响应式数据。每个访问的响应式数据都会记录当前正在执行的 `Watcher` 作为其依赖。这意味着，当这些数据发生变化时，`Watcher` 能够被通知。

2. **响应更新**：当 `Watcher` 所依赖的数据发生变化时，它会执行回调函数来进行相应的更新操作。这通常涉及重新计算计算属性的值或重新渲染组件。

具体来说，`Watcher` 在 Vue.js 中的角色可以这样理解：

- **组件的渲染**：每个 Vue 组件实例都有一个对应的 `Watcher` 实例，用于渲染组件并在组件的依赖数据发生变化时触发重新渲染。
- **计算属性**：每个计算属性也有一个对应的 `Watcher`，当依赖的数据发生变化时，这个 `Watcher` 会重新计算该属性的值。
- **侦听器**：Vue 的 `watch` 选项允许你指定当某些数据变化时执行的回调函数，每个这样的侦听器背后也是通过一个 `Watcher` 实例来实现的。

在 Vue 的内部实现中，`Watcher` 的作用是连接响应式数据和视图之间的桥梁。它使得 Vue 能够以高效和精确的方式更新 DOM，仅当实际需要时才进行更新，从而优化性能并避免不必要的计算。





### Dep

- `Dep` 类是 Vue 响应式系统中用于依赖跟踪的关键组件。每个响应式数据项（如 `data` 的属性）都关联一个 `Dep` 实例。
- 当组件或计算属性等访问这些数据时，它们的 `Watcher` 实例会被添加到相应的 `Dep` 的 `subs` 数组中。
- 当数据变化时，`Dep` 通过调用每个 `Watcher` 的 `update` 方法通知变化，从而触发组件的重新渲染或计算属性的重新计算。





### 为什么还要把这个 Dep 实例添加到这个 Watcher 的依赖中 ？ 有什么用处呢？



将 `Dep` 实例添加到 `Watcher` 的依赖中是 Vue 响应式系统的一个关键步骤，它有几个重要的用途：

1. **双向依赖跟踪**:
   
   在 Vue 的响应式系统中，依赖跟踪是双向的。一个 `Dep` 实例代表一个响应式数据属性，而 `Watcher` 实例代表一个消费这些数据的消费者（如组件或计算属性）。当一个组件访问某个数据属性时，不仅该数据的 `Dep` 需要知道哪些 `Watcher` 依赖于它（以便在数据改变时通知它们），而且每个 `Watcher` 也需要知道它依赖哪些 `Dep`。
   
   - **从 `Dep` 到 `Watcher`**: 当组件或计算属性访问某个响应式数据时（例如，在模板或计算属性中使用），该数据的 `Dep` 实例会收集当前活跃的 `Watcher`（即组件或计算属性的 `Watcher`）。这样，当数据变化时，`Dep` 知道要通知哪些 `Watcher` 更新。
   - **从 `Watcher` 到 `Dep`**: 同时，每个 `Watcher` 也需要知道它依赖于哪些数据。这样，如果组件被销毁或计算属性依赖的数据改变，`Watcher` 可以避免不必要的更新，或者从不再需要的 `Dep` 中清理自己。
   
2. **避免重复收集**:
   
   每个 `Dep` 实例会有多个 `Watcher` 订阅它，但同一个 `Watcher` 不应该重复订阅同一个 `Dep`。当 `Dep` 实例被添加到 `Watcher` 的依赖中时，`Watcher` 可以管理这些依赖并避免重复收集。
   
   - 当多次访问同一个数据时，不需要重复将同一个 `Watcher` 添加到 `Dep` 中。`Watcher` 中会检查是否已经收集了对应的 `Dep`，从而避免重复收集。
   - 当组件销毁或依赖关系改变时，`Watcher` 可以从其依赖的 `Dep` 中移除自己，防止不必要的更新。
   
3. **优化性能**:
   
   - 当组件或计算属性需要重新计算或重新渲染时，Vue 不需要重新计算所有的依赖关系。由于每个 `Watcher` 知道其依赖的确切 `Dep` 实例，Vue 可以精确地确定哪些数据变化需要触发哪些 `Watcher`，从而避免不必要的计算和渲染，提高应用程序的效率和性能。
   
4. **清理和更新依赖**:
   - 在组件的生命周期中，依赖可能会变化（例如，条件渲染可能会访问不同的数据）。`Watcher` 知道自己的所有依赖，使得在需要时可以清理旧的依赖并建立新的依赖关系。

5. **响应式系统的核心机制**:
   - 这种依赖收集机制是 Vue 响应式系统能够高效且准确地响应数据变化的核心。它允许 Vue 在数据变化时仅更新那些真正依赖变化数据的部分，而不是整个应用，从而提高了性能和用户体验。

总之，将 `Dep` 实例添加到 `Watcher` 的依赖中，使 Vue 能够建立一个精确且高效的响应式系统，这对于管理复杂的应用状态和确保高效的更新至关重要。





### 在 Watcher 的 class 中  为何需要有 2 个 Dep 实例数组呢？ this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set()

在 Vue.js 的 `Watcher` 类中，存在两组 `Dep` 实例数组（`this.deps` 和 `this.newDeps`）以及对应的 `Set`（`this.depIds` 和 `this.newDepIds`）。这种设计是为了高效且准确地管理依赖收集和清理过程。让我们来探讨一下这些数组和集合的作用和原因。

1. **this.deps 和 this.depIds**：
   - `this.deps` 用于存储 `Watcher` 当前所依赖的所有 `Dep` 实例。
   - `this.depIds` 是一个 `Set`，用于存储 `this.deps` 中每个 `Dep` 实例的唯一标识符（id）。这个 `Set` 主要用于快速检查 `Watcher` 是否已经收集了特定的 `Dep` 实例，从而避免重复收集。

2. **this.newDeps 和 this.newDepIds**：
   - `this.newDeps` 在每次 `Watcher` 重新求值时用于临时存储新的 `Dep` 实例。
   - `this.newDepIds` 作为 `Set` 存储 `this.newDeps` 中每个 `Dep` 实例的唯一标识符（id），用于快速检查避免重复收集。

这种设计的原因是：

- **避免重复收集**：在组件重新渲染或计算属性重新计算时，`Watcher` 可能会再次访问相同的响应式数据。通过这两组集合，Vue 可以确保不会重复收集相同的依赖。

- **清理不再需要的依赖**：当 `Watcher` 的依赖发生变化时（例如，组件的模板或计算属性的依赖项更改），需要移除那些不再需要的依赖。通过比较 `this.deps` 和 `this.newDeps`，Vue 可以识别出哪些依赖不再需要，并相应地进行清理。

在每次依赖收集的结束时，Vue 会执行以下操作：

- 将 `this.newDeps` 赋值给 `this.deps`，以便在下一次求值时使用。
- 清空 `this.newDeps` 和 `this.newDepIds` 以备下次使用。
- 使用 `this.depIds` 和 `this.newDepIds` 来确保不会重复收集依赖和正确地移除不再需要的依赖。

这种机制确保了 Vue 的响应式系统既高效又准确，能够根据组件的实际需要动态调整其依赖关系。



### 不要 Dep，属性直接关联 watcher 可以吗？ 属性变了，然后通知 watcher 进行更新？

您提出的这个想法，即属性直接关联 `Watcher` 而不经由 `Dep` 实例，理论上是可行的。但在实际应用中，使用 `Dep` 实例作为中间层有几个重要的优点，这些优点在 Vue 的设计中起到了关键作用：

1. **解耦数据和观察者**：
   - 使用 `Dep` 实例作为中介，可以将数据属性和依赖于这些属性的观察者（`Watcher`）解耦。这意味着数据层不需要直接知道谁在观察它，也不需要知道观察者具体需要执行哪些操作。

2. **管理多对多的关系**：
   - 在复杂的应用中，一个 `Watcher` 可能依赖多个数据属性，同样一个属性也可能被多个 `Watcher` 所依赖。`Dep` 实例作为中间层可以更高效地管理这种多对多的关系。

3. **避免重复收集依赖**：
   - 通过 `Dep` 实例，Vue 可以有效地避免重复收集依赖。当一个 `Watcher` 被多次触发相同属性的 getter 时，`Dep` 实例确保这个 `Watcher` 只被添加一次。

4. **优化依赖更新**：
   - 当属性发生变化时，`Dep` 实例可以有效地通知所有相关的 `Watcher` 进行更新。如果没有 `Dep` 层，每个属性直接管理它的 `Watcher` 列表可能会导致效率低下，特别是在涉及大量数据和观察者时。

5. **灵活性和可维护性**：
   - 使用 `Dep` 实例作为中间层提供了更好的灵活性和可维护性。这种模式使得 Vue 的内部机制更容易扩展和优化，同时对开发者而言，这种抽象也使得框架的使用更简单、更直观。

总之，虽然属性直接关联 `Watcher` 在某些方面看似简化了设计，但实际上使用 `Dep` 实例为中间层在管理复杂依赖关系、优化性能、提高代码的灵活性和可维护性方面提供了显著优势。这是 Vue.js 响应式系统设计的一个关键部分。







### 挂载更新



![img](https://qn.huat.xyz/mac/202401031144373.png)







### 编译相关

![image-20240104224138741](https://qn.huat.xyz/mac/202401042241828.png)





![image-20240104225457248](https://qn.huat.xyz/mac/202401042254279.png)















### 初始渲染过程



1.  **实例化 Vue**： 

- - 创建一个新的 Vue 实例。
  - 初始化实例属性、事件等。

1.  **初始化阶段** (`init` 方法)： 

- - 设置数据观察者（`Observer`），将 `data` 中的属性转换为响应式属性。
  - 编译模板，将模板（字符串或 DOM 元素）转换为渲染函数（`render` 函数）。

1.  **挂载阶段** (`vm.$mount` 方法)： 

- - 如果未提供渲染函数，Vue 会将模板编译成 `render` 函数。
  - 创建一个 `Watcher` 实例来监听数据变化，并在首次调用 `render` 函数生成虚拟 DOM。

1.  **虚拟 DOM 渲染** (`render` 函数)： 

- - 根据实例的状态生成虚拟 DOM。

1.  **真实 DOM 渲染** (`_update` 方法)： 

- - 调用 `patch` 函数，将虚拟 DOM 转换为真实 DOM，并挂载到指定的挂载点。



### 更新过程



1.  **数据变化**： 

- - 当响应式数据发生变化时，触发依赖该数据的 `Watcher`。

1.  **重新渲染** (`Watcher` 的回调函数)： 

- - `Watcher` 检测到数据变化，会再次调用 `render` 函数生成新的虚拟 DOM。

1.  **虚拟 DOM 重新渲染** (`render` 函数)： 

- - 根据最新的组件状态生成新的虚拟 DOM。

1.  **DOM 更新** (`_update` 方法)： 

- - 再次调用 `patch` 函数，比较新旧虚拟 DOM 的差异。

1.  **虚拟 DOM Diff 算法** (`patch` 方法)： 

- - 使用 diff 算法比较新旧虚拟 DOM 树的差异。
  - 调用 `updateChildren` 等方法来高效地更新子节点。

1.  **应用 DOM 更新**： 

- - 根据 diff 算法的结果，执行实际的 DOM 更新操作（如节点的添加、删除、更新）。
  - 如果涉及组件，执行相关的生命周期钩子（如 `beforeUpdate` 和 `updated`）。

1.  **更新完成**： 

- - 完成所有 DOM 更新后，视图与组件的最新状态保持一致。



在这个过程中，Vue 的响应式系统、虚拟 DOM 和 diff 算法共同工作，确保只有必要的组件进行重渲染，并且 DOM 操作是高效的。这种机制使得 Vue 在处理复杂界面时仍能保持良好的性能。