

使用 `import()` 语法会告诉打包工具（如 webpack）对代码进行分割。每个异步组件的代码会被分割成一个单独的代码块（chunk），在需要时才会加载。



## import动态导入和静态导入区别

1. **加载时机**

   - **静态导入**：在程序开始执行前或编译时就已经加载了所需的模块。所有依赖的模块在程序启动时一次性加载完成。
   - **动态导入**：在程序运行过程中，根据需要才加载模块。只有当代码执行到导入语句时，才会实际加载模块。
2. **语法与使用方式**

   - **静态导入**：
     - 在 JavaScript（ES6）中：`import moduleName from 'module'`
   - **动态导入**：
     - 在 JavaScript 中：`import('module').then(module => { /* 使用模块 */ })`
3. **灵活性**

   - **静态导入**：模块名和要导入的内容在代码编写时就已经确定，不能在运行时改变。
   - **动态导入**：可以在运行时根据条件、用户输入或其他因素决定导入哪个模块，实现更高的灵活性。
4. **性能影响**

   - **静态导入**：在程序启动时就加载所有模块，可能增加初始加载时间，但在运行过程中不需要再次加载，性能较稳定。
   - **动态导入**：初始加载时间较短，但在需要加载新模块时，会有加载延迟。适合于大型应用中按需加载，减少初始开销。
5. **作用域与可访问性**

   - **静态导入**：导入的模块或函数在整个模块范围内可用。
   - **动态导入**：通常在导入所在的作用域内可用，可能需要注意命名空间和作用域管理。
6. **错误处理**

   - **静态导入**：如果模块不存在或导入失败，程序在启动时就会抛出错误，阻止程序运行。
   - **动态导入**：可以使用异常处理机制捕获导入错误，程序可以继续运行或采取其他措施。
7. **工具支持**

   - **静态导入**：更容易被静态分析工具、代码补全和类型检查所支持，有助于提高代码质量。
   - **动态导入**：由于模块名是动态的，可能无法被静态分析工具检测，增加了调试和维护的难度。

**总结：**

- **静态导入**适用于依赖关系固定、模块数量较少的场景，代码可读性和维护性更高。
- **动态导入**适用于需要按需加载、插件化开发或依赖关系动态变化的场景，提高了程序的灵活性和性能优化空间。



## CommonJS

**CommonJS**（Node.js 所采用的模块规范）使用的是 `require()` 函数来导入模块。由于 `require()` 是在运行时执行的函数调用，导入的模块可以根据条件、变量或其他运行时信息动态决定，这使得导入过程具有动态特性。

**为什么 CommonJS 不支持有效的 Tree-Shaking：**

1. **动态导入特性**：

   - **运行时决策**：`require()` 可以放在代码的任何位置，甚至在函数内部、条件语句或循环中。这意味着模块的导入是动态的，无法在编译时确定。

2. **静态分析困难**：

   - **无法确定依赖关系**：Tree-Shaking 依赖于编译时的静态分析，以确定哪些模块和代码实际被使用。由于 CommonJS 的模块导入是动态的，静态分析工具无法准确地跟踪依赖关系。

3. **代码优化受限**：

   - **无法删除未使用代码**：因为无法确定哪些代码在运行时会被使用，打包工具（如 Webpack、Rollup）无法安全地删除未被引用的代码。

**相比之下，ES Module（ESM）规范：**

- **静态导入**：使用 `import` 和 `export` 关键字，模块依赖关系在编译时就可以确定。

- **支持 Tree-Shaking**：由于依赖关系是静态的，打包工具可以准确地识别并删除未使用的代码。



## 为什么使用 `import()` 语法就能实现代码分割？

`import()` 是 ECMAScript 提案中的一种动态导入语法，它允许在运行时按需加载模块。与静态的 `import` 语句不同，`import()` 会返回一个 `Promise`，并且可以在代码的任何地方使用。

静态导入（Static Import）：

```js
import module from './module.js';
```

静态导入在编译时就会被解析，所有被导入的模块都会被直接打包到最终的文件中。



动态导入（Dynamic Import）：

```js
const modulePromise = import('./module.js');
```

动态导入是在运行时才会去加载指定的模块，这为代码分割和懒加载提供了可能。



### **编译时无法确定模块**

`import()` 是动态的，传入的路径可以是在运行时确定的。由于编译时无法知道具体需要加载哪些模块，Webpack 只能将这些模块单独打包，以备运行时加载。

### **提示 Webpack 进行代码分割**

`import()` 明确地告诉 Webpack，这部分代码需要被分割到一个单独的 Chunk 中，并在需要时异步加载。

### **异步加载的天然支持**

`import()` 返回一个 Promise，这与异步加载的机制相匹配，使得浏览器可以在需要时加载对应的模块，而不影响主线程的执行。



好处：

**减少初始加载时间**

通过将不必要的代码分割出去，可以显著减少初始加载的 JavaScript 文件大小，提高首屏渲染速度。

**按需加载**

只有在用户需要某个功能时，才加载对应的代码，提高了资源的利用率。

**并行加载**

浏览器可以并行加载多个 Chunk，提高加载效率。





## Webpack 如何处理 `import()`

### 代码分割点的识别

Webpack 是一个模块打包工具，它在处理代码时，会扫描你的代码，构建一个依赖图。在默认情况下，Webpack 会将所有的模块打包到一个单独的 JavaScript 文件中。

但是，当 Webpack 遇到 `import()` 时，会将其视为一个代码分割点（Split Point）。这意味着被 `import()` 引用的模块将被放入一个单独的代码块（chunk）中。

### **代码分割的实现**

- **创建 Chunk：**

  当 Webpack 解析到 `import()` 时，会创建一个新的 Chunk，用于包含被导入的模块及其依赖。

- **生成动态加载代码：**

  Webpack 会在打包后的代码中，插入动态加载 Chunk 的代码。当代码运行到 `import()` 时，会触发对该 Chunk 的加载。

- **使用 Webpack 的魔法注释（Magic Comments）：**

  你可以使用魔法注释来控制生成的 Chunk，例如命名 Chunk、设置预加载等。

  ```js
  import(/* webpackChunkName: "my-chunk" */ './module.js');
  ```

