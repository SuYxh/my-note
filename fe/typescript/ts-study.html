<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MY-NOTE</title>
    <meta name="description" content="成长之路，包含前端常用知识、源码阅读笔记、各种奇淫技巧、日常提效工具等">
    <meta name="generator" content="VitePress v1.0.0-rc.42">
    <link rel="preload stylesheet" href="/my-note/assets/style.Wuk6Ca9c.css" as="style">
    
    <script type="module" src="/my-note/assets/app.1tSQOf9h.js"></script>
    <link rel="preload" href="/my-note/assets/inter-roman-latin.bvIUbFQP.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/my-note/assets/chunks/framework.hxTji2_l.js">
    <link rel="modulepreload" href="/my-note/assets/chunks/theme.biAOaOSG.js">
    <link rel="modulepreload" href="/my-note/assets/fe_typescript_ts-study.md.vHTDiOl4.lean.js">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileColor" content="#000000">
    <meta name="msapplication-TileImage" content="/favicon.ico">
    <meta name="baidu-site-verification" content="codeva-Whjnr38WFE">
    <link rel="apple-touch-icon" href="/favicon.ico">
    <link rel="mask-icon" href="/favicon.ico" color="#3eaf7c">
    <link rel="manifest" href="/manifest.webmanifest">
    <script src="https://hm.baidu.com/hm.js?8092fab2f2adfc7938ba5b8885aef5b4"></script>
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-39b8670e><!--[--><!--]--><!--[--><span tabindex="-1" data-v-f86abc88></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-f86abc88> Skip to content </a><!--]--><!----><header class="VPNav" data-v-39b8670e data-v-5564ad85><div class="VPNavBar has-sidebar" data-v-5564ad85 data-v-ba5a6291><div class="wrapper" data-v-ba5a6291><div class="container" data-v-ba5a6291><div class="title" data-v-ba5a6291><div class="VPNavBarTitle has-sidebar" data-v-ba5a6291 data-v-08027d8e><a class="title" href="/my-note/" data-v-08027d8e><!--[--><!--]--><!--[--><img class="VPImage logo" src="/my-note/logo.png" alt data-v-4712ab32><!--]--><span data-v-08027d8e>MY-NOTE</span><!--[--><!--[--><!--[--><!--[--><img class="visitor" src="https://visitor-badge.laobi.icu/badge?page_id=xinhao.notes" onerror="this.style.display=&#39;none&#39;" data-v-eb8806b1><!--]--><!--]--><!--]--><!--]--></a></div></div><div class="content" data-v-ba5a6291><div class="content-body" data-v-ba5a6291><!--[--><!--]--><div class="VPNavBarSearch search" data-v-ba5a6291><!--[--><!----><div id="docsearch"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg class="DocSearch-Search-Icon" width="20" height="20" viewBox="0 0 20 20" aria-label="search icon"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-ba5a6291 data-v-b0404748><span id="main-nav-aria-label" class="visually-hidden" data-v-b0404748>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/my-note/nav" tabindex="0" data-v-b0404748 data-v-44024336><!--[--><span data-v-44024336>项目</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-b0404748 data-v-ea401803><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-ea401803><span class="text" data-v-ea401803><!----><span data-v-ea401803>基础</span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-ea401803><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-ea401803><div class="VPMenu" data-v-ea401803 data-v-1c764e68><div class="items" data-v-1c764e68><!--[--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/fe/basicknowledge/concept/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F" data-v-6409e986><!--[-->基础知识<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/fe/html/index" data-v-6409e986><!--[-->html<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/fe/css/index" data-v-6409e986><!--[-->CSS<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/fe/javascript/types" data-v-6409e986><!--[-->JavaScript<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/fe/es6/" data-v-6409e986><!--[-->ECMAScript 6<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/fe/typescript/base" data-v-6409e986><!--[-->TypeScript<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-b0404748 data-v-ea401803><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-ea401803><span class="text" data-v-ea401803><!----><span data-v-ea401803>框架</span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-ea401803><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-ea401803><div class="VPMenu" data-v-ea401803 data-v-1c764e68><div class="items" data-v-1c764e68><!--[--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/frame/vue/index" data-v-6409e986><!--[-->vue<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/frame/react/index" data-v-6409e986><!--[-->react<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/frame/different/index" data-v-6409e986><!--[-->区别<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-b0404748 data-v-ea401803><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-ea401803><span class="text" data-v-ea401803><!----><span data-v-ea401803>工程化</span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-ea401803><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-ea401803><div class="VPMenu" data-v-ea401803 data-v-1c764e68><div class="items" data-v-1c764e68><!--[--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/engineering/package/index" data-v-6409e986><!--[-->包管理工具<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/engineering/standard/index" data-v-6409e986><!--[-->项目规范<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/engineering/buildTools/index" data-v-6409e986><!--[-->构建<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/engineering/deploy/index" data-v-6409e986><!--[-->部署<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-b0404748 data-v-ea401803><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-ea401803><span class="text" data-v-ea401803><!----><span data-v-ea401803>服务端</span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-ea401803><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-ea401803><div class="VPMenu" data-v-ea401803 data-v-1c764e68><div class="items" data-v-1c764e68><!--[--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/afterEnd/node/index" data-v-6409e986><!--[-->Node<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/afterEnd/db/index" data-v-6409e986><!--[-->数据库<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/afterEnd/nginx/index" data-v-6409e986><!--[-->Nginx<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-b0404748 data-v-ea401803><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-ea401803><span class="text" data-v-ea401803><!----><span data-v-ea401803>专题</span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-ea401803><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-ea401803><div class="VPMenu" data-v-ea401803 data-v-1c764e68><div class="items" data-v-1c764e68><!--[--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/subject/chatGPT/index" data-v-6409e986><!--[-->AI<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/subject/mobile/index" data-v-6409e986><!--[-->移动端<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/subject/harmonyOS/index" data-v-6409e986><!--[-->鸿蒙开发<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/subject/weixin/index" data-v-6409e986><!--[-->微信相关<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/subject/performance/index" data-v-6409e986><!--[-->性能优化<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/subject/dataStructure/index" data-v-6409e986><!--[-->数据结构与算法<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-b0404748 data-v-ea401803><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-ea401803><span class="text" data-v-ea401803><!----><span data-v-ea401803>Me</span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-ea401803><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-ea401803><div class="VPMenu" data-v-ea401803 data-v-1c764e68><div class="items" data-v-1c764e68><!--[--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link vp-external-link-icon" href="https://www.yuque.com/jarvis-zzzhw/frontend?# 《Front-End》" target="_blank" rel="noreferrer" data-v-6409e986><!--[-->语雀<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link vp-external-link-icon" href="https://juejin.cn/user/2084329779636094/posts" target="_blank" rel="noreferrer" data-v-6409e986><!--[-->掘金<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/pit/index" data-v-6409e986><!--[-->经验<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/tools/index" data-v-6409e986><!--[-->工具<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-1c764e68 data-v-6409e986><a class="VPLink link" href="/my-note/interview/index" data-v-6409e986><!--[-->🔒<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-ba5a6291 data-v-ff1a2bad><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-ff1a2bad data-v-643139dc data-v-adf535c5><span class="check" data-v-adf535c5><span class="icon" data-v-adf535c5><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-643139dc><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-643139dc><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><!----><div class="VPFlyout VPNavBarExtra extra" data-v-ba5a6291 data-v-5e25dd8f data-v-ea401803><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-ea401803><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-ea401803><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-ea401803><div class="VPMenu" data-v-ea401803 data-v-1c764e68><!----><!--[--><!--[--><!----><div class="group" data-v-5e25dd8f><div class="item appearance" data-v-5e25dd8f><p class="label" data-v-5e25dd8f>外观</p><div class="appearance-action" data-v-5e25dd8f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-5e25dd8f data-v-643139dc data-v-adf535c5><span class="check" data-v-adf535c5><span class="icon" data-v-adf535c5><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-643139dc><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-643139dc><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-ba5a6291 data-v-2ffe8fd0><span class="container" data-v-2ffe8fd0><span class="top" data-v-2ffe8fd0></span><span class="middle" data-v-2ffe8fd0></span><span class="bottom" data-v-2ffe8fd0></span></span></button></div></div></div></div><div class="divider" data-v-ba5a6291><div class="divider-line" data-v-ba5a6291></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-39b8670e data-v-e6fafaf7><div class="container" data-v-e6fafaf7><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-e6fafaf7><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-e6fafaf7><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-e6fafaf7>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-e6fafaf7 data-v-d030a23e><button data-v-d030a23e>返回顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-39b8670e data-v-89fdbb46><div class="curtain" data-v-89fdbb46></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-89fdbb46><span class="visually-hidden" id="sidebar-aria-label" data-v-89fdbb46> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-89fdbb46><section class="VPSidebarItem level-0 collapsible" data-v-89fdbb46 data-v-0e1f047c><div class="item" role="button" tabindex="0" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><h2 class="text" data-v-0e1f047c>基础</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-0e1f047c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-0e1f047c><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-0e1f047c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/base/02-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8TS%E5%92%8CTS%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>为什么使用TS和TS运行环境搭建</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/base/03-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E7%A9%BA%E9%97%B4" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>类型声明空间与变量声明空间</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/base/04-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>类型注解与类型推断</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/base/05-%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB%E4%B8%8E%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E4%B8%8E%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>类型分类与联合类型与交叉类型</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/base/06-never%E7%B1%BB%E5%9E%8B%E4%B8%8Eany%E7%B1%BB%E5%9E%8B%E4%B8%8Eunknown%E7%B1%BB%E5%9E%8B" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>never类型与any类型与unknown类型</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/base/07-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%B8%8E%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>类型断言与非空断言</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/base/08-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>数组类型与元组类型</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/base/09-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>对象类型与索引签名</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/base/10-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8Evoid%E7%B1%BB%E5%9E%8B" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>函数类型与void类型</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/base/11-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%8F%AF%E8%B0%83%E7%94%A8%E6%B3%A8%E8%A7%A3" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>函数重载与可调用注解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/base/12-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%B8%8Econst%E6%9E%9A%E4%B8%BE" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>枚举类型与const枚举</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-89fdbb46><section class="VPSidebarItem level-0 collapsible collapsed" data-v-89fdbb46 data-v-0e1f047c><div class="item" role="button" tabindex="0" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><h2 class="text" data-v-0e1f047c>进阶</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-0e1f047c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-0e1f047c><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-0e1f047c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/advance/02-%E8%AF%A6%E8%A7%A3%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E4%B9%8B%E9%97%B4%E5%8C%BA%E5%88%AB" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>详解接口与类型别名之间区别</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/advance/03-%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8Ckeyof%E5%85%B3%E9%94%AE%E5%AD%97" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>字面量类型和keyof关键字</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/advance/04-%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>类型保护与自定义类型保护</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/advance/05-%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E5%92%8C%E6%B3%9B%E5%9E%8B%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>定义泛型和泛型常见操作</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/advance/06-%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7%E8%AF%A6%E8%A7%A3" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>类型兼容性详解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/advance/07-%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>映射类型与内置工具类型</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/advance/08-%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%92%8Cinfer%E5%85%B3%E9%94%AE%E5%AD%97" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>条件类型和infer关键字</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/advance/09-%E7%B1%BB%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>类中如何使用类型</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/advance/10-%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>模板字符串类型</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/advance/d%E7%82%B9ts%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E5%92%8Cdeclare%E5%85%B3%E9%94%AE%E5%AD%97" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>d.ts声明文件和declare关键字</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/advance/@types%E5%92%8CDefinitelyTyped%E4%BB%93%E5%BA%93" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>@types和DefinitelyTyped仓库</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/advance/lib_d_ts%E5%92%8Cglobal_d_ts" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>lib.d.ts和global.d.ts</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/advance/%E8%AF%A6%E8%A7%A3tsconfigjson%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>详解tsconfigjson配置文件</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/advance/%E9%85%8D%E7%BD%AE%E4%BD%A0%E7%9A%84TypeScript" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>配置你的TypeScript</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-89fdbb46><section class="VPSidebarItem level-0 collapsible" data-v-89fdbb46 data-v-0e1f047c><div class="item" role="button" tabindex="0" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><h2 class="text" data-v-0e1f047c>内置工具类型</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-0e1f047c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-0e1f047c><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-0e1f047c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/tool/%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B-1" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>内置工具类型-1</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/tool/%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B-2" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>内置工具类型-2</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-89fdbb46><section class="VPSidebarItem level-0 collapsible has-active" data-v-89fdbb46 data-v-0e1f047c><div class="item" role="button" tabindex="0" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><h2 class="text" data-v-0e1f047c>其他</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-0e1f047c><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-0e1f047c><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-0e1f047c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/index" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>简介</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/base" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>typescript</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-0e1f047c data-v-0e1f047c><div class="item" data-v-0e1f047c><div class="indicator" data-v-0e1f047c></div><a class="VPLink link link" href="/my-note/fe/typescript/ts-study" data-v-0e1f047c><!--[--><p class="text" data-v-0e1f047c>ts-study</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-39b8670e data-v-196404f9><div class="VPDoc has-sidebar has-aside" data-v-196404f9 data-v-6c989021><!--[--><!--]--><div class="container" data-v-6c989021><div class="aside" data-v-6c989021><div class="aside-curtain" data-v-6c989021></div><div class="aside-container" data-v-6c989021><div class="aside-content" data-v-6c989021><div class="VPDocAside" data-v-6c989021 data-v-e197b2d0><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" role="navigation" data-v-e197b2d0 data-v-d47d39ea><div class="content" data-v-d47d39ea><div class="outline-marker" data-v-d47d39ea></div><div class="outline-title" role="heading" aria-level="2" data-v-d47d39ea>本页目录</div><nav aria-labelledby="doc-outline-aria-label" data-v-d47d39ea><span class="visually-hidden" id="doc-outline-aria-label" data-v-d47d39ea> Table of Contents for current page </span><ul class="VPDocOutlineItem root" data-v-d47d39ea data-v-a6309792><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-e197b2d0></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--[--><!--[--><!--[--><div class="VPDocAsideSponsors"><div class="VPSponsors vp-sponsor aside"><!--[--><section class="vp-sponsor-section"><!----><div class="VPSponsorsGrid vp-sponsor-grid medium"><!--[--><div class="vp-sponsor-grid-item"><a class="vp-sponsor-grid-link" target="_blank" rel="sponsored noopener"><article class="vp-sponsor-grid-box"><h4 class="visually-hidden"></h4><img class="vp-sponsor-grid-image" src="https://qn.huat.xyz/mac/202308122340742.jpg"></article></a></div><!--]--></div></section><section class="vp-sponsor-section"><!----><div class="VPSponsorsGrid vp-sponsor-grid medium"><!--[--><div class="vp-sponsor-grid-item"><a class="vp-sponsor-grid-link" target="_blank" rel="sponsored noopener"><article class="vp-sponsor-grid-box"><h4 class="visually-hidden"></h4><img class="vp-sponsor-grid-image" src="https://qn.huat.xyz/mac/202308122340353.jpg"></article></a></div><!--]--></div></section><!--]--></div></div><!--]--><!--]--><!--]--><!--]--></div></div></div></div><div class="content" data-v-6c989021><div class="content-container" data-v-6c989021><!--[--><!--]--><main class="main" data-v-6c989021><div style="position:relative;" class="vp-doc _my-note_fe_typescript_ts-study" data-v-6c989021><div><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>一边学习，一边记录，前前后后花了至少 2 个月的时间，算是把 TS 大部分都搞明白了。</p><p>这篇文章的篇幅有点长，是我本人学习过程中的一些记录，参考了很多优秀博主的一些文章，以及在 B 站看了一些 TS 的视频，把几乎所有 TS 涵盖到的基础知识点都总结了下来，所以，对于想学习 TS 的小伙伴下来，一定一定要认认真真把这篇文章看完。</p><p><strong>8 万多字的教程，不敢说是全网最好，但可以说是全网最详细。</strong></p><p>对于新手入门来说是一篇非常不错的宝藏文章，几乎每个 TypeScript 的知识点都有详细的讲到，并且附上一些简单的示例，通俗易懂，希望可以给想学习 TS 的小伙伴带来动力！</p><h2 id="一、了解-typescript" tabindex="-1">一、了解 TypeScript <a class="header-anchor" href="#一、了解-typescript" aria-label="Permalink to &quot;一、了解 TypeScript&quot;">​</a></h2><h2 id="_1-什么是-typescript" tabindex="-1">1. 什么是 TypeScript <a class="header-anchor" href="#_1-什么是-typescript" aria-label="Permalink to &quot;1\. 什么是 TypeScript&quot;">​</a></h2><ul><li>TypeScript 是由微软开发的一门开源的编程语言。</li><li>TypeScript，简称 TS，是 JavaScript 的超集（以 JavaScript 为基础构建的语言，JS 有的 TS 都有）。</li><li>Typescript = Type + JavaScript（在 JS 基础之上，为 JS 添加了类型支持）。</li><li>可以在任何支持 JavaScript 的平台中执行。</li></ul><h2 id="_2-为什么需要-typescript" tabindex="-1">2. 为什么需要 TypeScript <a class="header-anchor" href="#_2-为什么需要-typescript" aria-label="Permalink to &quot;2\. 为什么需要 TypeScript&quot;">​</a></h2><p>我们都知道，JavaScript 是弱类型的编程语言，很多的错误只有在运行的时候才会被发现，而 TS 在代码编译的时候（代码执行前）就可以发现错误。</p><h2 id="_3-typescript-的特点" tabindex="-1">3. TypeScript 的特点 <a class="header-anchor" href="#_3-typescript-的特点" aria-label="Permalink to &quot;3\. TypeScript 的特点&quot;">​</a></h2><ul><li>支持最新的 ECMAScript 语法</li><li>在代码编译阶段就能发现错误</li><li>在 JS 基础上增加了类型支持</li></ul><h2 id="_4-typescript-和-javascript-的区别" tabindex="-1">4. TypeScript 和 JavaScript 的区别 <a class="header-anchor" href="#_4-typescript-和-javascript-的区别" aria-label="Permalink to &quot;4\. TypeScript 和 JavaScript 的区别&quot;">​</a></h2><table><thead><tr><th><strong>TypeScript</strong></th><th><strong>JavaScript</strong></th></tr></thead><tbody><tr><td>编译期发现错误</td><td>运行时发现错误</td></tr><tr><td>强类型语言，支持静态和动态类型</td><td>弱类型语言，没有静态类型选项</td></tr><tr><td>支持模块、泛型和接口</td><td>不支持模块、泛型和接口</td></tr><tr><td>代码运行时会被编译成 JavaScript 代码，浏览器才能识别</td><td>可以直接在浏览器使用</td></tr></tbody></table><h2 id="二、typescript-环境搭建" tabindex="-1">二、TypeScript 环境搭建 <a class="header-anchor" href="#二、typescript-环境搭建" aria-label="Permalink to &quot;二、TypeScript 环境搭建&quot;">​</a></h2><h2 id="_1-安装编译-ts-的工具包" tabindex="-1">1. 安装编译 TS 的工具包 <a class="header-anchor" href="#_1-安装编译-ts-的工具包" aria-label="Permalink to &quot;1\. 安装编译 TS 的工具包&quot;">​</a></h2><p><code>npm i -g typescript</code></p><h2 id="_2-验证-ts-是否安装成功" tabindex="-1">2. 验证 TS 是否安装成功 <a class="header-anchor" href="#_2-验证-ts-是否安装成功" aria-label="Permalink to &quot;2\. 验证 TS 是否安装成功&quot;">​</a></h2><p><code>tsc -v</code></p><h2 id="_3-typescript-初体验" tabindex="-1">3. TypeScript 初体验 <a class="header-anchor" href="#_3-typescript-初体验" aria-label="Permalink to &quot;3\. TypeScript 初体验&quot;">​</a></h2><ol><li>创建一个 TS 文件，hello.ts（注意：TS 文件的后缀名为 <strong>.ts</strong>），并输入以下的内容</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function greet(name: string): string {</span></span>
<span class="line"><span>  return `hello, ${name}`</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let user = &quot;Echo&quot;</span></span>
<span class="line"><span>console.log(greet(&quot;Echo&quot;))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="2"><li>将 TS 文件编译为 JS 文件，在终端中输入命令：<strong>tsc hello.ts，</strong> （此时，在同级目录中会出现一个同名的 JS 文件）</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&quot;use strict&quot;;</span></span>
<span class="line"><span>function greet(name) {</span></span>
<span class="line"><span>    return &quot;Hello, &quot;.concat(name);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var user = &quot;Echo&quot;;</span></span>
<span class="line"><span>console.log(greet(user));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="3"><li>执行 JS 代码：在终端中输入命令，<strong>node hello.js</strong>，终端会输出 hello, Echo。</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&quot;hello, Echo&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90017e6f068c47e698c676833bf4aa09~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=654&amp;h=521&amp;s=42652&amp;e=png&amp;b=ffffff" alt=""></p><h2 id="_4-简化运行-ts-的步骤" tabindex="-1">4. 简化运行 TS 的步骤 <a class="header-anchor" href="#_4-简化运行-ts-的步骤" aria-label="Permalink to &quot;4\. 简化运行 TS 的步骤&quot;">​</a></h2><p>每次修改代码后，都要重复执行两个命令，才能运行 TS 代码，我们可以直接使用<strong>ts-node</strong>工具包，直接在 node.js 中执行 TS 代码。</p><p>安装命令：<strong>npm i -g ts-node</strong></p><p>使用方式：<strong>ts-node hello.ts</strong></p><h2 id="_5-运行-ts-文件的另一种方法" tabindex="-1">5. 运行 TS 文件的另一种方法 <a class="header-anchor" href="#_5-运行-ts-文件的另一种方法" aria-label="Permalink to &quot;5\. 运行 TS 文件的另一种方法&quot;">​</a></h2><p>在 VSCode 中安装<strong>Code Runner</strong>扩展插件，在需要运行的 ts 文件中按鼠标右键，选择<strong>Run Code</strong>(快捷键：<strong>Ctrl+Alt+N</strong>)。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/637a9df1adaf478a8d61308d33ff24e1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=670&amp;h=393&amp;s=46211&amp;e=png&amp;b=fefefe" alt=""></p><h2 id="_6-typescript-playground-线上环境" tabindex="-1">6. TypeScript Playground 线上环境 <a class="header-anchor" href="#_6-typescript-playground-线上环境" aria-label="Permalink to &quot;6\. TypeScript Playground 线上环境&quot;">​</a></h2><p>对于刚入门 TypeScript 的小伙伴来说，我们可以不用安装本地的运行环境，而是直接使用线上的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Fplay%3F%23code%2FGYVwdgxgLglg9mABAcwKZQGIgDbYHICGAtqgBTAwBOAzlISQFyK2UxjIA0i2Bt9qTFm2QBKQVFbtEAbwCwAKESJK6EJSQUadYqkQBqRACIA%2Bof3de2kgoC%2BChRAS1EoXP0QBeFOixudpQwBRCAALOEMuQwAFVHZDEQcnOGxUADpsOGRyHHwdESA" title="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAcwKZQGIgDbYHICGAtqgBTAwBOAzlISQFyK2UxjIA0i2Bt9qTFm2QBKQVFbtEAbwCwAKESJK6EJSQUadYqkQBqRACIA+of3de2kgoC+ChRAS1EoXP0QBeFOixudpQwBRCAALOEMuQwAFVHZDEQcnOGxUADpsOGRyHHwdESA" target="_blank" rel="noreferrer">TypeScript Playground</a>，我们就可以在浏览器中学习和编写 TypeScript 代码，通过配置 TS Config 的 Target，可以设置不同的编译目标，从而编译生成不同的目标代码。</p><h2 id="三、typescript-类型注解" tabindex="-1">三、TypeScript 类型注解 <a class="header-anchor" href="#三、typescript-类型注解" aria-label="Permalink to &quot;三、TypeScript 类型注解&quot;">​</a></h2><h2 id="_1-类型注解作用" tabindex="-1">1. 类型注解作用 <a class="header-anchor" href="#_1-类型注解作用" aria-label="Permalink to &quot;1\. 类型注解作用&quot;">​</a></h2><p><strong>TS 类型注解的作用是为变量、函数、类等添加类型信息，用于在静态类型检查阶段检查代码的类型正确性。</strong></p><h2 id="_2-类型注解用途" tabindex="-1">2. 类型注解用途 <a class="header-anchor" href="#_2-类型注解用途" aria-label="Permalink to &quot;2\. 类型注解用途&quot;">​</a></h2><ol><li>提供类型提示：类型注解使得开发人员可以清晰地知道变量的类型，编辑器能够根据类型注解给出相应的代码提示，提高代码的可读性和可维护性。</li><li>静态类型检查：通过给变量添加类型注解，在编译阶段可以对代码进行静态类型检查。它会检查变量的类型是否符合预期的类型，并发现潜在的类型错误。</li><li>函数参数类型检查：类型注解可以帮助开发人员在编写函数时明确参数的类型，并在调用函数时进行参数类型检查。这样可以避免因参数类型不匹配引发的潜在错误。</li><li>对象属性类型约束：通过类型注解，可以约束对象的属性类型，确保对象的属性符合特定的类型要求。</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e7d0b43a7394076a4681278abbaf4dc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=185&amp;h=78&amp;s=3643&amp;e=png&amp;b=fffefe" alt=""></p><p>例如，上述代码中的 <strong>: number</strong> 就是<strong>类型注解。</strong> 约定变量 num 的类型为 number（数值类型）。</p><h2 id="_3-类型注解注意事项" tabindex="-1">3. 类型注解注意事项 <a class="header-anchor" href="#_3-类型注解注意事项" aria-label="Permalink to &quot;3\. 类型注解注意事项&quot;">​</a></h2><ol><li><strong>约定了什么类型，就只能给变量赋值该类型的值</strong>，否则，就会报错。</li></ol><p>例如，我们将变量 num 的值 123，重新赋值为字符串的“456”，此时我们就可以看到编辑器的错误提示：不能将类型“string”分配给类型“number”。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e32be756d7b45d29ea2cb50d6ccddb0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=380&amp;h=151&amp;s=9777&amp;e=png&amp;b=1e1e1e" alt=""></p><ol start="2"><li><strong>类型注解只在编译阶段起作用，并不会影响运行时的行为。</strong> 在编译后的 JavaScript 代码中，类型注解会被编译器忽略。</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2794a8f3f63423b91e522aa9bd59818~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=502&amp;h=159&amp;s=10478&amp;e=png&amp;b=fefefe" alt=""></p><h2 id="四、typescript-类型" tabindex="-1">四、TypeScript 类型 <a class="header-anchor" href="#四、typescript-类型" aria-label="Permalink to &quot;四、TypeScript 类型&quot;">​</a></h2><h2 id="_1-ts-中常用的基础类型" tabindex="-1">1. TS 中常用的基础类型 <a class="header-anchor" href="#_1-ts-中常用的基础类型" aria-label="Permalink to &quot;1\. TS 中常用的基础类型&quot;">​</a></h2><p>我们可以将 TS 中常用的基础类型分为两类：</p><ol><li>JS 已有的类型</li><li>TS 新增的类型</li></ol><p>JS 已有的类型，我们又可以分为两类：</p><ol><li>原始数据类型：<strong>number、string、boolean、null、undefined、symbol（ES6 中的新类型）、bigint（ES10 中的新类型）。</strong></li><li>对象类型：<strong>object（包括数组、对象、函数等对象）。</strong></li></ol><p>TS 新增的类型：<strong>any、void、自定义类型（类型别名）、联合类型、接口、元组、字面量类型、枚举等。</strong></p><h3 id="_1-1-数值-number" tabindex="-1">1.1. 数值（number） <a class="header-anchor" href="#_1-1-数值-number" aria-label="Permalink to &quot;1.1. 数值（number）&quot;">​</a></h3><p>和 JS 一样，TS 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TS 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。</p><p>在 TS 中，使用 <strong>number</strong> ****来定义数值类型：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 十进制</span></span>
<span class="line"><span>let decLiteral: number = 6</span></span>
<span class="line"><span>// 十六进制</span></span>
<span class="line"><span>let hexLiteral: number = 0xf00d</span></span>
<span class="line"><span>// 二进制</span></span>
<span class="line"><span>let binaryLiteral: number = 0b1010</span></span>
<span class="line"><span>// 八进制</span></span>
<span class="line"><span>let octalLiteral: number = 0o744</span></span>
<span class="line"><span>let notANumber: number = NaN</span></span>
<span class="line"><span>let infinityNumber: number = Infinity</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>编译结果：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 十进制</span></span>
<span class="line"><span>var decLiteral = 6;</span></span>
<span class="line"><span>// 十六进制</span></span>
<span class="line"><span>var hexLiteral = 0xf00d;</span></span>
<span class="line"><span>// 二进制</span></span>
<span class="line"><span>var binaryLiteral = 10;</span></span>
<span class="line"><span>// 八进制</span></span>
<span class="line"><span>var octalLiteral = 484;</span></span>
<span class="line"><span>var notANumber = NaN;</span></span>
<span class="line"><span>var infinityNumber = Infinity;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_1-2-布尔值-boolean" tabindex="-1">1.2. 布尔值（boolean） <a class="header-anchor" href="#_1-2-布尔值-boolean" aria-label="Permalink to &quot;1.2. 布尔值（boolean）&quot;">​</a></h3><p>在 TS 中，使用 <strong>boolean</strong> 来定义布尔值类型：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let flag: boolean = false;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>编译结果：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var flag = false;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="_1-3-字符串-string" tabindex="-1">1.3. 字符串（string） <a class="header-anchor" href="#_1-3-字符串-string" aria-label="Permalink to &quot;1.3. 字符串（string）&quot;">​</a></h3><p>在 TS 中，使用 <strong>string</strong> 来定义字符串类型：</p><p>在 TS 中，字符串的表现形式主要有以下三种方式：</p><ol><li>使用单引号（ <strong>&#39;</strong> ）</li><li>使用双引号（ <strong>&quot;</strong> ）</li><li>使用模板字符串，它可以定义多行文本和内嵌表达式。这种字符串是被反引号包围（ <strong>`</strong> ），并且以 <strong>${ expr }</strong> 这种形式嵌入表达式</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let myName: string = &quot;Echo&quot;</span></span>
<span class="line"><span>let age: number = 25</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 模板字符串</span></span>
<span class="line"><span>let sentence: string = `Hello, my name is ${ myName }. I&#39;ll be ${ age + 1} years old next month.`</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 上面定义的sentence的语句与下面定义的sentence1语句的效果相同</span></span>
<span class="line"><span>let sentence1: string = &quot;Hello, my name is &quot; + myName + &quot;. I&#39;ll be &quot; + ( age + 1) +&quot; years old next month.&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>编译结果：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var myName = &quot;Echo&quot;;</span></span>
<span class="line"><span>var age = 25;</span></span>
<span class="line"><span>// 模板字符串</span></span>
<span class="line"><span>var sentence = &quot;Hello, my name is &quot;.concat(myName, &quot;. I&#39;ll be &quot;).concat(age + 1, &quot; years old next month.&quot;);</span></span>
<span class="line"><span>// 上面定义的sentence的语句与下面定义的sentence1语句的效果相同</span></span>
<span class="line"><span>var sentence1 = &quot;Hello, my name is &quot; + myName + &quot;. I&#39;ll be &quot; + (age + 1) + &quot; years old next month.&quot;;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_1-4-null-和-undefined" tabindex="-1">1.4. null 和 undefined <a class="header-anchor" href="#_1-4-null-和-undefined" aria-label="Permalink to &quot;1.4. null 和 undefined&quot;">​</a></h3><p>null 和 undefined 是所有类型的子类型，默认情况下，可以把 null 和 undefined 赋值给其他类型。</p><p>注意：如果你将 tsconfig.json 文件中的 <strong>strictNullChecks</strong> 选项设置为 <strong>false</strong>，下面这种操作不会报错，不过尽量不要这么做。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 将 null 和 undefined 赋值给 string 类型</span></span>
<span class="line"><span>let str: string = &quot;哈哈哈&quot;</span></span>
<span class="line"><span>str = null</span></span>
<span class="line"><span>str = undefined</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 将 null 和 undefined 赋值给 number 类型</span></span>
<span class="line"><span>let num: number = 123</span></span>
<span class="line"><span>num = null</span></span>
<span class="line"><span>num = undefined</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 将 null 和 undefined 赋值给 object 类型</span></span>
<span class="line"><span>let obj: object = {}</span></span>
<span class="line"><span>obj = null</span></span>
<span class="line"><span>obj = undefined</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 将 null 和 undefined 赋值给 boolean 类型</span></span>
<span class="line"><span>let flag: boolean = false</span></span>
<span class="line"><span>flag = null</span></span>
<span class="line"><span>flag = undefined</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 将 null 和 undefined 赋值给 symbol 类型</span></span>
<span class="line"><span>let sym: symbol = Symbol(&quot;abc&quot;)</span></span>
<span class="line"><span>sym = null</span></span>
<span class="line"><span>sym = undefined</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 将 null 和 undefined 赋值给 bigint 类型</span></span>
<span class="line"><span>let big: bigint =  10n;</span></span>
<span class="line"><span>big = null</span></span>
<span class="line"><span>big = undefined</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>编译结果：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 将 null 和 undefined 赋值给 string 类型</span></span>
<span class="line"><span>var str = &quot;哈哈哈&quot;;</span></span>
<span class="line"><span>str = null;</span></span>
<span class="line"><span>str = undefined;</span></span>
<span class="line"><span>// 将 null 和 undefined 赋值给 number 类型</span></span>
<span class="line"><span>var num = 123;</span></span>
<span class="line"><span>num = null;</span></span>
<span class="line"><span>num = undefined;</span></span>
<span class="line"><span>// 将 null 和 undefined 赋值给 object 类型</span></span>
<span class="line"><span>var obj = {};</span></span>
<span class="line"><span>obj = null;</span></span>
<span class="line"><span>obj = undefined;</span></span>
<span class="line"><span>// 将 null 和 undefined 赋值给 boolean 类型</span></span>
<span class="line"><span>var flag = false;</span></span>
<span class="line"><span>flag = null;</span></span>
<span class="line"><span>flag = undefined;</span></span>
<span class="line"><span>// 将 null 和 undefined 赋值给 symbol 类型</span></span>
<span class="line"><span>var sym = Symbol(&quot;abc&quot;);</span></span>
<span class="line"><span>sym = null;</span></span>
<span class="line"><span>sym = undefined;</span></span>
<span class="line"><span>// 将 null 和 undefined 赋值给 bigint 类型</span></span>
<span class="line"><span>var big = 10n;</span></span>
<span class="line"><span>big = null;</span></span>
<span class="line"><span>big = undefined;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>注意：如果你在 <strong>tsconfig.json</strong> 文件中指定了“<strong>strictNullChecks：true</strong>”，null 和 undefined 只能赋值给 <strong>void</strong> 和它们各自的类型。</p><p>下面这种情况会报错：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ae0c0b62a304ee7b88e6093db1e8ac5~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=373&amp;h=156&amp;s=11650&amp;e=png&amp;b=1f1f1f" alt=""></p><h3 id="_1-5-symbol" tabindex="-1">1.5. symbol <a class="header-anchor" href="#_1-5-symbol" aria-label="Permalink to &quot;1.5. symbol&quot;">​</a></h3><p><strong>symbol</strong> 是 ES6 新增的一种基本数据类型，<strong>Symbol()函数</strong> 会返回 <strong>symbol</strong> 类型的值，<strong>每个从 Symbol()函数 返回的 symbol 的值都是唯一的。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const sym1: symbol = Symbol()</span></span>
<span class="line"><span>const sym2: symbol = Symbol(&#39;temp&#39;)</span></span>
<span class="line"><span>const sym3: symbol = Symbol(&#39;temp&#39;)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面的代码创建了三个新的 symbol 类型，但是注意的是，每个从 Symbol()函数 返回的值都是唯一的。</p><p>此时，如果我们在控制台打印下面的代码，两者并不相等。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>console.log(sym2 === sym3) // false</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="_1-6-bigint" tabindex="-1">1.6. bigint <a class="header-anchor" href="#_1-6-bigint" aria-label="Permalink to &quot;1.6. bigint&quot;">​</a></h3><p><strong>bigint</strong> 是 ES10 新增的一种基本数据类型，在 JS 中，可以用 Number 表示的最大整数为 2^53 - 1，可以写为 Number.MAX_SAFE_INTEGER。如果超过了这个界限，那么就可以用 BigInt 来表示，它可以表示任意大的整数。</p><p>在一个整数字面量后面加 n 的方式定义一个 bigint，或者调用函数 BigInt()。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let big1: bigint = 10n</span></span>
<span class="line"><span>let big2: bigint = BigInt(10)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(big1 === big2) // true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_1-7-区别" tabindex="-1">1.7. 区别 <a class="header-anchor" href="#_1-7-区别" aria-label="Permalink to &quot;1.7. 区别&quot;">​</a></h3><h4 id="_1-7-1-null-和-undefined-的区别" tabindex="-1">1.7.1. null 和 undefined 的区别 <a class="header-anchor" href="#_1-7-1-null-和-undefined-的区别" aria-label="Permalink to &quot;1.7.1. null 和 undefined 的区别&quot;">​</a></h4><ol><li>在 JS 中，null 表示“什么都没有”，而 undefined 是一个没有设置值的变量</li><li>用 typeof 检测 null，返回 object；typeof 一个没有值的变量会返回 undefined</li><li>null 是一个只有一个值的特殊类型，表示一个空对象的引用</li><li>null 和 undefined 是其它任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。而在 TS 中启用严格的空校验（strictNullChecks）特性，就可以使得 null 和 undefined 只能被赋值给 void 或本身对应的类型</li></ol><h4 id="_1-7-2-bigint-和-number-的区别" tabindex="-1">1.7.2. bigint 和 number 的区别 <a class="header-anchor" href="#_1-7-2-bigint-和-number-的区别" aria-label="Permalink to &quot;1.7.2. bigint 和 number 的区别&quot;">​</a></h4><ol><li>number 和 bigint 都可以表示数字，但是两者不能进行相互转换</li><li>仅在值大于 2^53 - 1 时，才使用 bigint，否则尽量使用 number</li><li>用 typeof 检测 bigint 对象时，返回 bigint，用 typeof 检测 number，返回 number</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>console.log(typeof 10) // number</span></span>
<span class="line"><span>console.log(typeof Number(10)) // number</span></span>
<span class="line"><span>console.log(typeof 10n) // bigint</span></span>
<span class="line"><span>console.log(typeof BigInt(10)) // bigint</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_1-8-对象类型" tabindex="-1">1.8. 对象类型 <a class="header-anchor" href="#_1-8-对象类型" aria-label="Permalink to &quot;1.8. 对象类型&quot;">​</a></h3><h4 id="_1-8-1-数组-array-类型" tabindex="-1">1.8.1. 数组（Array）类型 <a class="header-anchor" href="#_1-8-1-数组-array-类型" aria-label="Permalink to &quot;1.8.1. 数组（Array）类型&quot;">​</a></h4><p>数组类型的写法有两种：</p><ol><li>在类型后面加上 []，例如 <strong>number[]</strong></li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let num: number[] = [1, 2, 3, 4]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="2"><li>使用数组泛型 &lt;&gt;，例如 <strong>Array</strong></li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let num: Array&lt;number&gt; = [1, 2, 3, 4]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>推荐使用第一种写法。</p><p><strong>注意：</strong></p><ol><li>如果我们定义了一个 number 类型的数组，此时数组的项中就不能出现其它的类型。</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7b1e6f9132f4decb81fb1b892286ddd~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=599&amp;h=142&amp;s=9115&amp;e=png&amp;b=1f1f1f" alt=""></p><ol start="2"><li>如果我们希望数组中既有 number 类型，又有 string 类型，此时我们可以用联合类型来写（关于联合类型，后面会详细讲到）。</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let arr: (number | string)[] = [1, &#39;a&#39;, 2, &#39;b&#39;]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上面的代码，表示的是，定义一个 arr 数组，这个数组中可以出现 number 或者 string 类型的元素。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let arr1: number | string[] = 123</span></span>
<span class="line"><span>let arr2: number | string[] = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面的代码，arr1 和 arr2 都表示即可以是 number 类型，又可以是 string[]，加了小括号和不加小括号，含义不同。</p><h4 id="_1-8-2-函数类型" tabindex="-1">1.8.2. 函数类型 <a class="header-anchor" href="#_1-8-2-函数类型" aria-label="Permalink to &quot;1.8.2. 函数类型&quot;">​</a></h4><p>函数类型实际上指的是：<strong>函数参数和返回值的类型</strong>。</p><p>为函数指定类型的两种方式：</p><ol><li>单独指定参数、返回值的类型</li><li>同时指定参数、返回值的类型</li></ol><p>在 JS 中，有两种常见的定义函数的方式：</p><ol><li>函数声明</li><li>函数表达式</li></ol><h5 id="_1-8-2-1-单独指定参数、返回值的类型" tabindex="-1">1.8.2.1. 单独指定参数、返回值的类型 <a class="header-anchor" href="#_1-8-2-1-单独指定参数、返回值的类型" aria-label="Permalink to &quot;1.8.2.1. 单独指定参数、返回值的类型&quot;">​</a></h5><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 函数声明写法</span></span>
<span class="line"><span>function sum(num1: number, num2: number): number {</span></span>
<span class="line"><span>  return num1 + num2</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>// 函数表达式写法</span></span>
<span class="line"><span>const sum1 = (num1: number, num2: number): number =&gt; {</span></span>
<span class="line"><span>  return num1 + num2</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(sum(10, 20))  // 30</span></span>
<span class="line"><span>console.log(sum1(10, 20)) // 30</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h5 id="_1-8-2-2-同时指定参数、返回值的类型" tabindex="-1">1.8.2.2. 同时指定参数、返回值的类型 <a class="header-anchor" href="#_1-8-2-2-同时指定参数、返回值的类型" aria-label="Permalink to &quot;1.8.2.2. 同时指定参数、返回值的类型&quot;">​</a></h5><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const sum: (num1: number, num2: number) =&gt; number = (num1, num2) =&gt; {</span></span>
<span class="line"><span>  return num1 + num2</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(sum(10, 20)) // 30</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>注意：不要把 ES6 中的 =&gt; 和 TypeScript 中的 =&gt;混淆了。</p><p>在 ES6 中，=&gt;叫做箭头函数。而在 TypeScript 的类型定义中，=&gt;用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p><h5 id="_1-8-2-3-函数没有返回值" tabindex="-1">1.8.2.3. 函数没有返回值 <a class="header-anchor" href="#_1-8-2-3-函数没有返回值" aria-label="Permalink to &quot;1.8.2.3. 函数没有返回值&quot;">​</a></h5><p>如果函数没有返回值，那么，函数返回值类型为：<strong>void</strong>。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function greet(name: string): void {</span></span>
<span class="line"><span>  console.log(&quot;Hello, &quot;, name);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>greet(&quot;Echo&quot;)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h5 id="_1-8-2-4-可选参数" tabindex="-1">1.8.2.4. 可选参数 <a class="header-anchor" href="#_1-8-2-4-可选参数" aria-label="Permalink to &quot;1.8.2.4. 可选参数&quot;">​</a></h5><p>使用函数实现某个功能时，参数可以传也可以不传，这种情况下，在给函数参数指定类型时，就用到<strong>可选参数</strong>了。</p><p>可选参数使用问号（ <strong>?</strong> ）标记，表示该参数可以省略。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function greet(name: string, greeting?: string): string {</span></span>
<span class="line"><span>  if (greeting) {</span></span>
<span class="line"><span>    return `${greeting}, ${name}!`;</span></span>
<span class="line"><span>  } else {</span></span>
<span class="line"><span>    return `Hello, ${name}!`;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(greet(&quot;Echo&quot;)) // &quot;Hello, Echo!&quot;</span></span>
<span class="line"><span>console.log(greet(&quot;Echo&quot;, &quot;Hi&quot;)) // &quot;Hi, Echo!&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>上面的代码中，我们在第二个参数 greeting 的后面加了个问号，表示在调用 greet() 函数时，该参数可传可不传。</p><p>注意：<strong>可选参数只能出现在参数列表的最后面，也就是说，可选参数后面不能再出现必选参数。</strong></p><p>错误演示：下面代码中，我们把第一个参数改为可选的，第二个参数改为必选的，然后将鼠标移到必选参数上面，可以看到错误提示：“必选参数不能位于可选参数后”。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf25c8ffbc2148b0b560ce384fce1db6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=832&amp;h=336&amp;s=79655&amp;e=png&amp;b=1e1e1e" alt=""></p><h5 id="_1-8-2-5-参数默认值" tabindex="-1">1.8.2.5. 参数默认值 <a class="header-anchor" href="#_1-8-2-5-参数默认值" aria-label="Permalink to &quot;1.8.2.5. 参数默认值&quot;">​</a></h5><p>在 ES6 中，允许给函数的参数添加默认值，而 TypeScript 会将添加了默认值的参数识别为可选参数。</p><p>默认参数使用等号（<strong>=</strong>）赋予默认值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function buildName(firstName: string, lastName: string = &#39;Cat&#39;) {</span></span>
<span class="line"><span>    return firstName + &#39; &#39; + lastName;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(buildName(&#39;Tom&#39;, &#39;Cat&#39;)) // Tom Cat</span></span>
<span class="line"><span>console.log(buildName(&#39;Tom&#39;)) // Tom Cat</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>注意：与可选参数不同的是，<strong>带默认值的参数不需要放在必选参数的后面</strong>。如果带默认值的参数出现在必选参数的前面，我们在调用函数时，必须明确的传入 <strong>undefined</strong> 值来获得默认值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function buildName(firstName = &quot;Echo&quot;, lastName: string) {</span></span>
<span class="line"><span>    return firstName + &quot; &quot; + lastName;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(buildName(&quot;james&quot;))           // 报错，未提供“lastName”自变量</span></span>
<span class="line"><span>console.log(buildName(&quot;Jerk&quot;, &quot;Lose&quot;))    // Jerk Lose</span></span>
<span class="line"><span>console.log(buildName(undefined, &quot;Deno&quot;)) // Echo Deno</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h5 id="_1-8-2-6-剩余参数" tabindex="-1">1.8.2.6. 剩余参数 <a class="header-anchor" href="#_1-8-2-6-剩余参数" aria-label="Permalink to &quot;1.8.2.6. 剩余参数&quot;">​</a></h5><p>使用三个点（ <strong>...</strong> ）前缀和参数名来定义剩余参数。</p><p>剩余参数允许我们将不确定数量的参数表示为一个数组。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function sum(x: number, ...rest: number[]): number {</span></span>
<span class="line"><span>  let result = x;</span></span>
<span class="line"><span>  for (let num of rest) {</span></span>
<span class="line"><span>    result += num;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(sum(1, 2, 3, 4, 5)) // 15</span></span>
<span class="line"><span>console.log(sum(1, 2, 3))       // 6</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>注意：<strong>剩余参数必须是函数参数列表中的最后一个参数</strong>。</p><h5 id="_1-8-2-7-函数重载" tabindex="-1">1.8.2.7. 函数重载 <a class="header-anchor" href="#_1-8-2-7-函数重载" aria-label="Permalink to &quot;1.8.2.7. 函数重载&quot;">​</a></h5><p>函数重载允许我们为同一个函数提供多个函数类型定义，以便在不同的参数类型或返回值类型下进行不同的处理。</p><p>例如，我们现在需要实现一个函数，需求是：输入数字 123，输出反转的数字 321，输入字符串&quot;hello&quot;，输出反转的字符串&quot;olleh&quot;。</p><p>利用联合类型，我们可以这么实现：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function reverse(x: number | string): number | string {</span></span>
<span class="line"><span>  if (typeof x === &#39;number&#39;) {</span></span>
<span class="line"><span>    return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));</span></span>
<span class="line"><span>  } else if (typeof x === &#39;string&#39;) {</span></span>
<span class="line"><span>    return x.split(&#39;&#39;).reverse().join(&#39;&#39;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(reverse(123))     // 321</span></span>
<span class="line"><span>console.log(reverse(&quot;hello&quot;)) // olleh</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>然后这样会有一个问题，就是输出的类型不能准确的知道，我们想输入为数字的时候，输出的类型应该也为数值类型，输入为字符串的时候，输出类型应该也为字符串类型。</p><p>这时，我们可以用<strong>重载</strong>定义多个 reserve 的函数类型：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function reverse(x: number): number;</span></span>
<span class="line"><span>function reverse(x: string): string;</span></span>
<span class="line"><span>function reverse(x: number | string): number | string {</span></span>
<span class="line"><span>  if (typeof x === &#39;number&#39;) {</span></span>
<span class="line"><span>    return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));</span></span>
<span class="line"><span>  } else if (typeof x === &#39;string&#39;) {</span></span>
<span class="line"><span>    return x.split(&#39;&#39;).reverse().join(&#39;&#39;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(reverse(123), typeof reverse(123))     // 321 number</span></span>
<span class="line"><span>console.log(reverse(&quot;hello&quot;), typeof reverse(&quot;hello&quot;)) // olleh string</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>上述代码中，第 1-2 行是函数定义，第 3-9 行是函数实现。第 11 行代码，我们调用 reverse 函数，并传入数值 123，使用 typeof 检测类型为 number，第 12 行代码，我们调用 reverse 函数，并传入字符串&quot;hello&quot;，使用 typeof 检测类型为 string，这样我们利用函数重载就实现了输入为什么类型，输出应该也是什么类型。</p><h4 id="_1-8-3-对象类型" tabindex="-1">1.8.3. 对象类型 <a class="header-anchor" href="#_1-8-3-对象类型" aria-label="Permalink to &quot;1.8.3. 对象类型&quot;">​</a></h4><p>JS 中的对象是由属性和方法构成的，而 TS 中对象的类型就是在描述对象的结构（有什么类型的属性和方法）。</p><h5 id="_1-8-3-1-定义对象类型" tabindex="-1">1.8.3.1. 定义对象类型 <a class="header-anchor" href="#_1-8-3-1-定义对象类型" aria-label="Permalink to &quot;1.8.3.1. 定义对象类型&quot;">​</a></h5><ul><li>使用花括号（ <strong>{}</strong> ）来定义对象类型，属性采用 <strong>属性名: 类型</strong> 的形式；方法采用 <strong>方法名(): 返回值类型</strong> 的形式。</li><li>如果方法有参数，就在方法名后面的小括号中指定参数类型（比如：greet(name: string): void）。</li><li>在一行代码中指定对象的多个属性类型时，使用分号（ <strong>;</strong> ）来分隔。</li><li>如果一行代码只指定一个属性类型（通过换行来分隔多个属性类型），可以去掉分号（ <strong>;</strong> ）。</li><li>方法的类型也可以使用箭头函数形式，比如：{ sayHi: () =&gt; void }。</li></ul><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let person: { name: string; age: number; sayHi(): void; greet(name: string): void } = {</span></span>
<span class="line"><span>  name: &#39;John&#39;,</span></span>
<span class="line"><span>  age: 25,</span></span>
<span class="line"><span>  sayHi() {},</span></span>
<span class="line"><span>  greet(name) {}</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>上面的代码，也可以写成下面这种形式：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let person: {</span></span>
<span class="line"><span>  name: string</span></span>
<span class="line"><span>  age: number</span></span>
<span class="line"><span>  // sayHi(): void</span></span>
<span class="line"><span>  sayHi: () =&gt; void</span></span>
<span class="line"><span>// greet(name: string): void</span></span>
<span class="line"><span>  greet: (name: string) =&gt; void</span></span>
<span class="line"><span>} = {</span></span>
<span class="line"><span>  name: &#39;John&#39;,</span></span>
<span class="line"><span>  age: 25,</span></span>
<span class="line"><span>  sayHi() {},</span></span>
<span class="line"><span>  greet(name) {}</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h5 id="_1-8-3-2-对象可选属性" tabindex="-1">1.8.3.2. 对象可选属性 <a class="header-anchor" href="#_1-8-3-2-对象可选属性" aria-label="Permalink to &quot;1.8.3.2. 对象可选属性&quot;">​</a></h5><p>对象类型中的属性或方法可以是可选的，使用问号（ <strong>?</strong> ）标记。</p><p>可选属性表示该属性可以存在，也可以不存在。</p><p>比如，我们在使用 axios({...})时，如果发送 GET 请求，method 属性就可以省略。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function myAxios(config: { url: string; method?: string}) {</span></span>
<span class="line"><span>  console.log(config)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>myAxios({ url: &#39;http://localhost:3000&#39; })</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h5 id="_1-8-3-3-对象只读属性" tabindex="-1">1.8.3.3. 对象只读属性 <a class="header-anchor" href="#_1-8-3-3-对象只读属性" aria-label="Permalink to &quot;1.8.3.3. 对象只读属性&quot;">​</a></h5><p>对象的属性也可以是只读的，使用 <strong>readonly</strong> 关键字标记。</p><p>只读属性表示该属性的值在创建后就不能被修改。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let person: {</span></span>
<span class="line"><span>  name: string</span></span>
<span class="line"><span>  age: number</span></span>
<span class="line"><span>readonly id: number</span></span>
<span class="line"><span>} = {</span></span>
<span class="line"><span>  name: &#39;John&#39;,</span></span>
<span class="line"><span>  age: 25,</span></span>
<span class="line"><span>id: 1</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_2-元组-tuple" tabindex="-1">2. 元组（Tuple） <a class="header-anchor" href="#_2-元组-tuple" aria-label="Permalink to &quot;2\. 元组（Tuple）&quot;">​</a></h2><h3 id="_2-1-元组的定义" tabindex="-1">2.1. 元组的定义 <a class="header-anchor" href="#_2-1-元组的定义" aria-label="Permalink to &quot;2.1. 元组的定义&quot;">​</a></h3><p>在 TypeScript 中，<strong>元组（Tuple）是一种特殊的数组类型，它允许</strong> <strong>存储具有固定数量和特定类型顺序的元素。</strong></p><p>声明一个元组的语法是在类型注解中使用方括号 <strong>[]</strong> ，并使用逗号分隔元素的类型。</p><p>例如，下面是一个包含两个元素的元组：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let tuple: [string, number];</span></span>
<span class="line"><span>tuple = [&quot;Echo&quot;, 26];</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在上述示例中，我们声明了一个名为 tuple 的变量，它被注解为一个元组类型 [string, number]。我们可以将一个包含两个元素的数组赋值给 tuple，其中第一个元素是一个字符串，第二个元素是一个数字。</p><h3 id="_2-2-元组的特点" tabindex="-1">2.2. 元组的特点 <a class="header-anchor" href="#_2-2-元组的特点" aria-label="Permalink to &quot;2.2. 元组的特点&quot;">​</a></h3><ol><li>元组可以包含多个不同类型的元素，但每个元素的类型和顺序是固定的。</li><li>元组的长度是固定的，在创建元组时必须指定元素的数量。</li><li>可以通过索引访问元组中的元素，索引从 0 开始。</li><li>元组中的每个元素可以具有不同的类型注解。</li><li>当访问元组中的元素时，会根据其类型注解提供相关的类型检查和智能提示。</li></ol><p>下面是一些操作元组的示例：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 声明一个 tuple 变量，它的类型注解为：[string, number, boolean]，然后把一个包含3个元素的数组赋值给 tuple，其中，数组的第一个元素为字符串类型，第二个元素为数值类型，第三个元素为布尔值类型</span></span>
<span class="line"><span>let tuple: [string, number, boolean] = [&quot;Echo&quot;, 26, true];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 通过索引访问元组中的元素，索引从 0 开始</span></span>
<span class="line"><span>console.log(tuple[0]); // 输出：Echo</span></span>
<span class="line"><span>console.log(tuple[1]); // 输出：26</span></span>
<span class="line"><span>console.log(tuple[2]); // 输出：true</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 可以通过索引重新赋值，赋值的类型需要跟类型注解中的固定位置的类型一样</span></span>
<span class="line"><span>tuple[0] = &quot;june&quot;;</span></span>
<span class="line"><span>tuple[1] = 28;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(tuple); // 输出：[&quot;june&quot;, 28, true]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 下面的代码会报错：不能将类型 &quot;[string, number, boolean, string]&quot; 分配给类型 &quot;[string, number, boolean]&quot;，源具有 4 个元素，但目标仅允许3个</span></span>
<span class="line"><span>tuple = [&quot;Echo&quot;, 26, true, &quot;hhhh&quot;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 下面的代码也会报错，因为元组的第一个元素类型要求为字符串类型，不能将 number 类型分配给 string 类型。</span></span>
<span class="line"><span>tuple = [1, 28, true]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>注意：<strong>当访问元组中的元素以及进行元素的赋值时，要确保索引和类型注解的一致性，否则可能会导致类型错误。</strong></p><h3 id="_2-3-元组类型的解构赋值" tabindex="-1">2.3. 元组类型的解构赋值 <a class="header-anchor" href="#_2-3-元组类型的解构赋值" aria-label="Permalink to &quot;2.3. 元组类型的解构赋值&quot;">​</a></h3><p>在 TypeScript 中，可以使用解构赋值语法来从元组中提取和赋值元素。</p><p>下面是一个简单的示例，展示了如何使用解构赋值从元组中获取各个元素：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let tuple: [string, number] = [&quot;Echo&quot;, 26];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let [str, num] = tuple;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(str); // 输出：Echo</span></span>
<span class="line"><span>console.log(num); // 输出：26</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在上述示例中，我们首先声明了一个元组 tuple，其中包含一个字符串类型的元素和一个数值类型的元素。接着，我们使用解构赋值语法将元组中的元素分别赋值给变量 str 和 num。</p><p>通过解构赋值，我们可以直接使用对应位置的变量来获取元组中的元素值，而不需要通过索引访问。这样可以以一种简洁、语义明确的方式从元组中解构得到各个元素。</p><p><strong>解构赋值还支持忽略某些元素，或者只提取部分元素。</strong></p><p>例如，如果只想获取元组中的第一个元素，可以使用以下方式：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let tuple: [string, number] = [&quot;Echo&quot;, 26];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let [str] = tuple;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(str); // 输出：Echo</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在上述示例中，我们只声明了一个变量 str，而忽略了后面的元素。通过解构赋值只获取所需元素，可以简化代码并提高可读性。</p><p>另外，<strong>解构赋值还支持使用默认值。</strong></p><p>当从元组中解构一个不存在的元素时，可以提供一个默认值作为备选值。例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let tuple: [string, number?] = [&quot;Echo&quot;];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let [str, num = 26] = tuple;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(str); // 输出：Echo</span></span>
<span class="line"><span>console.log(num); // 输出：26</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在上述示例中，我们声明了一个带有可选的数字元素的元组 tuple，但是没有给出对应的数字值。在解构赋值时，如果元组中缺少对应的元素，就会使用默认值 undefined，这里我们将默认值设置为 26。</p><p>总而言之，使用解构赋值可以轻松地从元组中提取和赋值元素，使得代码更加简洁和可读。它是一种方便的语法，特别适用于处理具有固定结构的数据。</p><p>注意：<strong>在解构赋值时，如果解构数组元素的个数超过元组中元素的个数，会出现错误。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let tuple: [string, number] = [&quot;Echo&quot;, 26];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let [str, num, sex] = tuple;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上述示例中，我们解构时新增了一个 sex 变量，但元组的长度为 2，在索引 &quot;2&quot; 处没有元素。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0765393931a14756a38e983cff79c316~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1070&amp;h=254&amp;s=50285&amp;e=png&amp;b=1f1f1f" alt=""></p><h3 id="_2-4-元组类型的可选元素" tabindex="-1">2.4. 元组类型的可选元素 <a class="header-anchor" href="#_2-4-元组类型的可选元素" aria-label="Permalink to &quot;2.4. 元组类型的可选元素&quot;">​</a></h3><p>在 TypeScript 中，可以使用问号 <strong>?</strong> 来将元素定义为可选的，以表示元组中某些位置的元素是可选的。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let tuple: [string, number?] = [&quot;Echo&quot;];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(tuple);   // 输出 [ &#39;Echo&#39;, undefined ]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>tuple = [&quot;june&quot;, 26];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(tuple);  // 输出 [ &#39;june&#39;, 26 ]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在上述示例中，我们定义了一个元组 tuple，该元组有两个元素，第一个是一个字符串类型的元素，而第二个是一个可选的数值类型的元素。当我们只提供第一个元素时，第二个元素会被默认设置为 undefined。然后，我们更新了元组的值，提供了第二个元素的值。此时，元组中的两个元素都有具体的值。</p><p>注意，<strong>当一个元组中包含一个可选元素时，该元素可以存在或不存在，但是顺序必须与元组类型定义一致。在解构赋值时，可以使用默认值来处理可选元素的缺失情况。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let tuple: [string, number?] = [&quot;Echo&quot;];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let [str, num = 26] = tuple;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(str); // 输出：Echo</span></span>
<span class="line"><span>console.log(num); // 输出：26</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在上述示例中，我们使用解构赋值将元组中的元素分别赋值给变量 str 和 num。由于元组只提供了一个元素，没有提供可选的第二个元素，所以 num 的值将使用默认值 26。</p><p>通过使用可选元素，可以更灵活地定义元组类型，允许元组中特定位置的元素是可选的。这样，我们可以在处理数据时更好地适应不完整或可变的情况。</p><h3 id="_2-5-元组类型的剩余元素" tabindex="-1">2.5. 元组类型的剩余元素 <a class="header-anchor" href="#_2-5-元组类型的剩余元素" aria-label="Permalink to &quot;2.5. 元组类型的剩余元素&quot;">​</a></h3><p>在 TypeScript 中，可以使用剩余元素（Rest Elements）来表示元组中剩余的元素，即将剩余的元素放入一个数组中。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let tuple: [string, number, ...boolean[]] = [&quot;Echo&quot;, 26, true, true, false];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(tuple); // 输出：[ &#39;Echo&#39;, 26, true, true, false ]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上述示例中，我们定义了一个元组 tuple，包含一个字符串元素、一个数字元素，以及剩余元素使用剩余元素语法 <strong>...</strong> 定义的布尔类型数组。在创建元组时，我们提供了多个布尔类型的元素，它们会被放入一个数组并作为剩余元素。这样，元组中除了前两个元素以外的其他元素都会被放入数组中，并以数组的形式表示。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let tuple: [string, number, ...boolean[]] = [&quot;Echo&quot;, 26, true, true, false];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let [str, num, ...boolArr] = tuple;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(str);      // 输出：Echo</span></span>
<span class="line"><span>console.log(num);      // 输出：26</span></span>
<span class="line"><span>console.log(boolArr);  // 输出：[true, true, false]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在上述示例中，我们使用解构赋值从元组中提取出各个元素。通过使用 ...boolArr，我们将剩余的布尔类型元素提取到名为 boolArr 的数组中。</p><p>使用剩余元素可以处理元组中数量不确定的元素，可以更灵活地处理和操作这些元素。它提供了一种方便的方式来处理由不固定数量的元素组成的结构数据。</p><h3 id="_2-6-只读的元组类型" tabindex="-1">2.6. 只读的元组类型 <a class="header-anchor" href="#_2-6-只读的元组类型" aria-label="Permalink to &quot;2.6. 只读的元组类型&quot;">​</a></h3><p>在 TypeScript 中，可以使用 <strong>readonly</strong> 修饰符来创建只读的元组类型，即元组中的元素不可被修改。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let tuple: readonly [string, number] = [&quot;Echo&quot;, 26];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(tuple);    // 输出：[ &#39;Echo&#39;, 26 ]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>tuple[0] = &quot;world&quot;;    // 编译错误：无法为“0”赋值，因为它是只读属性</span></span>
<span class="line"><span>tuple.push(&#39;abc&#39;);     // 编译错误：类型 &quot;readonly [string, number]&quot; 上不存在 &quot;push&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在上述示例中，我们使用 readonly 修饰符将 tuple 声明为只读的元组类型。这意味着在运行时，我们无法修改元组中的元素的值。</p><p>尝试对 tuple 进行赋值或调用修改元素的方法（如 push）时，TypeScript 编译器会报错，因为元组被声明为只读，无法被修改。</p><p>只读的元组类型在某些场景下非常有用，特别是当希望确保元组中的数据不会被意外修改时。它提供了一种强制保护元组数据不可变性的机制。</p><h2 id="_3-字面量类型" tabindex="-1">3. 字面量类型 <a class="header-anchor" href="#_3-字面量类型" aria-label="Permalink to &quot;3\. 字面量类型&quot;">​</a></h2><p>当我们在 TypeScript 中使用字面量类型，我们可以明确指定变量只能取特定的字面量值，而不是其他可能性。这样可以在编译时捕获潜在的错误，并提供更好的类型推断和类型检查支持。</p><p>在 TypeScript 中，可以使用多种类型的字面量进行类型定义，包括字符串字面量类型、数字字面量类型、布尔字面量类型和符号字面量类型。</p><h3 id="_3-1-字符串字面量类型" tabindex="-1">3.1. 字符串字面量类型 <a class="header-anchor" href="#_3-1-字符串字面量类型" aria-label="Permalink to &quot;3.1. 字符串字面量类型&quot;">​</a></h3><p>使用字符串字面量表示的类型，只能取特定的字符串值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let direction: &quot;Up&quot; | &quot;Right&quot; | &quot;Down&quot; | &quot;Left&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>direction = &quot;Right&quot;;   // 合法</span></span>
<span class="line"><span>direction = &quot;none&quot;;    // 错误，只能取值为 &quot;Up&quot; | &quot;Right&quot; | &quot;Down&quot; | &quot;Left&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_3-2-数字字面量类型" tabindex="-1">3.2. 数字字面量类型 <a class="header-anchor" href="#_3-2-数字字面量类型" aria-label="Permalink to &quot;3.2. 数字字面量类型&quot;">​</a></h3><p>使用数字字面量表示的类型，只能取特定的数字值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let num: 1 | 2 | 3;</span></span>
<span class="line"><span>num = 2; // 合法</span></span>
<span class="line"><span>num = 4; // 错误，只能取值为 1、2 或 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_3-3-布尔字面量类型" tabindex="-1">3.3. 布尔字面量类型 <a class="header-anchor" href="#_3-3-布尔字面量类型" aria-label="Permalink to &quot;3.3. 布尔字面量类型&quot;">​</a></h3><p>使用布尔字面量表示的类型，只能取特定的布尔值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let isShow: true | false;</span></span>
<span class="line"><span>isShow = true;  // 合法</span></span>
<span class="line"><span>isShow = false; // 合法</span></span>
<span class="line"><span>isShow = 1;     // 错误，只能取值为 true 或 false</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_3-4-符号字面量类型" tabindex="-1">3.4. 符号字面量类型 <a class="header-anchor" href="#_3-4-符号字面量类型" aria-label="Permalink to &quot;3.4. 符号字面量类型&quot;">​</a></h3><p>使用符号字面量表示的类型，只能取特定的符号值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const apple: unique symbol = Symbol(&quot;apple&quot;);</span></span>
<span class="line"><span>const orange: unique symbol = Symbol(&quot;orange&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let fruit: typeof apple | typeof orange;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fruit = apple;           // 合法</span></span>
<span class="line"><span>fruit = orange;          // 合法</span></span>
<span class="line"><span>fruit = Symbol(&quot;apple&quot;); // 错误，只能取预定义的 apple 或 orange</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>字面量类型不仅可以用于变量的定义，还可以用于<strong>函数的参数、返回值、对象属性</strong>等地方。通过使用字面量类型，我们可以在编写代码时明确指定特定的取值范围，提高代码的可读性和可维护性。</p><p>需要注意的是，字面量类型具有一个特殊的用途，即与联合类型结合使用，以实现更精确的类型约束。例如，联合类型 string | number 表示可以是字符串或数字类型的值，而字面量类型 &quot;success&quot; | &quot;error&quot; 表示只能是字符串 &quot;success&quot; 或 &quot;error&quot;，它们可以一起使用来实现更精确的类型定义。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let result: &quot;success&quot; | &quot;error&quot; | number;</span></span>
<span class="line"><span>result = &quot;success&quot;; // 合法</span></span>
<span class="line"><span>result = 42;        // 合法</span></span>
<span class="line"><span>result = true;      // 错误，只能取值为 &quot;success&quot;、&quot;error&quot; 或 number 类型</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_3-5-函数参数中的字面量类型" tabindex="-1">3.5. 函数参数中的字面量类型 <a class="header-anchor" href="#_3-5-函数参数中的字面量类型" aria-label="Permalink to &quot;3.5. 函数参数中的字面量类型&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function move(direction: &quot;up&quot; | &quot;right&quot; | &quot;down&quot; | &quot;left&quot;): void {</span></span>
<span class="line"><span>  console.log(direction);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>move(&quot;up&quot;);    // 合法</span></span>
<span class="line"><span>move(&quot;left&quot;);  // 合法</span></span>
<span class="line"><span>move(10);      // 错误，只能取值为 &quot;up&quot; 或 &quot;right&quot; 或 &quot;down&quot; 或 &quot;left&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在上述示例中，函数 move 的参数 direction 的类型被指定为 &quot;up&quot; | &quot;right&quot; | &quot;down&quot; | &quot;left&quot;，这意味着参数 direction 只能接受这四个特定的值。</p><h3 id="_3-6-函数返回值中的字面量类型" tabindex="-1">3.6. 函数返回值中的字面量类型 <a class="header-anchor" href="#_3-6-函数返回值中的字面量类型" aria-label="Permalink to &quot;3.6. 函数返回值中的字面量类型&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function getMove(direction: string): &quot;up&quot; | &quot;right&quot; | &quot;down&quot; | &quot;left&quot; {</span></span>
<span class="line"><span>  if (direction === &#39;W&#39;) {</span></span>
<span class="line"><span>    return &quot;up&quot;;</span></span>
<span class="line"><span>  } else if (direction === &#39;D&#39;) {</span></span>
<span class="line"><span>    return &quot;right&quot;;</span></span>
<span class="line"><span>  } else if (direction === &#39;S&#39;) {</span></span>
<span class="line"><span>    return &quot;down&quot;;</span></span>
<span class="line"><span>  } else {</span></span>
<span class="line"><span>    return &quot;left&quot;;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上述示例中，函数 getMove 的返回值被指定为 &quot;up&quot; | &quot;right&quot; | &quot;down&quot; | &quot;left&quot;，这表示函数的返回值只能是这四个特定的值之一。</p><h3 id="_3-7-对象属性中的字面量类型" tabindex="-1">3.7. 对象属性中的字面量类型 <a class="header-anchor" href="#_3-7-对象属性中的字面量类型" aria-label="Permalink to &quot;3.7. 对象属性中的字面量类型&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Options {</span></span>
<span class="line"><span>  mode: &quot;light&quot; | &quot;dark&quot;;</span></span>
<span class="line"><span>  size: &quot;small&quot; | &quot;medium&quot; | &quot;large&quot;;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let config: Options = {</span></span>
<span class="line"><span>  mode: &quot;light&quot;,</span></span>
<span class="line"><span>  size: &quot;medium&quot;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在上述示例中，Options 接口中的 mode 属性的类型被指定为 &quot;light&quot; | &quot;dark&quot;，size 属性的类型被指定为 &quot;small&quot; | &quot;medium&quot; | &quot;large&quot;，这意味着对象 config 的 mode 属性只能是其中一个值，size 属性也只能是其中一个值。</p><h3 id="_3-8-let-和-const-分析" tabindex="-1">3.8. let 和 const 分析 <a class="header-anchor" href="#_3-8-let-和-const-分析" aria-label="Permalink to &quot;3.8. let 和 const 分析&quot;">​</a></h3><h4 id="_3-8-1-let-声明的字面量类型" tabindex="-1">3.8.1 let 声明的字面量类型 <a class="header-anchor" href="#_3-8-1-let-声明的字面量类型" aria-label="Permalink to &quot;3.8.1 let 声明的字面量类型&quot;">​</a></h4><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let direction: &quot;Up&quot; | &quot;Right&quot; | &quot;Down&quot; | &quot;Left&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>direction = &quot;Right&quot;;   // 合法</span></span>
<span class="line"><span>direction = &quot;none&quot;;    // 错误，只能取值为 &quot;Up&quot; | &quot;Right&quot; | &quot;Down&quot; | &quot;Left&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在上述示例中，我们使用 let 关键字声明了变量 direction，并将其类型指定为 &quot;Up&quot; | &quot;Right&quot; | &quot;Down&quot; | &quot;Left&quot;，因此 direction 只能取值为 &quot;Up&quot; 或 &quot;Right&quot; 或 &quot;Down&quot; 或 &quot;Left&quot; 这四个特定值中的其中一个。</p><h4 id="_3-8-2-const-声明的字面量类型" tabindex="-1">3.8.2 const 声明的字面量类型 <a class="header-anchor" href="#_3-8-2-const-声明的字面量类型" aria-label="Permalink to &quot;3.8.2 const 声明的字面量类型&quot;">​</a></h4><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const size: &quot;small&quot; | &quot;medium&quot; | &quot;large&quot; = &quot;medium&quot;;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在上述示例中，我们使用 const 关键字声明了常量 size，并将其类型指定为 &quot;small&quot; | &quot;medium&quot; | &quot;large&quot;。由于使用了 const，size 是一个只读的常量，且初始值为 &quot;medium&quot;。因此，size 的值将永远是 &quot;medium&quot;，不能被重新赋值。</p><p>使用 let 和 const 关键字来声明变量和常量时，可以配合字面量类型提供更具体和可靠的类型约束。</p><p>注意：<strong>const 声明的常量在声明时必须被初始化，并且一旦初始化后，其值将不能被修改。而 let 声明的变量可以在后续代码中被重新赋值。</strong></p><h2 id="_4-枚举-enum" tabindex="-1">4. 枚举（Enum） <a class="header-anchor" href="#_4-枚举-enum" aria-label="Permalink to &quot;4\. 枚举（Enum）&quot;">​</a></h2><p>枚举（Enum）是一种用于定义一组命名常量的数据结构。</p><h3 id="_4-1-基本枚举" tabindex="-1">4.1. 基本枚举 <a class="header-anchor" href="#_4-1-基本枚举" aria-label="Permalink to &quot;4.1. 基本枚举&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>enum Direction {</span></span>
<span class="line"><span>  Up,</span></span>
<span class="line"><span>  Down,</span></span>
<span class="line"><span>  Left,</span></span>
<span class="line"><span>  Right</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let dir: Direction = Direction.Up;</span></span>
<span class="line"><span>console.log(dir); // 输出: 0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在上述示例中，我们定义了一个名为 Direction 的枚举，其中列出了 Up、Down、Left 和 Right 四个枚举成员。默认情况下，枚举成员的值从 0 开始自动递增，因此 Direction.Up 的值为 0。我们可以使用枚举成员来声明变量，并进行比较、打印等操作。</p><h3 id="_4-2-数字枚举" tabindex="-1">4.2. 数字枚举 <a class="header-anchor" href="#_4-2-数字枚举" aria-label="Permalink to &quot;4.2. 数字枚举&quot;">​</a></h3><p>在默认情况下，数字枚举的成员从 0 开始自动递增。</p><h4 id="_4-2-1-默认递增的数字枚举" tabindex="-1">4.2.1. 默认递增的数字枚举 <a class="header-anchor" href="#_4-2-1-默认递增的数字枚举" aria-label="Permalink to &quot;4.2.1. 默认递增的数字枚举&quot;">​</a></h4><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>enum Direction {</span></span>
<span class="line"><span>  Up,</span></span>
<span class="line"><span>  Down,</span></span>
<span class="line"><span>  Left,</span></span>
<span class="line"><span>  Right</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(Direction.Up);     // 输出: 0</span></span>
<span class="line"><span>console.log(Direction.Down);   // 输出: 1</span></span>
<span class="line"><span>console.log(Direction.Left);   // 输出: 2</span></span>
<span class="line"><span>console.log(Direction.Right);  // 输出: 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上述示例中，我们定义了一个名为 Direction 的枚举，其中列出了 Up、Down、Left 和 Right 四个枚举成员。默认情况下，枚举成员的值从 0 开始自动递增，因此 Direction.Up 的值是 0，Direction.Down 的值是 1，Direction.Left 的值是 2，Direction.Right 的值是 3。</p><h4 id="_4-2-2-手动赋值的数字枚举" tabindex="-1">4.2.2. 手动赋值的数字枚举 <a class="header-anchor" href="#_4-2-2-手动赋值的数字枚举" aria-label="Permalink to &quot;4.2.2. 手动赋值的数字枚举&quot;">​</a></h4><p>在手动赋值的数字枚举中，可以为每个枚举成员手动指定一个特定的值。手动赋值的数字枚举可以使用任意合法的数字作为成员的值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>enum Direction {</span></span>
<span class="line"><span>  Up = 2,</span></span>
<span class="line"><span>  Down = 4,</span></span>
<span class="line"><span>  Left = 6,</span></span>
<span class="line"><span>  Right = 8</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(Direction.Up);     // 输出: 2</span></span>
<span class="line"><span>console.log(Direction.Down);   // 输出: 4</span></span>
<span class="line"><span>console.log(Direction.Left);   // 输出: 6</span></span>
<span class="line"><span>console.log(Direction.Right);  // 输出: 8</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上述示例中，Direction.Up 被赋值为 2，Direction.Down 被赋值为 4，Direction.Left 被赋值为 6，Direction.Right 被赋值为 8。</p><h4 id="_4-2-3-计算成员的数字枚举" tabindex="-1">4.2.3. 计算成员的数字枚举 <a class="header-anchor" href="#_4-2-3-计算成员的数字枚举" aria-label="Permalink to &quot;4.2.3. 计算成员的数字枚举&quot;">​</a></h4><p>在数字枚举中，可以使用计算表达式作为成员的值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>enum Calculation {</span></span>
<span class="line"><span>  Addition = 2 + 3,</span></span>
<span class="line"><span>  Subtraction = 10 - 5,</span></span>
<span class="line"><span>  Multiplication = 6 * 2,</span></span>
<span class="line"><span>  Division = 20 / 4</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(Calculation.Addition);        // 输出: 5</span></span>
<span class="line"><span>console.log(Calculation.Subtraction);     // 输出: 5</span></span>
<span class="line"><span>console.log(Calculation.Multiplication);  // 输出: 12</span></span>
<span class="line"><span>console.log(Calculation.Division);        // 输出: 5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上述示例中，我们使用加法、减法、乘法和除法运算符来计算成员的值。在编译时，这些计算表达式会被求值为结果值并成为实际的枚举成员的值。</p><h3 id="_4-3-常量枚举" tabindex="-1">4.3. 常量枚举 <a class="header-anchor" href="#_4-3-常量枚举" aria-label="Permalink to &quot;4.3. 常量枚举&quot;">​</a></h3><p>常量枚举（const enum）是一种特殊类型的枚举，它在编译时被删除，并且只保留枚举成员的值作为常量。常量枚举提供了一种更轻量级的方式来使用枚举，可以用于在编译期间替换枚举成员的值。</p><h4 id="_4-3-1-常量枚举的定义" tabindex="-1">4.3.1. 常量枚举的定义 <a class="header-anchor" href="#_4-3-1-常量枚举的定义" aria-label="Permalink to &quot;4.3.1. 常量枚举的定义&quot;">​</a></h4><p>在定义常量枚举时，需要使用 <strong>const</strong> 关键字和 <strong>enum</strong> 关键字的组合。<strong>常量枚举不能有计算成员。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const enum Direction {</span></span>
<span class="line"><span>  Up,</span></span>
<span class="line"><span>  Down,</span></span>
<span class="line"><span>  Left,</span></span>
<span class="line"><span>  Right</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="_4-3-2-常量枚举的使用" tabindex="-1">4.3.2. 常量枚举的使用 <a class="header-anchor" href="#_4-3-2-常量枚举的使用" aria-label="Permalink to &quot;4.3.2. 常量枚举的使用&quot;">​</a></h4><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const enum Direction {</span></span>
<span class="line"><span>  Up,</span></span>
<span class="line"><span>  Down,</span></span>
<span class="line"><span>  Left,</span></span>
<span class="line"><span>  Right</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(Direction.Up);     // 输出: 0</span></span>
<span class="line"><span>console.log(Direction.Down);   // 输出: 1</span></span>
<span class="line"><span>console.log(Direction.Left);   // 输出: 2</span></span>
<span class="line"><span>console.log(Direction.Right);  // 输出: 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="_4-3-3-常量枚举会在编译阶段被删除" tabindex="-1">4.3.3. 常量枚举会在编译阶段被删除 <a class="header-anchor" href="#_4-3-3-常量枚举会在编译阶段被删除" aria-label="Permalink to &quot;4.3.3. 常量枚举会在编译阶段被删除&quot;">​</a></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1356b8c906ee43f182729c2349c61ed6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1956&amp;h=510&amp;s=212242&amp;e=png&amp;b=ffffff" alt=""></p><h3 id="_4-4-字符串枚举" tabindex="-1">4.4. 字符串枚举 <a class="header-anchor" href="#_4-4-字符串枚举" aria-label="Permalink to &quot;4.4. 字符串枚举&quot;">​</a></h3><p>在 TypeScript 中，字符串枚举是一种特殊类型的枚举，其中每个成员都用字符串字面量进行初始化。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>enum Direction {</span></span>
<span class="line"><span>  Up = &quot;UP&quot;,</span></span>
<span class="line"><span>  Down = &quot;DOWN&quot;,</span></span>
<span class="line"><span>  Left = &quot;LEFT&quot;,</span></span>
<span class="line"><span>  Right = &quot;RIGHT&quot;,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(Direction.Up)     // 输出 UP</span></span>
<span class="line"><span>console.log(Direction.Down)   // 输出 DOWN</span></span>
<span class="line"><span>console.log(Direction.Left)   // 输出 LEFT</span></span>
<span class="line"><span>console.log(Direction.Right)  // 输出 RIGHT</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上述示例中，我们定义了一个名为 Direction 的字符串枚举。其中的成员 Up 使用字符串字面量 &quot;UP&quot; 进行初始化，成员 Down 使用字符串字面量 &quot;DOWN&quot; 进行初始化，成员 Left 使用字符串字面量 &quot;LEFT&quot; 进行初始化，成员 Right 使用字符串字面量 &quot;RIGHT&quot; 进行初始化。我们可以通过直接访问枚举成员来获得其对应的字符串值。</p><p>字符串枚举的特点：</p><ul><li>明确的字符串值：每个字符串枚举成员都具有明确的字符串值，可更好地描述其含义和用途。</li><li>代码可读性：由于成员的值直接使用字符串字面量，因此代码更加清晰、易读。</li><li>保留字符串字面量：使用字符串枚举可以在编译后保留字符串字面量，而不是转换为数值或其他类型。</li><li>可用于反向映射：字符串枚举可以支持从枚举值到枚举名的反向映射。</li></ul><h3 id="_4-5-外部枚举" tabindex="-1">4.5. 外部枚举 <a class="header-anchor" href="#_4-5-外部枚举" aria-label="Permalink to &quot;4.5. 外部枚举&quot;">​</a></h3><p>外部枚举（ambient enum）是一种定义在外部代码（如声明文件）中的枚举。外部枚举通常用于描述已存在的枚举类型的形状，而不是为了创建一个具体的 JavaScript 对象。</p><p><strong>外部枚举的定义不会在编译时生成任何实际的 JavaScript 代码，它只用于类型检查。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>declare enum HttpStatusCode {</span></span>
<span class="line"><span>  OK = 200,</span></span>
<span class="line"><span>  BadRequest = 400,</span></span>
<span class="line"><span>  Unauthorized,</span></span>
<span class="line"><span>  NotFound = 404</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let code: HttpStatusCode = HttpStatusCode.OK;</span></span>
<span class="line"><span>console.log(code);                        // 输出: 200</span></span>
<span class="line"><span>console.log(HttpStatusCode.BadRequest);   // 输出: 400</span></span>
<span class="line"><span>console.log(HttpStatusCode.Unauthorized); // 输出: 401 (自动递增)</span></span>
<span class="line"><span>console.log(HttpStatusCode.NotFound);     // 输出: 404</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在上述示例中，我们使用 declare 关键字来定义了一个外部枚举 HttpStatusCode。它描述了一些常见的 HTTP 状态码。其中的成员 OK 和 BadRequest 和 NotFound 指定了具体的数值，分别为 200，400 和 404，成员 Unauthorized 没有显式指定值，它会根据前一个成员的值自动递增，因此值为 401。</p><p>在使用外部枚举时，我们可以像使用普通枚举一样，访问它的成员并获得相应的值。在上述示例中，我们将 HttpStatusCode.OK 赋值给变量 code，然后将变量 code 的值打印出来，得到的结果是 200。</p><p>注意：当使用外部枚举时，我们必须使用 <strong>declare</strong> 来声明它，以告诉 TypeScript 编译器这是一个外部定义的枚举。此外，外部枚举的定义通常是在一个声明文件中（以 .d.ts 结尾），以便在与现有 JavaScript 库或框架进行交互时提供类型信息。</p><p>总结起来，外部枚举是 TypeScript 中一种在外部代码中定义的枚举，用于描述已存在的枚举类型的形状。外部枚举的定义通常只用于类型检查，并不会生成实际的 JavaScript 代码。它在与现有 JavaScript 库或框架进行交互时提供类型信息。</p><h3 id="_4-6-异构枚举" tabindex="-1">4.6. 异构枚举 <a class="header-anchor" href="#_4-6-异构枚举" aria-label="Permalink to &quot;4.6. 异构枚举&quot;">​</a></h3><p>异构枚举（heterogeneous enum）是一种允许枚举成员的值具有不同类型的枚举。</p><p>通常情况下，枚举中的成员的值应该是相同类型的。但是异构枚举允许在同一个枚举中使用不同类型的值，包括字符串、数字和其他类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>enum Status {</span></span>
<span class="line"><span>  Active = 1,</span></span>
<span class="line"><span>  Pending,</span></span>
<span class="line"><span>  Inactive = &quot;inactive&quot;,</span></span>
<span class="line"><span>  OnHold = &quot;on hold&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(Status.Active);   // 输出: 1</span></span>
<span class="line"><span>console.log(Status.Pending);  // 输出: 2 (自动递增)</span></span>
<span class="line"><span>console.log(Status.Inactive); // 输出: &quot;inactive&quot;</span></span>
<span class="line"><span>console.log(Status.OnHold);   // 输出: &quot;on hold&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上述示例中，我们定义了一个名为 Status 的异构枚举。其中的成员 Active 的值是一个数字，值为 1。成员 Pending 没有显式指定值，它的值会根据前一个成员的值自动递增，因此值为 2。成员 Inactive 的值是一个字符串，值为 &quot;inactive&quot;。成员 OnHold 的值是一个字符串，值为 &quot;on hold&quot;。</p><p>在访问异构枚举的成员时，将得到其对应的值。在上述示例中，我们分别打印了每个异构枚举成员的值，并相应地获得了不同类型的结果。</p><p>异构枚举的优势在于允许在一组相关的枚举中使用不同类型的值。这在某些特定情况下可能很有用，例如需要表示不同种类的状态或类型时。</p><p>注意：<strong>在异构枚举中，具有数字字面量值的成员会根据前一个成员的值自动递增，而具有字符串字面量值的成员不会自动递增。同时，在异构枚举中，没有初始化值的成员会根据前一个成员的值自动递增。</strong></p><h3 id="_4-7-反向映射" tabindex="-1">4.7. 反向映射 <a class="header-anchor" href="#_4-7-反向映射" aria-label="Permalink to &quot;4.7. 反向映射&quot;">​</a></h3><p>反向映射（reverse mapping）是指<strong>枚举成员不仅可以通过名称访问值，而且可以通过值访问名称。</strong> 这意味着可以根据枚举的值获取到对应的枚举成员名称。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>enum Direction {</span></span>
<span class="line"><span>  Up = 1,</span></span>
<span class="line"><span>  Down,</span></span>
<span class="line"><span>  Left,</span></span>
<span class="line"><span>  Right</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let rightValue = Direction.Right;</span></span>
<span class="line"><span>let rightName = Direction[rightValue];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(rightValue);  // 输出: 4</span></span>
<span class="line"><span>console.log(rightName);   // 输出: Right</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在上述示例中，我们定义了一个名为 Direction 的枚举，其中的成员分别使用数字进行初始化。我们将 Direction.Right 的值赋给变量 rightValue，然后使用 Direction[rightValue] 获取到对应的枚举成员名称，将结果赋给变量 rightName。</p><p>在打印出变量 rightValue 和 rightName 的值后，我们得到的结果是 4 和 Right。这就是反向映射的效果，根据枚举的值可以获取到对应的枚举成员名称。</p><p>注意：<strong>反向映射只在数字枚举中有效，而不适用于字符串枚举。</strong> 字符串枚举的成员值虽然可以是字符串字面量，但在 JavaScript 中无法实现反向映射。</p><h3 id="_4-8-运行时的枚举" tabindex="-1">4.8. 运行时的枚举 <a class="header-anchor" href="#_4-8-运行时的枚举" aria-label="Permalink to &quot;4.8. 运行时的枚举&quot;">​</a></h3><p>运行时的枚举（runtime enum）是指在 JavaScript 运行时可访问和操作的枚举。</p><p>TypeScript 编译器在编译过程中，会将枚举类型转换为实际的 JavaScript 对象。这些对象在运行时仍然保留了枚举的结构和值，以便能够通过它们来进行运行时的枚举操作。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>enum Fruit {</span></span>
<span class="line"><span>  Apple,</span></span>
<span class="line"><span>  Orange,</span></span>
<span class="line"><span>  Banana</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function getFruitName(fruit: Fruit): string {</span></span>
<span class="line"><span>  switch (fruit) {</span></span>
<span class="line"><span>    case Fruit.Apple:</span></span>
<span class="line"><span>      return &quot;Apple&quot;;</span></span>
<span class="line"><span>    case Fruit.Orange:</span></span>
<span class="line"><span>      return &quot;Orange&quot;;</span></span>
<span class="line"><span>    case Fruit.Banana:</span></span>
<span class="line"><span>      return &quot;Banana&quot;;</span></span>
<span class="line"><span>    default:</span></span>
<span class="line"><span>      throw new Error(&quot;Invalid fruit&quot;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(getFruitName(Fruit.Apple));  // 输出: Apple</span></span>
<span class="line"><span>console.log(getFruitName(Fruit.Orange)); // 输出: Orange</span></span>
<span class="line"><span>console.log(getFruitName(Fruit.Banana)); // 输出: Banana</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>在上述示例中，我们定义了一个名为 Fruit 的枚举，其中包含了三个成员 Apple、Orange 和 Banana。然后我们定义了一个函数 getFruitName，它接受一个 Fruit 类型的参数，根据传入的枚举值返回对应的水果名称。</p><p>通过运行 getFruitName 函数并传入不同的枚举值，我们可以在控制台上看到输出的结果，它们是根据传入的枚举值返回的相应水果名称。</p><p>注意：<strong>当使用运行时枚举时，由于枚举的成员值实际上是数字（默认从 0 开始递增），因此进行比较时需要使用严格相等运算符 ===。</strong></p><h3 id="_4-9-联合枚举" tabindex="-1">4.9. 联合枚举 <a class="header-anchor" href="#_4-9-联合枚举" aria-label="Permalink to &quot;4.9. 联合枚举&quot;">​</a></h3><p>联合枚举（union enum）是指一个枚举类型可以包含多个不同的枚举成员的组合。每个成员可以具有不同的值和类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>enum Shape {</span></span>
<span class="line"><span>  Circle = &quot;circle&quot;,</span></span>
<span class="line"><span>  Rectangle = &quot;rectangle&quot;,</span></span>
<span class="line"><span>  Triangle = &quot;triangle&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>enum Color {</span></span>
<span class="line"><span>  Red = &quot;red&quot;,</span></span>
<span class="line"><span>  Green = &quot;green&quot;,</span></span>
<span class="line"><span>  Blue = &quot;blue&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type ShapeColor = Shape.Circle | Shape.Rectangle | Shape.Triangle | Color.Red | Color.Green | Color.Blue;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function drawShape(shape: ShapeColor) {</span></span>
<span class="line"><span>  switch (shape) {</span></span>
<span class="line"><span>    case Shape.Circle:</span></span>
<span class="line"><span>      console.log(&quot;画一个圆形&quot;);</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    case Shape.Rectangle:</span></span>
<span class="line"><span>      console.log(&quot;画一个矩形&quot;);</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    case Shape.Triangle:</span></span>
<span class="line"><span>      console.log(&quot;画一个三角形&quot;);</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    case Color.Red:</span></span>
<span class="line"><span>      console.log(&quot;颜色为红色&quot;);</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    case Color.Green:</span></span>
<span class="line"><span>      console.log(&quot;颜色为绿色&quot;);</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    case Color.Blue:</span></span>
<span class="line"><span>      console.log(&quot;颜色为蓝色&quot;);</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    default:</span></span>
<span class="line"><span>      throw new Error(&quot;Invalid shape or color&quot;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>drawShape(Shape.Circle); // 输出: 画一个圆形</span></span>
<span class="line"><span>drawShape(Color.Blue);   // 输出: 颜色为蓝色</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>在上述示例中，我们定义了两个枚举 Shape 和 Color。Shape 枚举表示不同的形状，Color 枚举表示不同的颜色。然后我们定义了一个类型别名 ShapeColor，它是 Shape 枚举成员和 Color 枚举成员的联合。接着，我们定义了一个函数 drawShape，它接受一个 ShapeColor 类型的参数 shape。根据传入的参数值进行不同的分支逻辑处理，并输出相应的消息。通过调用 drawShape 函数并传入不同的值，我们可以根据传入的参数值来绘制不同的形状或填充不同的颜色。</p><p>联合枚举使得我们能够在一个类型中组合多个不同的枚举成员，以表示更复杂的类型。这可以让 TypeScript 的类型系统提供更精确的类型检查和推断，以确保代码的正确性。</p><p>注意：<strong>联合枚举的使用是通过定义类型别名或接口来实现的。</strong> 通过将不同枚举成员组合在一起，可以创建复合类型，提供更灵活的数据表示。</p><h2 id="_5-any-类型" tabindex="-1">5. any 类型 <a class="header-anchor" href="#_5-any-类型" aria-label="Permalink to &quot;5\. any 类型&quot;">​</a></h2><p>在 TypeScript 中，any 类型表示一个动态类型，它可以接受任何类型的值。使用 any 类型时，TypeScript 编译器将不会对值进行类型检查，允许你在编译期绕过类型系统的限制。</p><p>如果是一个普通类型，在赋值过程中改变类型是不被允许的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e98e4495fc94361850d74bd01dcada6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=381&amp;h=146&amp;s=8086&amp;e=png&amp;b=1f1f1f" alt=""></p><p>如果是 any 类型，则允许被赋值为任意类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let x: any = 26;</span></span>
<span class="line"><span>x = &quot;Echo&quot;;</span></span>
<span class="line"><span>x = true;</span></span>
<span class="line"><span>x = undefined</span></span>
<span class="line"><span>x = null</span></span>
<span class="line"><span>x = []</span></span>
<span class="line"><span>x = {}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>以下两种情况，隐式具有 any 类型：</p><ul><li>声明变量不提供类型也不提供默认值。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a917b2b0a8fc42b4a65bc3bf048918a5~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=590&amp;h=144&amp;s=8133&amp;e=png&amp;b=1f1f1f" alt=""></p><ul><li>函数参数不加类型。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2aec5b492cad49598a058ccb9b2cf343~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=671&amp;h=193&amp;s=12538&amp;e=png&amp;b=1e1e1e" alt=""></p><p>注意：在开发过程中应尽量避免过度使用 any 类型，以充分利用 TypeScript 的类型系统来提供更好的类型安全性和代码可维护性。</p><h2 id="五、接口-interface" tabindex="-1">五、接口（interface） <a class="header-anchor" href="#五、接口-interface" aria-label="Permalink to &quot;五、接口（interface）&quot;">​</a></h2><h2 id="_1-什么是接口" tabindex="-1">1. 什么是接口 <a class="header-anchor" href="#_1-什么是接口" aria-label="Permalink to &quot;1\. 什么是接口&quot;">​</a></h2><p>在 TypeScript 中，接口（Interface）是一种用来定义对象的结构和行为的类型。通过接口，我们可以定义对象应该有哪些属性、属性的类型以及方法。</p><p>接口提供了一种约束和规范，使得我们可以在代码中定义和使用特定的数据结构。</p><h2 id="_2-定义接口" tabindex="-1">2. 定义接口 <a class="header-anchor" href="#_2-定义接口" aria-label="Permalink to &quot;2\. 定义接口&quot;">​</a></h2><ul><li>使用关键字 <strong>interface</strong> 来定义接口。</li><li>声明接口后，直接使用接口名称作为变量的类型。</li><li>方法的定义和函数的定义类似，包括参数和返回值类型。</li><li>接口一般首字母大写。<strong>有的编程语言中建议接口的名称加上前缀</strong> <strong>I</strong> <strong>。</strong></li></ul><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>  name: string</span></span>
<span class="line"><span>  age: number</span></span>
<span class="line"><span>  sayHi(): void</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let jerry: Person = {</span></span>
<span class="line"><span>  name: &#39;John&#39;,</span></span>
<span class="line"><span>  age: 25,</span></span>
<span class="line"><span>  sayHi() {}</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>上面的代码中，我们定义了一个接口 Person，接着定义了一个变量 jerry，它的类型是 Person。这样，我们就约束了 jerry 的形状必须和接口 Person 一致。</p><p>注意：<strong>定义的变量比接口少了一些属性不允许的</strong>。</p><p>下面是一段错误的代码演示：我们定义了一个接口 Person，里面有 name，age2 个属性，以及 sayHi 方法，接着定义了一个变量 jerry，它的类型是 Person，但是我们只给属性 name 和 age 赋值，所以会报错。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f86b62d7bc9d4f80b49af1ae1c541212~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1222&amp;h=454&amp;s=76028&amp;e=png&amp;b=1f1f1f" alt=""></p><p>当然，<strong>定义的变量比接口多了一些属性也是不允许的。</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/753dd188ed4943498d321759b99a21bb~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1188&amp;h=422&amp;s=75112&amp;e=png&amp;b=1f1f1f" alt=""></p><p>也就是说，<strong>在赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p><h2 id="_3-接口-interface-和类型别名-type-的区别" tabindex="-1">3. 接口（interface）和类型别名（type）的区别 <a class="header-anchor" href="#_3-接口-interface-和类型别名-type-的区别" aria-label="Permalink to &quot;3\. 接口（interface）和类型别名（type）的区别&quot;">​</a></h2><ol><li><p>相同点：都可以用于定义对象的结构和类型。</p></li><li><p>不同点：</p></li><li><ol><li>接口更适合用于描述真实存在的对象，而类型别名更适合用于定义复杂的类型。</li><li>接口可以被其他对象实现，而类型别名只是给类型起了一个别名。</li></ol></li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>  name: string</span></span>
<span class="line"><span>  age: number</span></span>
<span class="line"><span>  sayHi(): void</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type IPerson = {</span></span>
<span class="line"><span>  name: string</span></span>
<span class="line"><span>  age: number</span></span>
<span class="line"><span>  sayHi(): void</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_4-接口继承-extends" tabindex="-1">4. 接口继承（extends） <a class="header-anchor" href="#_4-接口继承-extends" aria-label="Permalink to &quot;4\. 接口继承（extends）&quot;">​</a></h2><p>在 TypeScript 中，接口是可以相互继承的，也就是说：<strong>一个接口可以从另一个接口中继承属性和方法的定义（通过继承实现复用）。</strong> 接口的继承可以通过使用关键字 <strong>extends</strong> ****实现。</p><p>接口继承的语法格式如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42b98c2e9896448da4d04c01755db5b1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=788&amp;h=530&amp;s=78290&amp;e=png&amp;b=1f1f1f" alt=""></p><p>通过继承，子接口可以获得父接口中定义的属性和方法，并可以在自身接口中添加新的属性和方法。</p><p>下面是一个简单的例子，展示了接口继承的用法：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Shape {</span></span>
<span class="line"><span>  color: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface Circle extends Shape {</span></span>
<span class="line"><span>  radius: number;</span></span>
<span class="line"><span>  getArea(): number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const circle: Circle = {</span></span>
<span class="line"><span>  color: &quot;red&quot;,</span></span>
<span class="line"><span>  radius: 5,</span></span>
<span class="line"><span>  getArea() {</span></span>
<span class="line"><span>    return Math.PI * this.radius * this.radius;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在上面的例子中，使用 extends 关键字实现了接口 Circle 继承 Shape。继承后，Circle 就有了 Shape 中的 color 属性，以及自身的 radius 属性以及 getArea() 方法。</p><h2 id="_5-接口的可选属性" tabindex="-1">5. 接口的可选属性 <a class="header-anchor" href="#_5-接口的可选属性" aria-label="Permalink to &quot;5\. 接口的可选属性&quot;">​</a></h2><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <strong>?</strong> 符号。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age?: number; // 可选属性</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const person1: Person = { name: &quot;Alice&quot; };</span></span>
<span class="line"><span>const person2: Person = { name: &quot;Bob&quot;, age: 25 };</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>上面的例子中，Person 接口中的 age 属性是可选的，我们定义了 person1 和 person2 两个对象，类型都是 Person，其中，person1 对象中没有 age 属性，而 person2 对象中包含了 age 属性。</p><p>可选属性的好处有 2 个：</p><ol><li>可以对可能存在的属性进行预定义</li><li>可以捕获引用了不存在的属性时的错误</li></ol><p>例如，我们故意将 person2 对象中的 age 属性名写错，就会得到一个错误的提示。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a418d7bf50da428b832d1140ceecc362~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1262&amp;h=240&amp;s=82291&amp;e=png&amp;b=1f1f1f" alt=""></p><h2 id="_6-接口的只读属性" tabindex="-1">6. 接口的只读属性 <a class="header-anchor" href="#_6-接口的只读属性" aria-label="Permalink to &quot;6\. 接口的只读属性&quot;">​</a></h2><p>有时候我们希望某些属性在对象创建后不能被修改，可以将这些属性声明为<strong>只读属性</strong>。</p><p>通过在属性名称前面加上 <strong>readonly</strong> 关键字，就可以将属性设置为只读。</p><p>例如，下面的例子中，声明了一个名称为 Point2D 的接口，接口中的属性 x 和 y 都是只读的，然后创建了一个 point 对象，类型为 Point2D，此时，我们不能再给对象中的 x 和 y 重新赋值，会报错，因为它们都是只读属性。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/818fd84cf8744f8a8dea80057bb90607~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=588&amp;h=362&amp;s=54075&amp;e=png&amp;b=1f1f1f" alt=""></p><p>此外 TypeScript 还提供了 <strong>ReadonlyArray</strong> 类型，它与 <strong>Array</strong> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let a: number[] = [1, 2, 3, 4]</span></span>
<span class="line"><span>let ro: ReadonlyArray&lt;number&gt; = a</span></span>
<span class="line"><span>ro[0] = 12      // error!</span></span>
<span class="line"><span>ro.push(5)      // error!</span></span>
<span class="line"><span>ro.length = 100 // error!</span></span>
<span class="line"><span>a = ro          // error!</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_7-额外的属性检查" tabindex="-1">7. 额外的属性检查 <a class="header-anchor" href="#_7-额外的属性检查" aria-label="Permalink to &quot;7\. 额外的属性检查&quot;">​</a></h2><p>接口用于定义对象的结构，当我们使用<strong>对象字面量</strong>赋值给接口类型时，TypeScript 会自动进行额外的属性检查。这意味着<strong>赋值的对象不能包含接口中未定义的额外属性，否则会导致编译错误。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Rectangle {</span></span>
<span class="line"><span>  width: number;</span></span>
<span class="line"><span>  height: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const rect1: Rectangle = { width: 10, height: 20 }</span></span>
<span class="line"><span>const rect2: Rectangle = { width: 10, height: 20, color: &quot;red&quot; } // 编译错误，额外的属性检查</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在上述例子中，rect2 对象包含了额外的 color 属性，但是接口 Rectangle 中并未定义该属性，所以会导致编译错误。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3405161cc8e94a15b5b06b86f8789612~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1636&amp;h=236&amp;s=98261&amp;e=png&amp;b=1f1f1f" alt=""></p><p>注意：<strong>如果我们确定对象会包含额外的属性，可以使用类型断言（Type Assertion）来绕过额外属性检查。</strong></p><h2 id="_8-接口的任意属性" tabindex="-1">8. 接口的任意属性 <a class="header-anchor" href="#_8-接口的任意属性" aria-label="Permalink to &quot;8\. 接口的任意属性&quot;">​</a></h2><p>有时候我们希望一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使用 <strong>索引签名</strong> 的形式来满足上述要求。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age?: number;</span></span>
<span class="line"><span>  [propName: string]: any;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let person: Person = {</span></span>
<span class="line"><span>  name: &#39;Echo&#39;,</span></span>
<span class="line"><span>  gender: &#39;male&#39;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>上述代码中，我们使用 <strong>[propName: string]</strong> 定义了任意属性取 <strong>string</strong> 类型的值。</p><p>注意：<strong>一旦定义了任意属性，那么必选属性和可选属性的类型都必须是它的类型的子集：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age?: number;</span></span>
<span class="line"><span>  [propName: string]: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let person: Person = {</span></span>
<span class="line"><span>  name: &#39;Echo&#39;,</span></span>
<span class="line"><span>  age: 25,</span></span>
<span class="line"><span>  gender: &#39;male&#39;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>上述例子中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11c9fb0e19c34412bcafc922950c4608~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1012&amp;h=368&amp;s=72754&amp;e=png&amp;b=1f1f1f" alt=""></p><p>注意：<strong>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age?: number; // 这里age真实的类型应该为：number | undefined</span></span>
<span class="line"><span>  [propName: string]: string | number | undefined;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let person: Person = {</span></span>
<span class="line"><span>  name: &#39;Echo&#39;,</span></span>
<span class="line"><span>  age: 25,</span></span>
<span class="line"><span>  gender: &#39;male&#39;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_9-函数类型" tabindex="-1">9. 函数类型 <a class="header-anchor" href="#_9-函数类型" aria-label="Permalink to &quot;9\. 函数类型&quot;">​</a></h2><p>接口可以描述函数类型。</p><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义，参数列表里的每个参数都需要名字和类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface SearchFunc {</span></span>
<span class="line"><span>  (source: string, subString: string): boolean;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上述例子中，SearchFunc 是一个接口，它表示一个接收两个参数 source 和 subString，参数类型都为 string，并且返回值为 number 类型的函数。</p><p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。</p><p>下面的例子展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface SearchFunc {</span></span>
<span class="line"><span>  (source: string, subString: string): boolean;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let mySearch: SearchFunc;</span></span>
<span class="line"><span>mySearch = function(source: string, subString: string) {</span></span>
<span class="line"><span>  let result = source.search(subString);</span></span>
<span class="line"><span>  return result &gt; -1;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>注意：<strong>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。</strong></p><p>例如，我们使用下面的代码重写上面的例子：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface SearchFunc {</span></span>
<span class="line"><span>  (source: string, subString: string): boolean;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let mySearch: SearchFunc;</span></span>
<span class="line"><span>mySearch = function(src: string, sub: string): boolean {</span></span>
<span class="line"><span>  let result = src.search(sub);</span></span>
<span class="line"><span>  return result &gt; -1;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。</p><p>如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false 和 true）。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface SearchFunc {</span></span>
<span class="line"><span>  (source: string, subString: string): boolean;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let mySearch: SearchFunc;</span></span>
<span class="line"><span>mySearch = function(src, sub) {</span></span>
<span class="line"><span>    let result = src.search(sub);</span></span>
<span class="line"><span>    return result &gt; -1;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc 接口中的定义不匹配。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85183e74f0c04a61ade34214f0a8a862~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=728&amp;h=310&amp;s=48265&amp;e=png&amp;b=1f1f1f" alt=""></p><h2 id="_10-可索引类型" tabindex="-1">10. 可索引类型 <a class="header-anchor" href="#_10-可索引类型" aria-label="Permalink to &quot;10\. 可索引类型&quot;">​</a></h2><p>接口可以描述具有索引签名的对象，这样我们就可以通过索引来访问对象的属性。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface StringArray {</span></span>
<span class="line"><span>  [index: number]: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let myArray: StringArray;</span></span>
<span class="line"><span>myArray = [&quot;Bob&quot;, &quot;Fred&quot;];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let myStr: string = myArray[0];</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上述的例子中，我们定义了 StringArray 接口，它具有索引签名。这个索引签名表示了当用 number 去索引 StringArray 时会得到 string 类型的返回值。</p><p>TypeScript 支持两种索引签名：<strong>字符串和数字。可以同时使用两种类型的索引，但是</strong>数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number 来索引时，JavaScript 会将它转换成 string 然后再去索引对象。 也就是说用 100（一个 number）去索引等同于使用&quot;100&quot;（一个 string）去索引，因此两者需要保持一致。</p><h2 id="_11-类类型实现接口" tabindex="-1">11. 类类型实现接口 <a class="header-anchor" href="#_11-类类型实现接口" aria-label="Permalink to &quot;11\. 类类型实现接口&quot;">​</a></h2><p>接口可以被类实现，称为<strong>类类型</strong>。</p><p>类可以通过 <strong>implements</strong> 关键字来实现接口，并必须实现接口中定义的所有属性和方法。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Printable {</span></span>
<span class="line"><span>  print(): void;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Document implements Printable {</span></span>
<span class="line"><span>  print() {</span></span>
<span class="line"><span>    console.log(&quot;Printing document...&quot;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在上述例子中，Document 类实现了 Printable 接口，并实现了接口中定义的 print 方法。</p><h2 id="_12-继承接口" tabindex="-1">12. 继承接口 <a class="header-anchor" href="#_12-继承接口" aria-label="Permalink to &quot;12\. 继承接口&quot;">​</a></h2><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Shape {</span></span>
<span class="line"><span>    color: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface Square extends Shape {</span></span>
<span class="line"><span>    sideLength: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let square = &lt;Square&gt;{};</span></span>
<span class="line"><span>square.color = &quot;blue&quot;;</span></span>
<span class="line"><span>square.sideLength = 10;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Shape {</span></span>
<span class="line"><span>    color: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface PenStroke {</span></span>
<span class="line"><span>    penWidth: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface Square extends Shape, PenStroke {</span></span>
<span class="line"><span>    sideLength: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let square = &lt;Square&gt;{};</span></span>
<span class="line"><span>square.color = &quot;blue&quot;;</span></span>
<span class="line"><span>square.sideLength = 10;</span></span>
<span class="line"><span>square.penWidth = 5.0;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="_13-接口继承类" tabindex="-1">13. 接口继承类 <a class="header-anchor" href="#_13-接口继承类" aria-label="Permalink to &quot;13\. 接口继承类&quot;">​</a></h2><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Animal {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  constructor(name: string) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  eat() {</span></span>
<span class="line"><span>    console.log(this.name + &quot; is eating.&quot;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface CanRun extends Animal {</span></span>
<span class="line"><span>  run(): void;</span></span>
<span class="line"><span>  eat(): void;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Dog implements CanRun {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  constructor(name: string) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  run() {</span></span>
<span class="line"><span>    console.log(this.name + &quot; is running.&quot;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  eat() {</span></span>
<span class="line"><span>    console.log(this.name + &quot; is eating.&quot;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const dog: CanRun = new Dog(&quot;Buddy&quot;);</span></span>
<span class="line"><span>dog.eat(); // 输出：Buddy is eating.</span></span>
<span class="line"><span>dog.run(); // 输出：Buddy is running.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>在以上示例中，我们定义了一个 Animal 类，它有一个 name 属性和一个 eat 方法。然后，我们定义了一个接口 CanRun，它继承自 Animal 类，并添加了一个 run 和 eat 方法。接着，我们创建了一个 Dog 类来实现 CanRun 接口，并在 Dog 类中实现了 run 和 eat 方法。</p><p>在最后的代码中，我们使用 CanRun 接口来声明一个 dog 对象，并将其实例化为 Dog 类的对象。这样，我们可以通过调用 dog 对象的 eat 和 run 方法来验证接口继承类的实现。</p><p><strong>接口继承类的主要作用在于类型标注和约束。</strong> 通过接口继承类，我们可以定义更具体的接口类型，使得类和接口之间的关系更加清晰。同时，在使用接口类型的变量或参数时，可以享受到类成员的类型检查和智能提示的功能。这对于代码的可读性、可维护性和可扩展性都有很大的帮助。</p><h2 id="六、类型别名" tabindex="-1">六、类型别名 <a class="header-anchor" href="#六、类型别名" aria-label="Permalink to &quot;六、类型别名&quot;">​</a></h2><p>作用：</p><p>在 TS 中，类型别名主要用于为已有的类型创建别名，以便在代码中更方便地引用和重用这些类型。</p><p>用法：</p><ol><li>使用 <strong>type</strong> 关键字可以为任何类型定义别名，包括基本类型、复杂类型、函数类型等。</li><li>创建类型别名后，直接使用该类型别名作为变量的类型注解即可。</li></ol><p>解释：</p><ol><li>类型别名是为已有类型提供另一个名称，而不是创建新的类型。</li><li>类型别名可以用于简化复杂类型的表达，提高可读性和可维护性。</li><li>类型别名可以用于定义联合类型或交叉类型的别名。</li></ol><p>注意：</p><ol><li>尽量选择有意义的别名，能够准确描述类型的用途，提高代码的可读性。</li><li>避免过度使用类型别名，过多的别名可能导致代码的可维护性变差。</li><li>注意避免循环引用的情况，即在类型别名中引用自身，这会导致编译错误。</li><li>类型别名并不创建新的类型，所以它无法被继承或实现。</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 未使用类型别名</span></span>
<span class="line"><span>let arr: (number | string)[] = [1, 2, 3]</span></span>
<span class="line"><span>let arr1: (number | string)[] = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 使用类型别名</span></span>
<span class="line"><span>type CustomArray = (number | string)[]</span></span>
<span class="line"><span>let arr2: CustomArray = [1, 2, 3]</span></span>
<span class="line"><span>let arr3: CustomArray = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span></span>
<span class="line"><span>let arr4: CustomArray = [1, &#39;a&#39;, 2, &#39;b&#39;, 3, &#39;c&#39;]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="七、类型推论" tabindex="-1">七、类型推论 <a class="header-anchor" href="#七、类型推论" aria-label="Permalink to &quot;七、类型推论&quot;">​</a></h2><h2 id="_1-定义" tabindex="-1">1. 定义 <a class="header-anchor" href="#_1-定义" aria-label="Permalink to &quot;1\. 定义&quot;">​</a></h2><p>在 TypeScript 中，类型推论（Type Inference）是指<strong>编译器在没有明确指定类型的情况下，根据变量的值推断出该变量的类型。</strong> 通过类型推论，TypeScript 可以在代码中自动推断出变量的类型，而无需显式地将其指定为特定类型。</p><h2 id="_2-基本类型推论" tabindex="-1">2. 基本类型推论 <a class="header-anchor" href="#_2-基本类型推论" aria-label="Permalink to &quot;2\. 基本类型推论&quot;">​</a></h2><p>当声明一个变量时，如果没有显式指定类型，并且在声明的同时进行了赋值操作，TypeScript 将根据赋值的值推断出变量的类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let age = 26;         // 推断为 number 类型</span></span>
<span class="line"><span>let str = &quot;Echo&quot;;    // 推断为 string 类型</span></span>
<span class="line"><span>let isActive = true; // 推断为 boolean 类型</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 以上的代码等价于下面的下吗</span></span>
<span class="line"><span>let age: number = 26;</span></span>
<span class="line"><span>let str: string = &quot;Echo&quot;;</span></span>
<span class="line"><span>let isActive: boolean = true;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/282529f5966d4f4f8b88d1db0b95c552~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=968&amp;h=446&amp;s=74819&amp;e=png&amp;b=ffffff" alt=""></p><h2 id="_3-上下文类型推论" tabindex="-1">3. 上下文类型推论 <a class="header-anchor" href="#_3-上下文类型推论" aria-label="Permalink to &quot;3\. 上下文类型推论&quot;">​</a></h2><p>当变量的类型与其所处的上下文相关时，TypeScript 可以根据上下文进行类型推断。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function add(x: number, y: number) {</span></span>
<span class="line"><span>  return x + y;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let result = add(5, 10); // 推断 result 为 number 类型</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在上述示例中，函数 add 接收两个参数，并返回它们的和。当我们调用 add(5, 10) 时，TypeScript 根据函数返回值的类型推断出 result 变量的类型为 number。</p><h2 id="_4-最佳通用类型推论" tabindex="-1">4. 最佳通用类型推论 <a class="header-anchor" href="#_4-最佳通用类型推论" aria-label="Permalink to &quot;4\. 最佳通用类型推论&quot;">​</a></h2><p>当需要推断出数组或对象类型时，TypeScript 会根据元素或属性的类型推断出一个“最佳通用类型”。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let numbers = [1, 2, 3]; // 推断为 number[] 类型</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let mixed = [26, &quot;Echo&quot;, true]; // 推断为 (number | string | boolean)[]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上述示例中，数组 numbers 中的所有元素都是数字，因此 TypeScript 推断出 numbers 的类型为 number[]。而数组 mixed 中的元素类型不同（数字、字符串和布尔值），所以 TypeScript 推断出 mixed 的类型为 (number | string | boolean)[]，表示该数组可以存储数字、字符串或布尔值类型的元素。</p><h2 id="_5-声明变量但没有赋值的情况" tabindex="-1">5. 声明变量但没有赋值的情况 <a class="header-anchor" href="#_5-声明变量但没有赋值的情况" aria-label="Permalink to &quot;5\. 声明变量但没有赋值的情况&quot;">​</a></h2><p>如果声明变量的时候没有赋值，不管之后有没有赋值，都会被推断成 <strong>any</strong> 类型而完全不被类型检查。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let str</span></span>
<span class="line"><span></span></span>
<span class="line"><span>str = &quot;Echo&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>str = 26</span></span>
<span class="line"><span></span></span>
<span class="line"><span>str = true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在上述示例中，变量 str 的类型推断为 any 类型，因为它没有明确的初始值。此时我们就可以把任意类型的值赋值给 str。</p><p>需要注意的是，虽然 TypeScript 可以根据赋值来推断类型，但如果变量的初始值为 null 或 undefined，类型推论仍然会将其推断为 any 类型。</p><p><strong>为了避免使用 any 类型，我们可以显式指定变量的类型或为变量提供一个初始值来触发类型推论。</strong></p><h2 id="八、类型断言" tabindex="-1">八、类型断言 <a class="header-anchor" href="#八、类型断言" aria-label="Permalink to &quot;八、类型断言&quot;">​</a></h2><h2 id="_1-定义-1" tabindex="-1">1. 定义 <a class="header-anchor" href="#_1-定义-1" aria-label="Permalink to &quot;1\. 定义&quot;">​</a></h2><p>类型断言（Type Assertion）是 TypeScript 中的一种表达式，它可以用来告诉编译器一个值的确切类型。通过类型断言，我们可以在一些情况下主动指定变量的类型，以满足特定的需求。</p><h2 id="_2-语法" tabindex="-1">2. 语法 <a class="header-anchor" href="#_2-语法" aria-label="Permalink to &quot;2\. 语法&quot;">​</a></h2><p>类型断言有 2 种语法形式：</p><ol><li><strong>尖括号语法：</strong> 使用尖括号 &lt;&gt; 将值包裹，并在尖括号内指定目标类型。 <strong>&lt;类型&gt;值</strong></li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let value: any = &quot;Hello&quot;;</span></span>
<span class="line"><span>let len: number = (&lt;string&gt;value).length;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(len); // 输出: 5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在上面的示例中，我们将变量 value 的类型断言为 string 类型，然后使用 .length 属性获取字符串的长度。</p><ol start="2"><li><strong>as 语法：</strong> 使用 as 关键字，在值后面跟上目标类型。<strong>值 as 类型</strong></li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let value: any = &quot;Hello&quot;;</span></span>
<span class="line"><span>let len: number = (value as string).length;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(len); // 输出: 5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在上面的示例中，我们使用 as 关键字将变量 value 的类型断言为 string 类型，并用 length 属性获取字符串的长度。</p><p>以上两种语法虽说没有太大的区别，但是我们<strong>更推荐使用 as 语法</strong>。因为尖括号格式会与 react 中 JSX 产生语法冲突。</p><h2 id="_3-任何类型可以断言为-any-类型" tabindex="-1">3. 任何类型可以断言为 any 类型 <a class="header-anchor" href="#_3-任何类型可以断言为-any-类型" aria-label="Permalink to &quot;3\. 任何类型可以断言为 any 类型&quot;">​</a></h2><p>由于 any 类型可以接收任何值，因此任何类型都可以断言为 any 类型。这样的断言并不提供更多的类型检查，因此在使用类型断言时需要谨慎。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f859b5c75594d4b97b650ca5e4d7599~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=602&amp;h=242&amp;s=32697&amp;e=png&amp;b=202020" alt=""></p><p>上面的例子中，数字类型的变量 foo 上是没有 length 属性的，故 TypeScript 给出了相应的错误提示。</p><p>这种错误提示显然是非常有用的。</p><p>但有的时候，我们非常确定这段代码不会出错，比如下面这个例子：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ca365dd9293413390ee5998b7190017~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=844&amp;h=204&amp;s=33883&amp;e=png&amp;b=282829" alt=""></p><p>上面的示例中，我们需要将 window 上添加一个属性 bar，但 TypeScript 编译时会报错，提示我们 window 上不存在 属性 bar。</p><p>此时我们可以使用 as any 临时将 window 断言为 any 类型：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>(window as any).bar = 1;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="_4-any-类型可以断言为任何类型" tabindex="-1">4. any 类型可以断言为任何类型 <a class="header-anchor" href="#_4-any-类型可以断言为任何类型" aria-label="Permalink to &quot;4\. any 类型可以断言为任何类型&quot;">​</a></h2><p>与上述情况相反，由于 any 类型可以接收任何值，它可以被断言为任何类型。这样的断言会跳过类型检查，因此潜在的类型错误可能发生。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let x: any = &quot;Echo&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let y: number = x as number; // 将 any 类型断言为 number 类型</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_5-联合类型的类型断言" tabindex="-1">5. 联合类型的类型断言 <a class="header-anchor" href="#_5-联合类型的类型断言" aria-label="Permalink to &quot;5\. 联合类型的类型断言&quot;">​</a></h2><p>当变量具有联合类型时，我们可以通过类型断言将其断言为其中的一个类型，但是必须确保断言的类型是变量实际上可以具备的类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let value: string | number = &quot;Echo&quot;;</span></span>
<span class="line"><span>let length: number = (value as string).length; // 类型断言为 string 类型</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_6-类型断言的限制" tabindex="-1">6. 类型断言的限制 <a class="header-anchor" href="#_6-类型断言的限制" aria-label="Permalink to &quot;6\. 类型断言的限制&quot;">​</a></h2><h3 id="_6-1-类型断言不会改变变量的实际类型" tabindex="-1">6.1. 类型断言不会改变变量的实际类型 <a class="header-anchor" href="#_6-1-类型断言不会改变变量的实际类型" aria-label="Permalink to &quot;6.1. 类型断言不会改变变量的实际类型&quot;">​</a></h3><p>类型断言只是告诉编译器将一个值视为特定类型，并不会改变该值的实际类型。在运行时，类型断言不会影响变量的值或行为，它只是在编译时起作用。</p><h3 id="_6-2-类型断言不能用于基本类型之间的转换" tabindex="-1">6.2. 类型断言不能用于基本类型之间的转换 <a class="header-anchor" href="#_6-2-类型断言不能用于基本类型之间的转换" aria-label="Permalink to &quot;6.2. 类型断言不能用于基本类型之间的转换&quot;">​</a></h3><p>TypeScript 的类型断言不能用于将基本类型（如 number、string、boolean）相互转换。因为基本类型具有明确的类型判断和行为，不能将一个基本类型断言为另一个基本类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let x: number = 5;</span></span>
<span class="line"><span>let y: string = x as string; // 错误，不能将 number 类型断言为 string 类型</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_6-3-类型断言不能覆盖类型检查" tabindex="-1">6.3. 类型断言不能覆盖类型检查 <a class="header-anchor" href="#_6-3-类型断言不能覆盖类型检查" aria-label="Permalink to &quot;6.3. 类型断言不能覆盖类型检查&quot;">​</a></h3><p>类型断言可以绕过编译器的类型检查，但并不意味着我们可以随意断言任何类型。如果发生类型断言与变量的实际类型不匹配的情况，可能会导致运行时错误。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e56d8471ffa42a48691322d8b80c6df~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1646&amp;h=180&amp;s=54119&amp;e=png&amp;b=202020" alt=""></p><h3 id="_6-4-类型断言不能将-null-或-undefined-断言为其他类型" tabindex="-1">6.4. 类型断言不能将 null 或 undefined 断言为其他类型 <a class="header-anchor" href="#_6-4-类型断言不能将-null-或-undefined-断言为其他类型" aria-label="Permalink to &quot;6.4. 类型断言不能将 null 或 undefined 断言为其他类型&quot;">​</a></h3><p>因为 null 和 undefined 可以被赋值给任何类型，将它们断言为其他类型是没有意义的。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let x: null = null;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let y: number = x as number; // 错误，不能将 null 断言为 number 类型</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_6-5-联合类型的类型断言存在类型互相排斥的限制" tabindex="-1">6.5. 联合类型的类型断言存在类型互相排斥的限制 <a class="header-anchor" href="#_6-5-联合类型的类型断言存在类型互相排斥的限制" aria-label="Permalink to &quot;6.5. 联合类型的类型断言存在类型互相排斥的限制&quot;">​</a></h3><p>如果将一个变量断言为联合类型中某个类型，那么它必须是该联合类型中的实际类型之一。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let value: string | number = &quot;Echo&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let len: number = (value as string).length; // 正确，因为 value 的实际类型可以为 string</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let size: number = (value as number).toFixed(2); // 错误，value 的实际类型不是 number</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_7-双重断言" tabindex="-1">7. 双重断言 <a class="header-anchor" href="#_7-双重断言" aria-label="Permalink to &quot;7\. 双重断言&quot;">​</a></h2><p>双重断言（Double Assertion），也被称为双重类型断言或连续类型断言，是一种在 TypeScript 中连续使用类型断言的技术。它是将一个值断言为多个类型的一种尝试，尽管这种用法并不被 TypeScript 官方鼓励使用，因为它可能产生不可预测的结果。</p><p>双重断言的形式是使用连续的类型断言操作符 <strong>as</strong> 或尖括号 <strong>&lt;&gt;</strong> 来表示：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let value: any = &quot;Echo&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let len: number = (value as any as string).length;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上述示例中，我们连续使用了两次类型断言，将值 value 先断言为 any 类型，然后再将其断言为 string 类型，并使用 length 属性获取字符串的长度。但是需要注意的是，尽管代码通过了编译，但是这种双重断言的方法并不安全，因为它可以导致类型错误和运行时错误。</p><p>使用双重断言可能会隐藏类型错误，因为类型断言是编译时的操作，而不是运行时。在运行时，双重断言可能会导致意外的类型转换错误，并且编译器无法为此提供任何保护。</p><p>所以，在实际开发中，应尽量避免使用双重断言。如果需要使用多个类型，而无法使用更安全的方法来表示，可以考虑重构代码，使用更合适的类型来处理多种情况，或者使用类型守卫和类型判断等 TypeScript 提供的更安全的技术来处理复杂的类型转换或条件判断。</p><h2 id="_8-类型断言-vs-类型转换" tabindex="-1">8. 类型断言 VS 类型转换 <a class="header-anchor" href="#_8-类型断言-vs-类型转换" aria-label="Permalink to &quot;8\. 类型断言 VS 类型转换&quot;">​</a></h2><p>在 TypeScript 中，<strong>类型断言（Type Assertion）</strong> 是一种在编译时告诉编译器一个值的确切类型的方式，它只是一种类型的声明，不会对变量进行真正的类型转换。</p><p>与类型断言相对的是<strong>类型转换（Type Casting）</strong> ，它是将一个值从一种类型转换为另一种类型的实际操作，而不仅仅是告诉编译器某个值的类型。类型转换通常需要在运行时进行，并涉及对值的实际修改。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 类型断言</span></span>
<span class="line"><span>let value: any = &quot;Echo&quot;;</span></span>
<span class="line"><span>let len: number = (value as string).length;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 类型转换</span></span>
<span class="line"><span>let numberValue: any = &quot;26&quot;;</span></span>
<span class="line"><span>let intValue: number = parseInt(numberValue);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在上述示例中，(value as string) 是一种类型断言，告诉编译器将变量 value 视为字符串类型。而 parseInt 是一种类型转换，将字符串类型的 numberValue 转换为整数类型。</p><p>需要注意的是，<strong>类型断言只会在编译时起作用，不会对变量进行实际的类型转换。而类型转换涉及到对变量值的修改，通常发生在运行时。</strong></p><p>尽管类型断言和类型转换在某种程度上可以实现相似的效果，但它们的机制和目的不同。类型断言是为了辅助编译器进行类型推断和类型检查的工具，而类型转换是为了实际修改变量的类型以满足特定需求。因此，在使用类型转换时，需要注意潜在的类型错误和运行时错误，并谨慎处理类型转换的结果。</p><h2 id="_9-类型断言-vs-类型声明" tabindex="-1">9. 类型断言 VS 类型声明 <a class="header-anchor" href="#_9-类型断言-vs-类型声明" aria-label="Permalink to &quot;9\. 类型断言 VS 类型声明&quot;">​</a></h2><p>在 TypeScript 中，<strong>类型断言（Type Assertion）</strong> 是一种在编译时告诉编译器一个值的确切类型的方式，它是开发者主动指定一个变量的类型，并告诉编译器遵循这个类型进行类型检查。通过类型断言，我们可以在某些情况下绕过编译器的类型检查，但这需要开发者对类型的准确性负责，并且存在潜在的类型错误的风险。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let value: any = &quot;Echo&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let len: number = (value as string).length;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上述示例中，(value as string) 是一种类型断言，将变量 value 的类型断言为字符串类型，从而可以安全地访问字符串的 length 属性。</p><p><strong>类型声明（Type Declaration）</strong> 是一种为变量、参数、返回值等明确指定类型的语法，它是用来定义变量的类型，并告诉编译器如何对变量进行类型推断和类型检查。类型声明通常出现在变量声明、函数声明、函数参数、函数返回值等地方，例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let value: string = &quot;Echo&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function greet(name: string): void {</span></span>
<span class="line"><span>  console.log(&quot;Hello, &quot; + name);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在上述示例中，value: string 是对变量 value 进行类型声明，指定其类型为字符串。而 name: string 是对函数参数 name 进行类型声明，指定其类型为字符串。这样可以确保编译器在类型检查时能够发现潜在的类型错误。</p><p>类型声明是 TypeScript 中一种重要的类型系统的特性，它提供了对变量类型的明确说明，使开发者能够编写更加安全和可维护的代码。与类型断言相比，类型声明更加强制，能够更好地帮助开发者在编译时发现类型错误，并提供更好的类型推断和类型检查支持。</p><h2 id="_10-类型断言和泛型" tabindex="-1">10. 类型断言和泛型 <a class="header-anchor" href="#_10-类型断言和泛型" aria-label="Permalink to &quot;10\. 类型断言和泛型&quot;">​</a></h2><p>在 TypeScript 中，<strong>类型断言（Type Assertion）</strong> 是一种在编译时告诉编译器一个值的确切类型的方式，它是开发者主动指定一个变量的类型，并告诉编译器遵循这个类型进行类型检查。通过类型断言，我们可以在某些情况下绕过编译器的类型检查，但这需要开发者对类型的准确性负责，并且存在潜在的类型错误的风险。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let value: any = &quot;Echo&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let len: number = (value as string).length;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上述示例中，(value as string) 是一种类型断言，将变量 value 的类型断言为字符串类型，以便可以安全地访问字符串的 length 属性。</p><p>泛型是一种在定义函数、类或接口时使用类型参数来表示灵活的类型的方式。通过泛型，我们可以在定义时不指定具体类型，而是在使用时根据上下文传入具体的类型。它可以增加代码的重用性和灵活性。例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function toArray&lt;T&gt;(value: T): T[] {</span></span>
<span class="line"><span>  return [value];</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let array: string[] = toArray(&quot;Hello&quot;);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在上述示例中，toArray 是一个泛型函数，使用类型参数 T 来表示数组中的元素类型。通过传入具体的类型 &quot;Hello&quot;，我们可以创建一个字符串类型的数组。</p><p>类型断言和泛型实际上可以一起使用。当我们在处理泛型类型时，有时可能需要对类型进行断言以满足特定的需求。例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function convertToString&lt;T&gt;(value: T): string {</span></span>
<span class="line"><span>  return value as unknown as string;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上述示例中，通过连续使用类型断言，我们将泛型类型 T 先断言为 unknown 类型，然后再断言为字符串类型，将参数 value 转换为字符串类型并返回。</p><p>需要注意的是，在使用类型断言和泛型时，我们要确保类型的安全性和正确性，并避免潜在的类型错误。类型断言可以帮助我们处理一些特殊情况，但要谨慎使用，并确保断言的类型与变量的实际类型相符。泛型则是一种更加灵活和通用的方式来处理不特定类型的代码逻辑。</p><h2 id="九、类-class" tabindex="-1">九、类（class） <a class="header-anchor" href="#九、类-class" aria-label="Permalink to &quot;九、类（class）&quot;">​</a></h2><h2 id="_1-类的定义" tabindex="-1">1. 类的定义 <a class="header-anchor" href="#_1-类的定义" aria-label="Permalink to &quot;1\. 类的定义&quot;">​</a></h2><p>在 TypeScript 中，可以使用 <strong>class</strong> 关键字来定义类。类的定义通常包括成员变量、构造函数、方法等。</p><h2 id="_2-类的基本使用" tabindex="-1">2. 类的基本使用 <a class="header-anchor" href="#_2-类的基本使用" aria-label="Permalink to &quot;2\. 类的基本使用&quot;">​</a></h2><p>类的基本使用主要有以下几个步骤：</p><ol><li><strong>定义类及成员变量：</strong> 使用 <strong>class</strong> 关键字定义一个类，并在类中声明成员变量。</li><li><strong>构造函数：</strong> 使用 <strong>constructor</strong> 方法定义构造函数，用于在创建类的实例时初始化对象的属性。</li><li><strong>方法：</strong> 在类中定义方法，可通过类的实例调用。</li><li><strong>创建类的实例：</strong> 使用 <strong>new</strong> 关键字创建类的实例，并传递构造函数所需的参数。</li><li><strong>访问成员变量和调用方法：</strong> 通过实例对象访问成员变量和调用方法。</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  constructor(name: string, age: number) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>    this.age = age;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  sayHello(): void {</span></span>
<span class="line"><span>    console.log(`Hello, my name is ${this.name} and I&#39;m ${this.age} years old.`);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const p = new Person(&quot;Echo&quot;, 26);</span></span>
<span class="line"><span>console.log(p.name); // 输出：Echo</span></span>
<span class="line"><span>console.log(p.age);  // 输出：26</span></span>
<span class="line"><span>p.sayHello();        // 输出：Hello, my name is Echo and I&#39;m 26 years old.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>在上述示例中：我们使用 class 关键字定义一个名为 Person 的类，并在 Person 类中声明了两个成员变量：name 和 age。接着，我们使用 constructor 方法定义一个构造函数，用于在创建类的实例时初始化对象的属性，构造函数参数 name 和 age 分别用于接收传入的 name 和 age 值，并将其赋给对应的成员变量。然后定义了一个名为 sayHello 的方法，用于打印一个问候语，并使用成员变量 name 和 age。接着，我们使用 new 关键字创建一个 Person 实例 p，然后打印出 name 和 age 的值以及调用 sayHello 方法。</p><h2 id="_3-类的构造函数" tabindex="-1">3. 类的构造函数 <a class="header-anchor" href="#_3-类的构造函数" aria-label="Permalink to &quot;3\. 类的构造函数&quot;">​</a></h2><p>在 TypeScript 类中，构造函数是一种特殊的方法，用于在创建类的实例时进行初始化操作。构造函数使用 <strong>constructor</strong> 关键字来定义，可以接收参数，并在创建对象时调用。</p><h3 id="_3-1-构造函数的基本语法" tabindex="-1">3.1. 构造函数的基本语法 <a class="header-anchor" href="#_3-1-构造函数的基本语法" aria-label="Permalink to &quot;3.1. 构造函数的基本语法&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class ClassName {</span></span>
<span class="line"><span>  constructor(parameter1: Type1, parameter2: Type2, ...) {</span></span>
<span class="line"><span>    // 书写构造函数的逻辑</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在上面的代码中，ClassName 是类的名称，parameter1、parameter2 等表示构造函数的参数名，Type1、Type2 等表示参数的类型。</p><h3 id="_3-2-使用构造函数初始化成员变量" tabindex="-1">3.2. 使用构造函数初始化成员变量 <a class="header-anchor" href="#_3-2-使用构造函数初始化成员变量" aria-label="Permalink to &quot;3.2. 使用构造函数初始化成员变量&quot;">​</a></h3><p>构造函数可以用来初始化类中的成员变量，通过接收构造函数的参数，并将其赋给对应的成员变量。成员变量的声明通常放在类的顶部，而初始化则在构造函数中进行。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  constructor(name: string, age: number) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>    this.age = age;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在上述示例中，构造函数接收 name 和 age 作为参数，并将参数的值分别赋给类中的 name 和 age 成员变量。</p><h3 id="_3-3-创建类的实例并调用构造函数" tabindex="-1">3.3. 创建类的实例并调用构造函数 <a class="header-anchor" href="#_3-3-创建类的实例并调用构造函数" aria-label="Permalink to &quot;3.3. 创建类的实例并调用构造函数&quot;">​</a></h3><p>使用 new 关键字创建类的实例时，构造函数会被自动调用，让我们可以在创建实例的同时进行初始化操作。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const person = new Person(&#39;Echo&#39;, 26);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在上述代码中，我们创建了一个 Person 类的实例 person，并传递了 &#39;Echo&#39; 和 26 作为构造函数的参数。构造函数会将这些参数的值分别赋给 person 实例的 name 和 age 成员变量。</p><h3 id="_3-4-构造函数的可选参数和默认值" tabindex="-1">3.4. 构造函数的可选参数和默认值 <a class="header-anchor" href="#_3-4-构造函数的可选参数和默认值" aria-label="Permalink to &quot;3.4. 构造函数的可选参数和默认值&quot;">​</a></h3><p>构造函数的参数可以设置为可选的，并且可以为参数提供默认值。</p><p>可选参数使用问号（ <strong>?</strong> ）修饰符进行标记，而默认值则使用等号（<strong>=</strong>）进行赋值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  constructor(name: string = &#39;Echo&#39;, age?: number) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>    this.age = age;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建 person 实例，但不传递 name 和 age 参数</span></span>
<span class="line"><span>const person = new Person();</span></span>
<span class="line"><span>console.log(person.name); // 输出：Echo</span></span>
<span class="line"><span>console.log(person.age);  // 输出：undefined</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建 person1 实例，只传递 name 参数</span></span>
<span class="line"><span>const person1 = new Person(&#39;Jee&#39;);</span></span>
<span class="line"><span>console.log(person1.name); // 输出：Jee</span></span>
<span class="line"><span>console.log(person1.age);  // 输出：undefined</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建 person2 实例，同时传递 name 和 age 参数</span></span>
<span class="line"><span>const person2 = new Person(&#39;James&#39;, 35);</span></span>
<span class="line"><span>console.log(person2.name); // 输出：James</span></span>
<span class="line"><span>console.log(person2.age);  // 输出：35</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>在上述示例中，name 参数具有一个默认值 &#39;Echo&#39;，而 age 参数则是可选的。如果在创建实例时不传 name 和 age 参数，那么 name 会输出默认值 &#39;Echo&#39;，而 age 会被设置为 undefined，如果在创建实例时只传递了 name 参数，而没有传递 age 参数，那么 age 也会被设置为 undefined。</p><h3 id="_3-5-调用其他构造函数-构造函数重载" tabindex="-1">3.5 .调用其他构造函数（构造函数重载） <a class="header-anchor" href="#_3-5-调用其他构造函数-构造函数重载" aria-label="Permalink to &quot;3.5 .调用其他构造函数（构造函数重载）&quot;">​</a></h3><p>在一个类中，可以定义多个构造函数，并通过不同的参数配置来进行重载。重载的构造函数之间可以相互调用，使用 <strong>this</strong> 关键字来引用当前类的实例。</p><p>构造函数重载需要定义多个具有不同参数类型和数量的构造函数签名。构造函数签名是指构造函数名称和参数列表，通过这些不同的签名来区分不同的构造函数。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class ClassName {</span></span>
<span class="line"><span>  constructor(parameter1: Type1);</span></span>
<span class="line"><span>  constructor(parameter1: Type1, parameter2: Type2);</span></span>
<span class="line"><span>  constructor(parameter1: Type1, parameter2: Type2, parameter3: Type3);</span></span>
<span class="line"><span>  // ...</span></span>
<span class="line"><span>  constructor(parameter1: Type1, parameter2: Type2, parameter3: Type3, ...) {</span></span>
<span class="line"><span>    // 书写构造函数实现的逻辑</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在上面的示例中，我们定义了三个构造函数签名，每个签名有不同的参数类型和数量，以提供不同的构造函数选项。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  constructor(name: string);</span></span>
<span class="line"><span>  constructor(name: string, age: number);</span></span>
<span class="line"><span>  constructor(name: string, age?: number) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>    if (age) {</span></span>
<span class="line"><span>      this.age = age;</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>      this.age = 0;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const person1 = new Person(&#39;Echo&#39;);</span></span>
<span class="line"><span>const person2 = new Person(&#39;Echo&#39;, 26);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(person1.name, person1.age); // 输出：Echo 0</span></span>
<span class="line"><span>console.log(person2.name, person2.age); // 输出：Echo 26</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>在上述示例中，我们定义了两个构造函数签名，第一个构造函数接收一个 name 参数，第二个构造函数接收一个 name 和一个 age 参数。在构造函数的实现中，根据传递的参数情况，决定是否给 age 成员变量赋值。接着，我们创建了两个实例 person1 和 person2，第一次实例化传递了一个 name 参数，调用了第一个构造函数。第二次实例化传递了一个 name 参数和一个 age 参数，调用了第二个构造函数。</p><p>注意：</p><ul><li>成员初始化（比如 name: string）后，才可以通过 this.name 来访问实例成员。</li><li>需要为构造函数指定类型注解，否则会被隐式推断为 any 类型，构造函数不需要返回值类型。</li></ul><h2 id="_4-类的实例方法" tabindex="-1">4. 类的实例方法 <a class="header-anchor" href="#_4-类的实例方法" aria-label="Permalink to &quot;4\. 类的实例方法&quot;">​</a></h2><p>在 TypeScript 类中，实例方法是定义在类中的成员方法，用于操作和访问类的实例属性，并执行特定的操作。实例方法可以通过类的实例来调用，用于对特定实例进行特定操作。</p><h3 id="_4-1-定义实例方法" tabindex="-1">4.1. 定义实例方法 <a class="header-anchor" href="#_4-1-定义实例方法" aria-label="Permalink to &quot;4.1. 定义实例方法&quot;">​</a></h3><p>实例方法是通过在类中定义普通函数来创建的。语法格式如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class ClassName {</span></span>
<span class="line"><span>  methodName(parameter1: Type1, parameter2: Type2): ReturnType {</span></span>
<span class="line"><span>    // 书写方法的实现逻辑</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在上面的示例中，methodName 是实例方法的名称，parameter1 和 parameter2 是方法的参数，Type1 和 Type2 是参数的类型，ReturnType 是方法的返回类型。</p><h3 id="_4-2-访问实例属性" tabindex="-1">4.2. 访问实例属性 <a class="header-anchor" href="#_4-2-访问实例属性" aria-label="Permalink to &quot;4.2. 访问实例属性&quot;">​</a></h3><p>实例方法可以通过使用 this 关键字直接访问类的实例属性。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>constructor(name: string, age: number) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>    this.age = age;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  sayHello(): void {</span></span>
<span class="line"><span>    console.log(`Hello, my name is ${this.name} and I&#39;m ${this.age} years old.`);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在上述示例中，sayHello 是一个实例方法，它访问了 Person 类的 name 和 age 属性，并在控制台打印出相应的消息。</p><h3 id="_4-3-调用实例方法" tabindex="-1">4.3. 调用实例方法 <a class="header-anchor" href="#_4-3-调用实例方法" aria-label="Permalink to &quot;4.3. 调用实例方法&quot;">​</a></h3><p>实例方法必须通过类的实例来调用。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const person = new Person(&quot;Echo&quot;, 26);</span></span>
<span class="line"><span>person.sayHello(); // 输出：Hello, my name is Echo and I&#39;m 26 years old.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在上述示例中，我们首先创建了一个 Person 类的实例 person，然后使用 person 实例来调用 sayHello 方法。</p><h2 id="_5-类的继承" tabindex="-1">5. 类的继承 <a class="header-anchor" href="#_5-类的继承" aria-label="Permalink to &quot;5\. 类的继承&quot;">​</a></h2><p>类的继承有 2 种方式：</p><ol><li>extends（继承父类）</li><li>implements（实现接口）</li></ol><p>说明：JS 中只有 extends，而 implements 是 TS 提供的。</p><h3 id="_5-1-extends-继承父类" tabindex="-1">5.1. extends（继承父类） <a class="header-anchor" href="#_5-1-extends-继承父类" aria-label="Permalink to &quot;5.1. extends（继承父类）&quot;">​</a></h3><p>当一个类继承另一个类时，它会继承父类的属性和方法，并可以通过重载或添加新的属性和方法来扩展父类。继承使用 <strong>extends</strong> 关键字来建立类之间的关系。</p><h4 id="_5-1-1-定义父类和子类" tabindex="-1">5.1.1. 定义父类和子类 <a class="header-anchor" href="#_5-1-1-定义父类和子类" aria-label="Permalink to &quot;5.1.1. 定义父类和子类&quot;">​</a></h4><p>父类是被继承的类，子类是继承父类的类。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class ParentClass {</span></span>
<span class="line"><span>  // 书写父类的属性和方法</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class ChildClass extends ParentClass {</span></span>
<span class="line"><span>  // 书写子类特有的属性和方法</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在上面的示例中，ParentClass 是父类，ChildClass 是子类，ChildClass 继承了 ParentClass 的属性和方法。</p><h4 id="_5-1-2-继承父类的属性和方法" tabindex="-1">5.1.2. 继承父类的属性和方法 <a class="header-anchor" href="#_5-1-2-继承父类的属性和方法" aria-label="Permalink to &quot;5.1.2. 继承父类的属性和方法&quot;">​</a></h4><p>使用 <strong>extends</strong> 关键字来建立子类对父类的继承关系。子类会继承父类的公共成员（属性和方法）。子类可以直接访问和使用继承来的属性和方法。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Animal {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  constructor(name: string) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  move(distance: number): void {</span></span>
<span class="line"><span>    console.log(`${this.name} moved ${distance} meters.`);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Dog extends Animal {</span></span>
<span class="line"><span>  bark(): void {</span></span>
<span class="line"><span>    console.log(&quot;Woof! Woof!&quot;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>在上述示例中，Animal 是父类，其中包含了 name 属性和 move 方法。Dog 是子类，使用 extends Animal 建立了继承关系。Dog 继承了 Animal 的属性和方法，并且定义了自己的 bark 方法。</p><h4 id="_5-1-3-调用继承的属性和方法" tabindex="-1">5.1.3. 调用继承的属性和方法 <a class="header-anchor" href="#_5-1-3-调用继承的属性和方法" aria-label="Permalink to &quot;5.1.3. 调用继承的属性和方法&quot;">​</a></h4><p>子类可以直接调用继承来的父类属性和方法，也可以访问自己定义的属性和方法。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const dog = new Dog(&quot;Hate&quot;);</span></span>
<span class="line"><span>dog.move(10);   // 调用继承来自父类的方法 输出：Hate moved 10 meters.</span></span>
<span class="line"><span>dog.bark();     // 调用子类自己定义的方法 输出：Woof! Woof!</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上述示例中，我们首先创建了一个 Dog 类的实例 dog。我们可以通过 dog 实例调用继承自父类的 move 方法，也可以调用子类自己定义的 bark 方法。</p><h3 id="_5-2-implements-实现接口" tabindex="-1">5.2. implements（实现接口） <a class="header-anchor" href="#_5-2-implements-实现接口" aria-label="Permalink to &quot;5.2. implements（实现接口）&quot;">​</a></h3><p>接口的实现是以类为基础的，类可以通过 <strong>implements</strong> 关键字实现一个或多个接口。通过实现接口，类必须提供接口中定义的所有属性和方法的具体实现。</p><h4 id="_5-2-1-定义接口" tabindex="-1">5.2.1. 定义接口 <a class="header-anchor" href="#_5-2-1-定义接口" aria-label="Permalink to &quot;5.2.1. 定义接口&quot;">​</a></h4><p>接口是一种抽象的类型，定义了一组属性和方法的规范。接口在定义时不包含具体的实现，而是描述了类应具备的特定行为和功能。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface InterfaceName {</span></span>
<span class="line"><span>  // 书写接口的属性和方法</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上面的示例中，InterfaceName 是一个接口，用于定义属性和方法的规范。</p><h4 id="_5-2-2-使用-implements-实现接口" tabindex="-1">5.2.2. 使用 implements 实现接口 <a class="header-anchor" href="#_5-2-2-使用-implements-实现接口" aria-label="Permalink to &quot;5.2.2. 使用 implements 实现接口&quot;">​</a></h4><p>使用 implements 关键字来实现接口，使得类能够满足接口定义的规范。通过实现接口，类必须提供接口中定义的所有属性和方法的具体实现。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class ClassName implements InterfaceName {</span></span>
<span class="line"><span>  // 书写类的属性和方法的具体实现</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上述示例中，ClassName 是一个类，通过 implements InterfaceName 实现了接口 InterfaceName，从而满足了接口定义的规范。</p><h4 id="_5-2-3-实现接口的属性和方法" tabindex="-1">5.2.3. 实现接口的属性和方法 <a class="header-anchor" href="#_5-2-3-实现接口的属性和方法" aria-label="Permalink to &quot;5.2.3. 实现接口的属性和方法&quot;">​</a></h4><p>实现接口的类必须包含接口中定义的所有属性和方法，并提供它们的具体实现。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Shape {</span></span>
<span class="line"><span>  color: string;</span></span>
<span class="line"><span>  getArea(): number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Circle implements Shape {</span></span>
<span class="line"><span>  radius: number;</span></span>
<span class="line"><span>  color: string;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  constructor(radius: number, color: string) {</span></span>
<span class="line"><span>    this.radius = radius;</span></span>
<span class="line"><span>    this.color = color;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  getArea(): number {</span></span>
<span class="line"><span>    return Math.PI * this.radius * this.radius;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const circle = new Circle(10, &#39;blue&#39;);</span></span>
<span class="line"><span>const area = circle.getArea();</span></span>
<span class="line"><span>console.log(area); // 输出：314.1592653589793</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>在上面的示例中，Shape 是一个接口，定义了属性 color 和方法 getArea()。Circle 类通过 implements Shape 实现了接口 Shape，并提供了接口中定义的属性和方法的具体实现。</p><h2 id="_6-类的修饰符" tabindex="-1">6. 类的修饰符 <a class="header-anchor" href="#_6-类的修饰符" aria-label="Permalink to &quot;6\. 类的修饰符&quot;">​</a></h2><p>在 TypeScript 中，类的修饰符用于控制类的成员（属性和方法）的可见性和访问权限。</p><p>类的修饰符包括：</p><ol><li>public（公有的），可以在任何地方被访问到，默认所有的属性和方法都是 public 的。</li><li>privete（私有的），不能在声明它的类的外部访问。</li><li>protected（受保护的），和 private 类似，区别是它在子类中也是允许被访问的。</li></ol><h3 id="_6-1-public" tabindex="-1">6.1. public <a class="header-anchor" href="#_6-1-public" aria-label="Permalink to &quot;6.1. public&quot;">​</a></h3><p>public 关键字是默认的访问修饰符，如果不指定修饰符，默认为 public。公共成员在类的内部和外部都是可见的，并且可以随时访问。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Person {</span></span>
<span class="line"><span>  public name: string;</span></span>
<span class="line"><span>  public age: number;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  public constructor(name: string, age: number) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>    this.age = age;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  public sayHello(): void {</span></span>
<span class="line"><span>    console.log(`Hello, my name is ${this.name} and I&#39;m ${this.age} years old.`);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const person = new Person(&quot;Echo&quot;, 26);</span></span>
<span class="line"><span>console.log(person.name); // 输出：ECho</span></span>
<span class="line"><span>person.sayHello();        // 输出：Hello, my name is Echo and I&#39;m 26 years old.</span></span>
<span class="line"><span>person.name = &quot;James&quot;;</span></span>
<span class="line"><span>console.log(person.name); // 输出：James</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>在上述示例中，name、age 和 sayHello() 都是公共成员，可以在类的内部和外部进行访问。</p><h3 id="_6-2-private" tabindex="-1">6.2. private <a class="header-anchor" href="#_6-2-private" aria-label="Permalink to &quot;6.2. private&quot;">​</a></h3><p>private 关键字修饰符限制成员的访问范围仅在类的内部。私有成员在类的外部不可见，只能在类的内部进行访问。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Person {</span></span>
<span class="line"><span>  private name: string;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  constructor(name: string) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  public sayHello(): void {</span></span>
<span class="line"><span>    console.log(`Hello, my name is ${this.name}.`);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const person = new Person(&quot;Echo&quot;);</span></span>
<span class="line"><span>person.sayHello();        // 输出：Hello, my name is Echo.</span></span>
<span class="line"><span>console.log(person.name); // 报错：属性“name”为私有属性，只能在类“Person”中访问</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>在上述示例中，成员 name 是私有成员，只能在类的内部进行访问，外部访问会报错。</p><p><strong>注意：1. 使用 private 修饰的属性或方法，在子类中也是不允许访问的。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Animal {</span></span>
<span class="line"><span>  private name: string;</span></span>
<span class="line"><span>  public constructor(name: string) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Dog extends Animal {</span></span>
<span class="line"><span>  constructor(name: string) {</span></span>
<span class="line"><span>    super(name);</span></span>
<span class="line"><span>    console.log(this.name); // 报错：属性“name”为私有属性，只能在类“Animal”中访问</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>注意：2. 当构造函数修饰为 private 时，该类不允许被继承或者实例化。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Animal {</span></span>
<span class="line"><span>  public name: string;</span></span>
<span class="line"><span>  private constructor(name: string) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>class Dog extends Animal { // 报错：无法扩展类“Animal”，类构造函数标记为私有</span></span>
<span class="line"><span>  constructor(name: string) {</span></span>
<span class="line"><span>    super(name);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const dog = new Animal(&#39;Hate&#39;); // 报错：类“Animal”的构造函数是私有的，仅可在类声明中访问。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="_6-3-protected" tabindex="-1">6.3. protected <a class="header-anchor" href="#_6-3-protected" aria-label="Permalink to &quot;6.3. protected&quot;">​</a></h3><p>protected 关键字修饰符限制成员的访问范围在类的内部及其派生类中。受保护成员在类的外部不可见，但可以在类的内部和派生类中进行访问。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Animal {</span></span>
<span class="line"><span>  protected name: string;</span></span>
<span class="line"><span>  public constructor(name: string) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Dog extends Animal {</span></span>
<span class="line"><span>  constructor(name: string) {</span></span>
<span class="line"><span>    super(name);</span></span>
<span class="line"><span>    console.log(this.name); // 输出：Hate</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const dog = new Dog(&#39;Hate&#39;);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>注意：<strong>当构造函数修饰为 protected 时，该类只允许被继承。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Animal {</span></span>
<span class="line"><span>  public name: string;</span></span>
<span class="line"><span>  protected constructor(name: string) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>class Dog extends Animal {</span></span>
<span class="line"><span>  constructor(name: string) {</span></span>
<span class="line"><span>    super(name);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const dog = new Animal(&#39;Hate&#39;); // 报错：类“Animal”的构造函数是受保护的，仅可在类声明中访问</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="_6-4-readonly" tabindex="-1">6.4. readonly <a class="header-anchor" href="#_6-4-readonly" aria-label="Permalink to &quot;6.4. readonly&quot;">​</a></h3><p>readonly 是一个只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Person {</span></span>
<span class="line"><span>  readonly name: string;</span></span>
<span class="line"><span>  constructor(name: string) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let person = new Person(&#39;Echo&#39;);</span></span>
<span class="line"><span>console.log(person.name); // 输出：Echo</span></span>
<span class="line"><span>person.name = &#39;James&#39;;    // 报错：无法为“name”赋值，因为它是只读属性</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>注意：<strong>如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Person {</span></span>
<span class="line"><span>  // public readonly name: string;</span></span>
<span class="line"><span>  public constructor(public readonly name: string) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>readonly 只读属性特点：</p><ul><li>只读属性必须在声明时或索引签名或构造函数内进行初始化赋值。</li><li>只读属性不能被重新赋值或修改，否则会报错。</li><li><strong>只能修饰属性，不能修饰方法。</strong></li></ul><p>只读属性和常量的区别：</p><ul><li>只读属性是 TypeScript 提供的一种语法，用于将类的属性标记为只读，并且只有在类的内部可以修改其值。</li><li>常量通常是通过 const 关键字声明的，在任何地方都无法修改其值，包括类的内部。</li></ul><h3 id="_6-5-参数属性" tabindex="-1">6.5. 参数属性 <a class="header-anchor" href="#_6-5-参数属性" aria-label="Permalink to &quot;6.5. 参数属性&quot;">​</a></h3><p>参数属性是一种简化代码的语法糖，用于在构造函数中同时声明和初始化类的成员属性。使用参数属性可以在一个地方完成属性的声明和赋值，减少了重复的代码。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Person {</span></span>
<span class="line"><span>  constructor(public name: string, private age: number, protected sex: string, public readonly height: number) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>    this.age = age;</span></span>
<span class="line"><span>    this.sex = sex;</span></span>
<span class="line"><span>    this.height = height;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const person = new Person(&#39;Echo&#39;, 26, &#39;male&#39;, 1.7);</span></span>
<span class="line"><span>console.log(person.name);   // 输出：Echo</span></span>
<span class="line"><span>console.log(person.age);    // 报错：属性“age”为私有属性，只能在类“Person”中访问</span></span>
<span class="line"><span>console.log(person.sex);    // 报错：属性“sex”受保护，只能在类“Person”及其子类中访问</span></span>
<span class="line"><span>console.log(person.height); // 输出：1.7</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>在上述示例中，定义了一个名为 Person 的类，类里面定义了一个 constructor 构造方法，其中参数 name 是公共属性，可以在类的内部和外部访问；参数 age 是私有属性，只能在类 Person 中访问；参数 sex 是受保护属性，只能在类 Person 及其子类中访问；参数 height 是只读属性，类的外部无法修改其值。</p><h2 id="_7-抽象类" tabindex="-1">7. 抽象类 <a class="header-anchor" href="#_7-抽象类" aria-label="Permalink to &quot;7\. 抽象类&quot;">​</a></h2><p>使用关键字 <strong>abstract</strong> 用于定义抽象类和其中的抽象方法。</p><p>抽象类是一种不能直接实例化的类，它主要用作其他类的基类。抽象类可以包含抽象方法和具体方法的定义，供子类继承和实现。</p><h3 id="_7-1-语法" tabindex="-1">7.1. 语法 <a class="header-anchor" href="#_7-1-语法" aria-label="Permalink to &quot;7.1. 语法&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>abstract class AbstractClass {</span></span>
<span class="line"><span>  abstract method(): void; // 抽象方法</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  concreteMethod(): void {</span></span>
<span class="line"><span>    console.log(&quot;This is a concrete method&quot;); // 具体方法</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在上述示例中，AbstractClass 是一个抽象类，它包含了一个抽象方法 method() 和一个具体方法 concreteMethod()。</p><h3 id="_7-2-抽象方法" tabindex="-1">7.2. 抽象方法 <a class="header-anchor" href="#_7-2-抽象方法" aria-label="Permalink to &quot;7.2. 抽象方法&quot;">​</a></h3><p>抽象方法是在抽象类中声明但没有具体实现的方法。它只包含方法的签名，没有方法体，<strong>子类必须实现抽象方法。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>abstract class Animal {</span></span>
<span class="line"><span>  constructor(public name: string) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  abstract sayHi();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Cat extends Animal {</span></span>
<span class="line"><span>  sayHi() {</span></span>
<span class="line"><span>    console.log(this.name); // 输出：Tom</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let cat = new Cat(&#39;Tom&#39;);</span></span>
<span class="line"><span>cat.sayHi();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>在上述示例中，抽象类 Animal 中的 sayHi() 是一个抽象方法，子类 Cat 继承了 父类 Animal 并实现了抽象方法。</p><h3 id="_7-3-抽象类不能被实例化-只能被继承" tabindex="-1">7.3. 抽象类不能被实例化，只能被继承 <a class="header-anchor" href="#_7-3-抽象类不能被实例化-只能被继承" aria-label="Permalink to &quot;7.3. 抽象类不能被实例化，只能被继承&quot;">​</a></h3><p>抽象类不能被实例化，只能被继承。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>abstract class Animal {</span></span>
<span class="line"><span>  constructor(public name: string) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  abstract sayHi();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let cat = new Animal(&#39;Tom&#39;); // 报错：无法创建抽象类的实例</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_7-4-特点" tabindex="-1">7.4. 特点 <a class="header-anchor" href="#_7-4-特点" aria-label="Permalink to &quot;7.4. 特点&quot;">​</a></h3><ul><li>抽象类不能被实例化，只能被继承。</li><li>抽象类可以包含抽象方法和具体方法的定义。</li><li>子类必须实现抽象类中的所有抽象方法，否则子类也必须声明为抽象类。</li><li>如果一个类继承了一个抽象类，那么它必须实现抽象类中的抽象方法，除非它自身也声明为抽象类。</li><li>抽象类可以作为其他类的基类，用于提供共享的属性和方法定义。</li></ul><h2 id="十、类型兼容性" tabindex="-1">十、类型兼容性 <a class="header-anchor" href="#十、类型兼容性" aria-label="Permalink to &quot;十、类型兼容性&quot;">​</a></h2><p>类型兼容性是指在 TS 中，如何判断一个类型是否能够赋值给另一个类型。</p><h2 id="_1-基本类型的兼容性" tabindex="-1">1. 基本类型的兼容性 <a class="header-anchor" href="#_1-基本类型的兼容性" aria-label="Permalink to &quot;1\. 基本类型的兼容性&quot;">​</a></h2><h3 id="_1-1-相同的基本类型可以互相赋值" tabindex="-1">1.1. 相同的基本类型可以互相赋值 <a class="header-anchor" href="#_1-1-相同的基本类型可以互相赋值" aria-label="Permalink to &quot;1.1. 相同的基本类型可以互相赋值&quot;">​</a></h3><p>当你声明一个变量并为其赋予一个特定类型的值时，TypeScript 会根据类型注解进行类型检查和推断。如果变量的类型与给定的值的类型完全匹配，那么它们可以互相赋值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let a: number = 10;</span></span>
<span class="line"><span>let b: number = a;</span></span>
<span class="line"><span>console.log(a, b); // 输出 10, 10</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上述示例中，变量 a 被声明为 number 类型，并且被赋值为 10。 然后将变量 a 赋值给变量 b，因为 a 和 b 的类型相同，都是 number，所以赋值是允许的。</p><h3 id="_1-2-数字字面量类型可以赋值给数值类型" tabindex="-1">1.2. 数字字面量类型可以赋值给数值类型 <a class="header-anchor" href="#_1-2-数字字面量类型可以赋值给数值类型" aria-label="Permalink to &quot;1.2. 数字字面量类型可以赋值给数值类型&quot;">​</a></h3><p>当你声明一个变量并为其指定为数字字面量类型时，TypeScript 会将该变量视为一个特定的数字值，而不仅仅是一般的数值类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let a: 10 = 10;</span></span>
<span class="line"><span>let b: number = a;</span></span>
<span class="line"><span>console.log(a, b); // 输出 10, 10</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在这个示例中，变量 a 被声明为数字字面量类型 10，它只能具有值 10，而不能是其它的值。然后将变量 a 赋值给变量 b，因为 b 的类型是 number，而 a 是数字字面量类型 5，数字字面量类型是数字类型的子类型，所以赋值是允许的。</p><p>需要注意的是，只有字面量类型才可以赋值给相应的数值类型，普通数值类型不能赋值给字面量类型，除非两者完全匹配。</p><h3 id="_1-3-枚举类型可以赋值给数字类型" tabindex="-1">1.3. 枚举类型可以赋值给数字类型 <a class="header-anchor" href="#_1-3-枚举类型可以赋值给数字类型" aria-label="Permalink to &quot;1.3. 枚举类型可以赋值给数字类型&quot;">​</a></h3><p>枚举类型在 TypeScript 中被编译成了一个具有反向映射的对象。默认情况下，枚举类型的成员值是从 0 开始递增的数字。由于枚举成员值是数字类型，所以它们可以被赋值给数字类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>enum Direction {</span></span>
<span class="line"><span>  Up,</span></span>
<span class="line"><span>  Right,</span></span>
<span class="line"><span>  Down,</span></span>
<span class="line"><span>  Left</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>let direction: Direction = Direction.Right;</span></span>
<span class="line"><span>let num: number = direction;</span></span>
<span class="line"><span>console.log(direction, num); // 输出：1, 1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在上述示例中，将 Direction.Right 赋值给了枚举类型的变量 direction，然后又将 direction 赋值给了数字类型的变量 num，此时 num 的值为 1，与 Direction.Right 对应的枚举成员值相同。</p><p>需要注意的是，枚举类型不仅可以赋值给数字类型，也可以赋值给字面量类型或其他兼容的类型。这主要是由于 TypeScript 在类型系统中对枚举类型进行了特殊处理，使得枚举成员值可以被当作相应的字面量值使用。</p><h2 id="_2-对象类型的兼容性" tabindex="-1">2. 对象类型的兼容性 <a class="header-anchor" href="#_2-对象类型的兼容性" aria-label="Permalink to &quot;2\. 对象类型的兼容性&quot;">​</a></h2><p>对象类型包括接口（interface）、类（class）、字面量对象等。</p><p>记住这句话：<strong>成员多的可以赋值给成员少的。</strong></p><h3 id="_2-1-成员个数的兼容性" tabindex="-1">2.1. 成员个数的兼容性 <a class="header-anchor" href="#_2-1-成员个数的兼容性" aria-label="Permalink to &quot;2.1. 成员个数的兼容性&quot;">​</a></h3><p>对象类型 T 能够赋值给对象类型 U，需要满足的条件是 T 中的成员个数要小于等于 U 中的成员个数。也就是说，T 可以拥有 U 中的所有成员，但 U 可能还有额外的成员。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Pont2D {</span></span>
<span class="line"><span>  x: number;</span></span>
<span class="line"><span>  y: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Point3D {</span></span>
<span class="line"><span>  x: number;</span></span>
<span class="line"><span>  y: number;</span></span>
<span class="line"><span>  z: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let p1: Pont2D = { x: 1, y: 2 }</span></span>
<span class="line"><span>let p2: Point3D = { x: 2, y: 3, z: 4 }</span></span>
<span class="line"><span>p1 = p2 // 正确，类 Point3D 拥有类 Point2D 中的所有成员</span></span>
<span class="line"><span>// p2 = p1 // 错误，类型 Point2D 中缺少属性 z，但类型 Point3D 中需要该属性</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>在上述示例中，类 Point2D 具有 x 和 y 成员，类 Point3D 比类 Point2D 多了一个 z 成员，根据兼容性规则，Point3D 可以赋值给 Point2D，因为类 Point3D 拥有类 Point2D 中的所有成员。</p><h3 id="_2-2-成员类型的兼容性" tabindex="-1">2.2. 成员类型的兼容性 <a class="header-anchor" href="#_2-2-成员类型的兼容性" aria-label="Permalink to &quot;2.2. 成员类型的兼容性&quot;">​</a></h3><p>对象类型 T 能够赋值给对象类型 U，需要满足的条件是 T 中的每个成员的类型都能够赋值给 U 中对应成员的类型。这个规则适用于成员变量和成员函数。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Animal {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface Dog {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  breed: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let animal: Animal = { name: &quot;Animal&quot; };</span></span>
<span class="line"><span>let dog: Dog = { name: &quot;Dog&quot;, breed: &quot;Husky&quot; };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>animal = dog; // 正确，Dog 的成员类型包含 Animal 的成员类型</span></span>
<span class="line"><span>// dog = animal; // 错误，类型 Animal 中缺少属性 breed，但类型 Dog 中需要该属性</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_2-3-可选属性的兼容性" tabindex="-1">2.3. 可选属性的兼容性 <a class="header-anchor" href="#_2-3-可选属性的兼容性" aria-label="Permalink to &quot;2.3. 可选属性的兼容性&quot;">​</a></h3><p>对象类型 T 能够赋值给对象类型 U，如果 U 中定义了可选属性，且 T 中没有对应的属性，则仍然可以进行赋值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age?: number; // 可选属性</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface Employee {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  employeeId: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let person: Person = { name: &quot;Echo&quot;, age: 26 };</span></span>
<span class="line"><span>let employee: Employee = { name: &quot;James&quot;, employeeId: &quot;123&quot; };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>person = employee; // 正确，虽然类型 Employee 中没有 age 属性，但类型 Person 中 age 属性是可选的</span></span>
<span class="line"><span>// employee = person; // 错误，类型 Person 中缺少属性 employeeId, 但类型 Employee 中需要该属性</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_3-函数类型兼容性" tabindex="-1">3. 函数类型兼容性 <a class="header-anchor" href="#_3-函数类型兼容性" aria-label="Permalink to &quot;3\. 函数类型兼容性&quot;">​</a></h2><p>函数之间的兼容性会比较复杂，需要考虑以下几个方面：</p><ul><li>参数个数</li><li>参数类型</li><li>返回值类型</li></ul><h3 id="_3-1-参数个数" tabindex="-1">3.1. 参数个数 <a class="header-anchor" href="#_3-1-参数个数" aria-label="Permalink to &quot;3.1. 参数个数&quot;">​</a></h3><p>源函数的参数个数要小于等于目标函数的参数个数。也就是说，源函数可以接受更少的参数或与目标函数相同数量的参数。多余的参数是允许的，因为在函数调用时可以忽略它们。</p><p>记住这句话：<strong>参数少的可以赋值给参数多的。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type Adder = (a: number, b: number) =&gt; number;</span></span>
<span class="line"><span>type Calculator = (a: number, b: number, c: number) =&gt; number;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let add: Adder = (a: number, b: number) =&gt; a + b;</span></span>
<span class="line"><span>let calculate: Calculator = (a: number, b: number, c: number) =&gt; a + b + c;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>calculate = add; // 正确，Adder 的参数个数少于 Calculator 的参数个数</span></span>
<span class="line"><span>// add = calculate; // 错误，Calculator 的参数个数多于 Adder 的参数个数</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在上述示例中，我们定义了两个类型 Adder 和 Calculator 分别表示加法函数和计算函数。根据函数兼容性规则，add 可以赋值给 calculate，因为 Adder 的参数个数（2 个）少于 Calculator 的参数个数（3 个）。但是相反的赋值会导致兼容性错误，因为 Calculator 的参数个数（3 个）要多于 Adder 的参数个数（2 个）。</p><h3 id="_3-2-参数类型" tabindex="-1">3.2. 参数类型 <a class="header-anchor" href="#_3-2-参数类型" aria-label="Permalink to &quot;3.2. 参数类型&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let x = (a: number) =&gt; 0;</span></span>
<span class="line"><span>let y = (a: number, b: string) =&gt; 0;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>y = x; // 正确</span></span>
<span class="line"><span>// x = y; // 错误</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在上述示例中，函数 x 的参数只有一个 a，类型为 number，函数 y 的参数有两个 a 和 b，类型分别为 number 和 string，x 可以赋值给 y，是因为 x 的每个参数都能在 y 里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 而 y 不能赋值给 x，因为 y 有个必需的第二个参数，但是 x 并没有，所以不允许赋值。</p><h3 id="_3-3-返回值类型" tabindex="-1">3.3. 返回值类型 <a class="header-anchor" href="#_3-3-返回值类型" aria-label="Permalink to &quot;3.3. 返回值类型&quot;">​</a></h3><p>如果返回值类型是普通类型，此时函数的返回值类型要相同。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type F1 = () =&gt; string</span></span>
<span class="line"><span>type F2 = () =&gt; string</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let func1: F1</span></span>
<span class="line"><span>let func2: F2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func1 = func2 // 正确</span></span>
<span class="line"><span>func2 = func1 // 正确</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如果返回值类型是对象类型，此时<strong>成员多的可以赋值给成员少的。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type F3 = () =&gt; { name: string }</span></span>
<span class="line"><span>type F4 = () =&gt; { name: string; age: number }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let func3: F3</span></span>
<span class="line"><span>let func4: F4</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func3 = func4 // 正确</span></span>
<span class="line"><span>func4 = func3 // 错误</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_4-类类型兼容性" tabindex="-1">4. 类类型兼容性 <a class="header-anchor" href="#_4-类类型兼容性" aria-label="Permalink to &quot;4\. 类类型兼容性&quot;">​</a></h2><p>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  constructor(name: string, age: number) {}</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Employee {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  constructor(name: string, age: number, employee: string) {}</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let person: Person;</span></span>
<span class="line"><span>let employee: Employee;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>employee = person; // 正确</span></span>
<span class="line"><span>person = employee; // 正确</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>私有的和受保护的成员必须来自于相同的类或者父类的派生类。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Person {</span></span>
<span class="line"><span>  protected name: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Employee extends Person {}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let person: Person;</span></span>
<span class="line"><span>let employee: Employee;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>employee = person; // 正确</span></span>
<span class="line"><span>person = employee; // 正确</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class User {</span></span>
<span class="line"><span>  protected name: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let user: User;</span></span>
<span class="line"><span>person = user; // 错误</span></span>
<span class="line"><span>user = person; // 错误</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="_5-泛型类型兼容性" tabindex="-1">5. 泛型类型兼容性 <a class="header-anchor" href="#_5-泛型类型兼容性" aria-label="Permalink to &quot;5\. 泛型类型兼容性&quot;">​</a></h2><p>当泛型类型没有明确指定类型参数时，它被认为是一种特殊的兼容性形式，称为类型参数的默认，即泛型函数或泛型类在没有传递类型参数的情况下，它们的类型参数会被推导为 any。此时，泛型类型可以兼容任意类型，也能赋值给其他泛型类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type Box&lt;T&gt; = {</span></span>
<span class="line"><span>  value: T;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let boxA: Box&lt;number&gt;;</span></span>
<span class="line"><span>let boxB: Box&lt;any&gt;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>boxA = boxB; // 正确，类型参数的默认 any 能兼容任意类型</span></span>
<span class="line"><span>boxB = boxA; // 正确，boxA 指定的类型参数是 number，也能赋值给类型参数的默认 any</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>当泛型类型明确指定了类型参数时，要求类型参数具有兼容的类型。这意味着泛型类型在传递不同类型参数时，需要确保它们之间满足兼容性规则。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type Box&lt;T&gt; = {</span></span>
<span class="line"><span>  value: T;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let boxA: Box&lt;number&gt;;</span></span>
<span class="line"><span>let boxB: Box&lt;string&gt;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>boxA = boxB; // 报错，不能将类型 string 分配给类型 number</span></span>
<span class="line"><span>boxB = boxA; // 报错，不能将类型 number 分配给类型 string</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="十一、交叉类型-intersection-types" tabindex="-1">十一、交叉类型（Intersection Types） <a class="header-anchor" href="#十一、交叉类型-intersection-types" aria-label="Permalink to &quot;十一、交叉类型（Intersection Types）&quot;">​</a></h2><p>交叉类型类似于接口继承，是将多个类型合并为一个类型。 也就是说我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p><p>使用符号（ <strong>&amp;</strong> ）来定义交叉类型。</p><h2 id="_1-组合对象类型" tabindex="-1">1. 组合对象类型 <a class="header-anchor" href="#_1-组合对象类型" aria-label="Permalink to &quot;1\. 组合对象类型&quot;">​</a></h2><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type User = {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type Admin = {</span></span>
<span class="line"><span>  isAdmin: boolean;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type UserAdmin = User &amp; Admin;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let userAdmin: UserAdmin = {</span></span>
<span class="line"><span>  name: &quot;John&quot;,</span></span>
<span class="line"><span>  age: 30,</span></span>
<span class="line"><span>  isAdmin: true</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在上述示例中，我们定义了 User 和 Admin 两个类型，然后使用交叉类型 &amp; 将 User &amp; Admin 连接起来创建了一个新的类型 UserAdmin，该类型包含了 User 和 Admin 类型的所有成员，接着我们定义了一个变量 userAdmin，该变量同时具有 User 和 Admin 类型的属性和方法。</p><h2 id="_2-合并函数类型" tabindex="-1">2. 合并函数类型 <a class="header-anchor" href="#_2-合并函数类型" aria-label="Permalink to &quot;2\. 合并函数类型&quot;">​</a></h2><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type AddFunc = {</span></span>
<span class="line"><span>  fn: (a: number, b: number) =&gt; number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>type MultiplyFunc = {</span></span>
<span class="line"><span>  fn1: (a: number, b: number) =&gt; number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type MathOperations = AddFunc &amp; MultiplyFunc;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const mathOps: MathOperations = {</span></span>
<span class="line"><span>  fn(num1, num2) {</span></span>
<span class="line"><span>    return num1 + num2;</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  fn1(num1, num2) {</span></span>
<span class="line"><span>    return num1 * num2</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(mathOps.fn(10, 20));    // 输出：30</span></span>
<span class="line"><span>console.log(mathOps.fn1(10, 20));   // 输出：200</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>在上述示例中，我们定义了两个函数类型 AddFunc 和 MultiplyFunc，AddFunc 里面定义了 fn 函数，MultiplyFunc 里面定义了 fn1 函数，并使用交叉类型 &amp; 将 AddFunc &amp; MultiplyFunc 连接起来创建了一个新的类型 MathOperations。此时变量 mathOps 同时拥有 fn 和 fn1 两个方法。</p><h2 id="_3-交叉类型-vs-接口继承" tabindex="-1">3. 交叉类型 VS 接口继承 <a class="header-anchor" href="#_3-交叉类型-vs-接口继承" aria-label="Permalink to &quot;3\. 交叉类型 VS 接口继承&quot;">​</a></h2><ul><li>相同点：都可以实现对象类型的组合。</li><li>不同点：两种方式实现类型组合时，对于同名属性之间，处理类型冲突的方式不同。</li></ul><p>下面是接口继承的示例，接口 B 继承接口 A，两个接口都定义了 fn 方法，返回值都是 string 类型，但是参数的类型不同，一个 string，一个 number，由于 fn 参数 value 的类型不兼容，所以接口 B 不能继承接口 A。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface A {</span></span>
<span class="line"><span>  fn: (value: number) =&gt; string</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface B extends A {</span></span>
<span class="line"><span>  fn: (value: string) =&gt; string</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e40ad7c09ed249cdb5fdd194e4c15262~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=715&amp;h=276&amp;s=21931&amp;e=png&amp;b=1f1f1f" alt=""></p><p>下面是交叉类型的示例：我们定义了 A 和 B 两个接口，然后使用交叉类型 &amp; 将 A &amp; B 连接起来创建了一个新的类型 ，接着我们定义了一个变量 c，类型为 C，变量 c 调用 fn 方法，此时参数的类型我们可以传数字类型或者字符串类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface A {</span></span>
<span class="line"><span>  fn: (value: number) =&gt; string</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface B {</span></span>
<span class="line"><span>  fn: (value: string) =&gt; string</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type C = A &amp; B</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let c: C</span></span>
<span class="line"><span>c.fn(1)       // 正确</span></span>
<span class="line"><span>c.fn(&#39;Echo&#39;)  // 正确</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_4-注意" tabindex="-1">4. 注意 <a class="header-anchor" href="#_4-注意" aria-label="Permalink to &quot;4\. 注意&quot;">​</a></h2><p><strong>如果合并的多个接口类型存在同名属性会是什么效果呢？</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type User = {</span></span>
<span class="line"><span>  id: number;</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type Admin = {</span></span>
<span class="line"><span>  name: number;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type UserAdmin = User &amp; Admin</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const user: UserAdmin = {</span></span>
<span class="line"><span>  id: 1,</span></span>
<span class="line"><span>  // name: &quot;Echo&quot;, // 错误：不能将类型“string”分配给类型“never”</span></span>
<span class="line"><span>  name: 26, // 错误：不能将类型“number”分配给类型“never”</span></span>
<span class="line"><span>  age: 26</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>在上面示例中，定义了两个类型 User 和 Admin，其中类型 User 中有 id 和 name 属性，类型 Admin 中有 name 和 age 属性，两个类型都有同名的 name 属性，但类型不同，一个是 string，一个是 number，合并后，name 属性的类型就是 string 和 number 两个原子类型的交叉类型，即 never。</p><p>此时，我们如果赋予 user 任意类型的 name 属性值都会提示类型错误。而如果我们不设置 name 属性，又会提示一个缺少必选的 name 属性的错误。在这种情况下，就意味着上述代码中交叉出来的 UserAdmin 类型是一个无用类型。</p><p><strong>如果同名属性的类型兼容，比如一个是 number，另一个是 number 的子类型、数字字面量类型，合并后 name 属性的类型就是两者中的子类型。</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type User = {</span></span>
<span class="line"><span>  id: number;</span></span>
<span class="line"><span>  name: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type Admin = {</span></span>
<span class="line"><span>  name: 2;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type UserAdmin = User &amp; Admin</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const user: UserAdmin = {</span></span>
<span class="line"><span>  id: 1,</span></span>
<span class="line"><span>  // name: 2, // 正确</span></span>
<span class="line"><span>  name: 22,  // 错误：不能将类型“22”分配给类型“2”</span></span>
<span class="line"><span>  age: 26</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>在上面示例中，name 属性的类型就是数字字面量类型 2，因此，我们不能把任何非 2 之外的值赋予 name 属性。</p><p><strong>如果交叉类型中的某个成员是对象类型，那么交叉后的类型将拥有这些对象类型的所有属性</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface A {</span></span>
<span class="line"><span>  x: {</span></span>
<span class="line"><span>    isShow: boolean</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface B {</span></span>
<span class="line"><span>  x: {</span></span>
<span class="line"><span>    name: string</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface C {</span></span>
<span class="line"><span>  x: {</span></span>
<span class="line"><span>    age: number</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type ABC = A &amp; B &amp; C;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let abc: ABC = {</span></span>
<span class="line"><span>  x: {</span></span>
<span class="line"><span>    isShow: true,</span></span>
<span class="line"><span>    name: &#39;Echo&#39;,</span></span>
<span class="line"><span>    age: 26</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(abc); // 输出：x: { isShow: true, name: &#39;Echo&#39;, age: 26 }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h2 id="十二、泛型-generics" tabindex="-1">十二、泛型（Generics） <a class="header-anchor" href="#十二、泛型-generics" aria-label="Permalink to &quot;十二、泛型（Generics）&quot;">​</a></h2><h2 id="_1-什么是泛型" tabindex="-1">1. 什么是泛型 <a class="header-anchor" href="#_1-什么是泛型" aria-label="Permalink to &quot;1\. 什么是泛型&quot;">​</a></h2><p>泛型（Generics）是 TypeScript 中一种允许我们在定义函数、类或接口时使用参数化类型的机制。泛型可以看作是类型参数，类似于函数中的参数，但是用于表示类型而不是值。它允许我们在定义函数、类或接口时使用占位符表示类型，并在实际使用时指定具体的类型。</p><h2 id="_2-一个简单的例子" tabindex="-1">2. 一个简单的例子 <a class="header-anchor" href="#_2-一个简单的例子" aria-label="Permalink to &quot;2\. 一个简单的例子&quot;">​</a></h2><p>现在我们有个需求：实现一个函数，传入的函数参数是什么类型的，返回值的类型也要跟函数参数的类型相同，并且函数只能接收一个参数，你会怎么做？</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const identity: (value: number) =&gt; number = (value) =&gt; value</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(identity(10)); // 输出：10，类型是number</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面的示例中，我们创建了一个 identity 函数，参数值和返回值类型都为 number，调用 identity 函数，传入一个数字，会返回数字本身。但是，该函数只能接收数值类型，如果我调用函数的时候传入字符串或者布尔值类型的值，此时就会报错。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const identity: (value: number) =&gt; number = (value) =&gt; value</span></span>
<span class="line"><span>console.log(identity(&#39;Echo&#39;)); // 报错：类型“string”的参数不能赋值给类型“number”的参数</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>为了让函数能够接收任意类型，可以将参数类型改为 any，但是，这样就失去了 TS 的类型保护，类型不安全。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const identity: (value: any) =&gt; any = (value) =&gt; value</span></span>
<span class="line"><span>console.log(identity(&#39;Echo&#39;));    // 输出：Echo</span></span>
<span class="line"><span>console.log(identity(26));        // 输出：26</span></span>
<span class="line"><span>console.log(identity(true));      // 输出：true</span></span>
<span class="line"><span>console.log(identity(null));      // 输出：null</span></span>
<span class="line"><span>console.log(identity(undefined)); // 输出：undefined</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>为了解决上面的这些问题，我们<strong>使用泛型对上面的代码进行重构。</strong> 泛型在保证类型安全（不丢失类型信息）的同时，可以让函数等于多钟不同的类型一起工作，灵活可复用。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function identity&lt;T&gt;(value: T): T {</span></span>
<span class="line"><span>  return value;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(identity&lt;string&gt;(&#39;Echo&#39;));   // 输出：Echo</span></span>
<span class="line"><span>console.log(identity&lt;number&gt;(26));       // 输出：26</span></span>
<span class="line"><span>console.log(identity&lt;boolean&gt;(true));    // 输出：true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>上面示例中，我们在函数名 identity 后添加了 ，其中 T 代表 Type，在定义泛型时通常用作第一个类型变量名称。但实际上 T 可以用任何有效名称代替。在调用函数 identity 时，在&lt;&gt;中指定类型 string，此时参数和返回值类型也都为 string。</p><h2 id="_3-泛型语法" tabindex="-1">3. 泛型语法 <a class="header-anchor" href="#_3-泛型语法" aria-label="Permalink to &quot;3\. 泛型语法&quot;">​</a></h2><ul><li>在函数名称的后面添加尖括号（ <strong>&lt;&gt;</strong> ）,尖括号中添加类型变量，比如下图中的 <strong>T。</strong></li><li>其中 T 代表 Type，可以是任意合法的变量名称。</li><li>类型变量 T，是一种特殊类型的变量，它用于处理类型而不是值。</li><li>该类型变量相当于一个类型容器，能够捕获用户提供的类型（具体是什么类型，由用户调用该函数时指定）。</li><li>因为 T 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型。</li></ul><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function identity&lt;T&gt;(value: T): T {</span></span>
<span class="line"><span>  return value;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在下面的示例中，调用泛型函数 identity，当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 T 捕获到，此时，T 的类型就是 number，所以，函数 identity 的参数和返回值的类型也都是 number。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3145dc86a30847d6ad1a9861ade96d39~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=486&amp;h=108&amp;s=8021&amp;e=png&amp;b=1f1f1f" alt=""></p><h2 id="_4-简化调用泛型函数" tabindex="-1">4. 简化调用泛型函数 <a class="header-anchor" href="#_4-简化调用泛型函数" aria-label="Permalink to &quot;4\. 简化调用泛型函数&quot;">​</a></h2><ul><li>在调用泛型函数时，可以<strong>省略&lt;类型&gt;来简化泛型函数的调用</strong>。</li><li>此时，TS 内部会采用一种叫做类型参数推断的机制，来根据传入的实参自动推断出类型变量 T 的类型。</li><li>当编译器无法推断类型或者推断的类型不准确时，就需要显示地传入类型参数。</li></ul><p>比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 T 的类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function identity&lt;T&gt;(value: T): T {</span></span>
<span class="line"><span>  return value;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b0f62fd2ec44667b04d7cec25666ea8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=294&amp;h=109&amp;s=5215&amp;e=png&amp;b=1e1e1e" alt=""></p><h2 id="_5-多个类型参数" tabindex="-1">5. 多个类型参数 <a class="header-anchor" href="#_5-多个类型参数" aria-label="Permalink to &quot;5\. 多个类型参数&quot;">​</a></h2><p>定义泛型的时候，可以一次定义多个类型参数：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] {</span></span>
<span class="line"><span>  return [tuple[1], tuple[0]];</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(swap([&#39;Echo&#39;, 26])); // [26, &#39;Echo]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上述示例中，我们定义了一个 swap 函数，用来交换输入的元组。</p><h2 id="_6-泛型类" tabindex="-1">6. 泛型类 <a class="header-anchor" href="#_6-泛型类" aria-label="Permalink to &quot;6\. 泛型类&quot;">​</a></h2><p>泛型类（Generic Class）是指在定义类时使用泛型类型参数的类。它允许我们在类的属性、方法、构造函数以及实例化时使用泛型。</p><ul><li>在 class 名称后面添加 <strong>&lt;类型变量&gt;</strong> ，这个类就变成了泛型类。</li><li>在创建 class 实例时，在类名后面通过 <strong>&lt;类型&gt;</strong> 来指定明确的类型。</li></ul><p>下面是一个简单的泛型类的示例：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Container&lt;T&gt; {</span></span>
<span class="line"><span>  private items: T[] = [];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  addItem(item: T) {</span></span>
<span class="line"><span>    this.items.push(item);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  getItem(index: number): T {</span></span>
<span class="line"><span>    return this.items[index];</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  getItems(): T[] {</span></span>
<span class="line"><span>    return this.items;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const container = new Container&lt;number&gt;(); // 实例化一个泛型类，指定类型参数为 number</span></span>
<span class="line"><span>container.addItem(1);</span></span>
<span class="line"><span>container.addItem(2);</span></span>
<span class="line"><span>console.log(container.getItems()); // 输出: [1, 2]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h2 id="_7-泛型接口" tabindex="-1">7. 泛型接口 <a class="header-anchor" href="#_7-泛型接口" aria-label="Permalink to &quot;7\. 泛型接口&quot;">​</a></h2><ul><li>在接口名称的后面添加 <strong>&lt;类型变量&gt;</strong> ，那么，这个接口就变成了泛型接口。</li><li>接口的类型变量，对接口中所有其它成员可见，也就是<strong>接口中所有成员都可以使用类型变量。</strong></li><li>使用泛型接口时，需要显示指定具体的类型。</li></ul><p>下面是一个简单的泛型接口的示例：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface KeyValuePair&lt;K, V&gt; {</span></span>
<span class="line"><span>  key: K;</span></span>
<span class="line"><span>  value: V;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const pair1: KeyValuePair&lt;number, string&gt; = { key: 1, value: &quot;one&quot; };</span></span>
<span class="line"><span>const pair2: KeyValuePair&lt;string, boolean&gt; = { key: &quot;isEnabled&quot;, value: true };</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_8-泛型参数的默认类型" tabindex="-1">8. 泛型参数的默认类型 <a class="header-anchor" href="#_8-泛型参数的默认类型" aria-label="Permalink to &quot;8\. 泛型参数的默认类型&quot;">​</a></h2><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; {</span></span>
<span class="line"><span>  let result: T[] = [];</span></span>
<span class="line"><span>  for (let i = 0; i &lt; length; i++) {</span></span>
<span class="line"><span>    result[i] = value;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_9-泛型约束" tabindex="-1">9. 泛型约束 <a class="header-anchor" href="#_9-泛型约束" aria-label="Permalink to &quot;9\. 泛型约束&quot;">​</a></h2><p>默认情况下，泛型函数的类型参数 T 理论上是可以是任何类型的，不同于 any，你不管使用它的什么属性或者方法都会报错（除非这个属性和方法是所有集合共有的）。</p><p>比如下面的示例中，我想打印出参数的 length 属性，如果不进行泛型约束 TS 是会报错的：类型“T”上不存在属性“length”。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c80037ea69504822b2a8d86ebf4cb395~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=469&amp;h=190&amp;s=10774&amp;e=png&amp;b=1e1e1e" alt=""></p><p>报错的原因很明显，如果要解决这个问题，我们就可以通过给泛型（类型变量）添加约束。</p><p>下面我们通过 <strong>extends</strong> 关键字进行类型约束：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface ILength {</span></span>
<span class="line"><span>  length: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function getLength&lt;T extends ILength&gt;(value: T): T {</span></span>
<span class="line"><span>  console.log(value.length);</span></span>
<span class="line"><span>  return value;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>getLength([1, 2, 3])                    // 正确，因为数组有 length 属性</span></span>
<span class="line"><span>getLength(&#39;Echo&#39;) //                    // 正确，因为字符串有 length 属性</span></span>
<span class="line"><span>getLength({ length: 10, name: &#39;Echo&#39; }) // 正确，因为传入的参数有 length 舒心</span></span>
<span class="line"><span>getLength(10)                           // 报错：类型“number”不能赋值给类型“ILength”的参数，因为数字不具有 length 属性</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在上述示例中，我们定义了一个 ILength 接口，具有 length 属性。在泛型函数 getLength 中，使用 T extends ILength 进行约束，该约束表示：传入的类型必须具有 length 属性。</p><h2 id="十三、ts-中的关键字" tabindex="-1">十三、TS 中的关键字 <a class="header-anchor" href="#十三、ts-中的关键字" aria-label="Permalink to &quot;十三、TS 中的关键字&quot;">​</a></h2><p>TS 内置了一些常用的工具类型，来简化 TS 中一些常见的操作，它们都是基于泛型实现的，并且是内置的，所以可以直接使用。</p><p>在学习工具类型之前，我们先学习一些关键字和基础知识，以便我们可以更好的去学习后面的内置工具类型。</p><h2 id="_1-keyof" tabindex="-1">1. keyof <a class="header-anchor" href="#_1-keyof" aria-label="Permalink to &quot;1\. keyof&quot;">​</a></h2><p>在 TS 中，<strong>keyof</strong> 操作符主要用途是用于获取类型中所有键的关键字。它用于泛型中，通常与索引类型（index type）结合使用。其<strong>返回类型是联合类型</strong>。</p><p>下面示例中，我们定义了一个接口 Person，包含 name、age 和 gender 三个键，然后使用 keyof 来获取 Person 接口的所有键，这样，Keys 类型就是一个由 &quot;name&quot; | &quot;age&quot; | &quot;gender&quot; 构成的联合字面量类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span>  gender: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type Keys = keyof Person; // &quot;name&quot; | &quot;age&quot; | &quot;gender&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>下面示例中，我们创建一个函数来获取对象中属性的值：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function getProp&lt;Type, Key extends keyof Type&gt;(obj: Type, key: Key) {</span></span>
<span class="line"><span>  return obj[key];</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const person = {</span></span>
<span class="line"><span>  name: &#39;Echo&#39;,</span></span>
<span class="line"><span>  age: 26,</span></span>
<span class="line"><span>  gender: &#39;male&#39;,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(getProp(person, &#39;name&#39;))   // 输出：Echo</span></span>
<span class="line"><span>console.log(getProp(person, &#39;age&#39;))    // 输出：26</span></span>
<span class="line"><span>console.log(getProp(person, &#39;gender&#39;)) // 输出：male</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在 TS 中， 是一种泛型约束方式，用于限制一个泛型类型参数 key 的范围。<strong>extends</strong> 关键字表示限制 key 的取值只能是 Type 类型中已有的属性名。可以理解为：Key 只能是 Type 所有键中的任意一个，或者说只能访问对象中存在的属性。</p><p>在上面的例子中，getProp 函数接收两个参数：一个泛型类型参数 Type，代表输入对象的类型；一个泛型类型参数 Key，代表属性名的类型。keyof Type 实际上获取的是 person 对象所有键的联合字面量类型，也就是：&#39;name&#39; | &#39;age&#39; | &#39;gender&#39;，当我们调用调用 getProp 函数传入一个不存在的属性名，例如： &#39;school&#39; 会引发编译错误。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5f6210c6519466ba5d516eb8a883201~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=820&amp;h=92&amp;s=9807&amp;e=png&amp;b=1f1f1f" alt=""></p><h2 id="_2-typeof" tabindex="-1">2. typeof <a class="header-anchor" href="#_2-typeof" aria-label="Permalink to &quot;2\. typeof&quot;">​</a></h2><p>在 TS 中，<strong>typeof</strong> 操作符的主要用途是在类型上下文中获取变量或者属性的类型。</p><h3 id="_2-1-typeof-获取变量的声明类型" tabindex="-1">2.1. typeof 获取变量的声明类型 <a class="header-anchor" href="#_2-1-typeof-获取变量的声明类型" aria-label="Permalink to &quot;2.1. typeof 获取变量的声明类型&quot;">​</a></h3><p>在 TS 中，typeof 可以用来返回一个变量的声明类型，如果不存在，则获取该类型的推论类型。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let n: number = 26</span></span>
<span class="line"><span>type N = typeof n // 等同于 typeof N = number</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let s: string = &#39;Echo&#39;</span></span>
<span class="line"><span>type S = typeof s // 等同于 typeof S = string</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let a: Array&lt;number&gt; = []</span></span>
<span class="line"><span>type A = typeof a // 等同于 typeof A = number[]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let sy: Symbol = Symbol()</span></span>
<span class="line"><span>type SY = typeof sy // 等同于 typeof SY = Symbol</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>需要注意的是：</p><ul><li><strong>typeof 作为类型操作符后面只能跟变量。</strong></li></ul><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let str = &#39;s&#39;;</span></span>
<span class="line"><span>type S = typeof str; // 正确</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// type S1 = typeof &#39;str&#39;;  // 错误</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><strong>如果变量没有声明类型，typeof 返回变量的推断类型。</strong></li></ul><p>如果变量没有明确声明类型，typeof 将返回变量的推断类型。此时，let 关键字声明的变量，可以被重新赋值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let str = &#39;Echo&#39;</span></span>
<span class="line"><span>type S = typeof str // 等同于 type S= string</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 可以被重新赋值</span></span>
<span class="line"><span>str = &#39;Steven&#39; // 正确</span></span>
<span class="line"><span>// str = 26 // 报错：不能将类型“number”分配给类型“string”</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>有时候，我们希望变量是常量，不允许被重新赋值。const 关键字可以解决这个问题。此时，基于类型推断，返回类型是等号右边的字面量类型。</p><p>例如，下面示例中，typeof str 返回的是字面量类型 &#39;Echo&#39;，不是字符串。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const str = &#39;Echo&#39;</span></span>
<span class="line"><span>type S = typeof str // 等同于：type S = &#39;Echo&#39;</span></span>
<span class="line"><span>// str = &#39;Steven&#39; // 报错：无法分配到“str”，因为它是常数</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在 Typescript3.4 中引入了一种新的字面量构造方式，const 断言。在 const 断言作用下，即使是 let 声明也可以限制类型扩展，变量不能被重新赋值。</p><p>例如，下面示例中，typeof str 返回的是字面量类型 &#39;Echo&#39;，不是字符串。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let str = &quot;Echo&quot; as const</span></span>
<span class="line"><span>type S = typeof str // 等同于：type S = &quot;Echo&quot;</span></span>
<span class="line"><span>// str = &#39;Steven&#39; // 报错：无法分配到“&quot;Steven&quot;”分配给类型“&quot;Echo&quot;”</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当我们使用 const 断言构造新的字面量表达式时，应注意以下几点：</p><ul><li>表达式中的任何字面量类型都不应该被扩展。</li><li>对象字面量的属性，将使用 readonly 修饰。</li><li>数组字面量将变成 readonly 元组。</li></ul><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let str = &quot;Echo&quot; as const;</span></span>
<span class="line"><span>type S = typeof str; // 等同于：type S = &quot;Echo&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let num = [1, 2, 3] as const;</span></span>
<span class="line"><span>type N = typeof num; // 等同于：type N = readonly [1, 2, 3]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let obj = { name: &quot;Echo&quot; } as const;</span></span>
<span class="line"><span>type O = typeof obj; // 等同于：type O = { readonly name: &quot;Echo&quot;; }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如果变量明确声明了类型，推断类型不受 const 影响，typeof str 返回 str 的声明类型 string，而不是字面量类型 &quot;Steven&quot;，但是变量依然不能被重新赋值。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const str: string = &quot;Echo&quot;;</span></span>
<span class="line"><span>type S = typeof str // 等同于：type S = string</span></span>
<span class="line"><span>str = &quot;Steven&quot; // 报错：无法分配到 &quot;str&quot; ，因为它是常数。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_2-2-typeof-与对象结合使用" tabindex="-1">2.2. typeof 与对象结合使用 <a class="header-anchor" href="#_2-2-typeof-与对象结合使用" aria-label="Permalink to &quot;2.2. typeof 与对象结合使用&quot;">​</a></h3><p>typeof 与对象结合使用，可以用来获取对象的结构类型，以及使用该类型来声明新的变量或函数参数等。</p><ol><li><strong>获取对象的类型</strong></li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const person = {</span></span>
<span class="line"><span>  name: &#39;Echo&#39;,</span></span>
<span class="line"><span>  age: 26,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type Person = typeof person</span></span>
<span class="line"><span>// 相当于</span></span>
<span class="line"><span>// type Person = {</span></span>
<span class="line"><span>//   name: string;</span></span>
<span class="line"><span>//   age: number;</span></span>
<span class="line"><span>// }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上述示例中，typeof person 返回的是对象 person 的类型，即 { name: string; age: number; }。</p><ol start="2"><li><strong>声明新变量的类型为对象的类型</strong></li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const person = {</span></span>
<span class="line"><span>  name: &#39;Echo&#39;,</span></span>
<span class="line"><span>  age: 26,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const newPerson: typeof person = {</span></span>
<span class="line"><span>  name: &#39;Steven&#39;,</span></span>
<span class="line"><span>  age: 33,</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(newPerson);  // 输出：{ name: &#39;Steven&#39;, age: 33 }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上述示例中，我们使用 typeof person 将 newPerson 的类型声明为 { name: string; age: number; }，并赋予了新的值。</p><ol start="3"><li><strong>在函数参数中使用对象的类型</strong></li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const person = {</span></span>
<span class="line"><span>  name: &#39;Echo&#39;,</span></span>
<span class="line"><span>  age: 26,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function printObj(obj: typeof person) {</span></span>
<span class="line"><span>  console.log(obj);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>printObj(person);  // 输出：{ name: &#39;Echo&#39;, age: 26 }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在上述示例中，函数 printObj 接收一个参数，其类型为 typeof person，即接收与对象 person 相同类型的参数。</p><p>需要注意的是，typeof 运算符用于获取对象类型是在静态类型检查阶段进行的，而不是在运行时期执行的。因此，它只提供了类型信息，而不会直接访问对象的值。</p><h3 id="_2-3-typeof-与接口结合使用" tabindex="-1">2.3. typeof 与接口结合使用 <a class="header-anchor" href="#_2-3-typeof-与接口结合使用" aria-label="Permalink to &quot;2.3. typeof 与接口结合使用&quot;">​</a></h3><p>typeof 与接口结合使用可以用于创建新类型，该类型的属性和方法将与给定对象类型保持一致。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const person: Person = {</span></span>
<span class="line"><span>  name: &#39;Echo&#39;,</span></span>
<span class="line"><span>  age: 26,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type NewPerson = typeof person</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const newPerson: NewPerson = {</span></span>
<span class="line"><span>  name: &#39;Steven&#39;,</span></span>
<span class="line"><span>  age: 33,</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在上述实例中，定义了一个名为 Person 的接口，然后创建一个对象 person，类型为 Person，接着使用 typeof 来创建一个新的类型 NewPerson，该类型的属性和方法将与 Person 接口中定义的属性和方法保持一致，这样我们就可以基于 NewPerson 来创建新的对象。</p><p>需要注意的是，typeof 运算符与接口结合使用通常适用于已存在的对象，它提取已知对象的类型用于创建新的类型。它不会用于动态创建对象或实例化类。</p><h3 id="_2-4-typeof-与-keyof-结合使用" tabindex="-1">2.4. typeof 与 keyof 结合使用 <a class="header-anchor" href="#_2-4-typeof-与-keyof-结合使用" aria-label="Permalink to &quot;2.4. typeof 与 keyof 结合使用&quot;">​</a></h3><p>keyof 主要用于获取类型的所有属性键，可以与 typeof 结合使用，获取某个类型的键集合。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let person = {</span></span>
<span class="line"><span>  name: &#39;Echo&#39;,</span></span>
<span class="line"><span>  age: 28,</span></span>
<span class="line"><span>  address: &#39;Guang Zhou&#39;,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type Person = keyof typeof person // 等同于：type Person = &quot;name&quot; | &quot;age&quot; | &quot;address&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_3-in" tabindex="-1">3. in <a class="header-anchor" href="#_3-in" aria-label="Permalink to &quot;3\. in&quot;">​</a></h2><p>在 TS 中，<strong>in</strong> 操作符的主要用于遍历目标类型的属性 key 值。类似 for...in，一般结合 [] 一起使用。</p><h3 id="_3-1-遍历枚举类型" tabindex="-1">3.1. 遍历枚举类型 <a class="header-anchor" href="#_3-1-遍历枚举类型" aria-label="Permalink to &quot;3.1. 遍历枚举类型&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>enum Direction {</span></span>
<span class="line"><span>  Up,</span></span>
<span class="line"><span>  Right,</span></span>
<span class="line"><span>  Down,</span></span>
<span class="line"><span>  Left</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type DirectionType = {</span></span>
<span class="line"><span>  [value in Direction]: number</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span>type DirectionType = {</span></span>
<span class="line"><span>  0: number;</span></span>
<span class="line"><span>  1: number;</span></span>
<span class="line"><span>  2: number;</span></span>
<span class="line"><span>  3: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>*/</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="_3-2-遍历联合类型" tabindex="-1">3.2. 遍历联合类型 <a class="header-anchor" href="#_3-2-遍历联合类型" aria-label="Permalink to &quot;3.2. 遍历联合类型&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type Property = &#39;name&#39; | &#39;age&#39; | &#39;gender&#39; | &#39;address&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type PropertyMap = {</span></span>
<span class="line"><span>  [key in Property]: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span>type PropertyMap = {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age: string;</span></span>
<span class="line"><span>  gender: string;</span></span>
<span class="line"><span>  address: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span> */</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="_4-extends" tabindex="-1">4. extends <a class="header-anchor" href="#_4-extends" aria-label="Permalink to &quot;4\. extends&quot;">​</a></h2><h3 id="_4-1-用于泛型函数" tabindex="-1">4.1. 用于泛型函数 <a class="header-anchor" href="#_4-1-用于泛型函数" aria-label="Permalink to &quot;4.1. 用于泛型函数&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type NT = number | string;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// T 必须是 number 或 string 类型</span></span>
<span class="line"><span>function printValue&lt;T extends NT&gt;(value: T) {</span></span>
<span class="line"><span>  console.log(value);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>printValue(&quot;Echo&quot;); // 正确</span></span>
<span class="line"><span>printValue(26);     // 正确</span></span>
<span class="line"><span>// printValue(true); // 错误，布尔类型不符合约束条件</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_4-2-用于泛型类" tabindex="-1">4.2. 用于泛型类 <a class="header-anchor" href="#_4-2-用于泛型类" aria-label="Permalink to &quot;4.2. 用于泛型类&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface ILength {</span></span>
<span class="line"><span>  length: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// T 必须是具有 length 属性的类型</span></span>
<span class="line"><span>class Container&lt;T extends ILength&gt; {</span></span>
<span class="line"><span>  value: T;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  constructor(value: T) {</span></span>
<span class="line"><span>    this.value = value;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  printLength() {</span></span>
<span class="line"><span>    console.log(this.value.length);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const container1 = new Container(&quot;Echo&quot;); // 正确</span></span>
<span class="line"><span>container1.printLength(); // 输出: 4</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// const container2 = new Container(26); // 错误，数字类型没有 length 属性</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="_4-3-用于类继承" tabindex="-1">4.3. 用于类继承 <a class="header-anchor" href="#_4-3-用于类继承" aria-label="Permalink to &quot;4.3. 用于类继承&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Animal {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  constructor(name: string) {</span></span>
<span class="line"><span>    this.name = name;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  move(distance: number): void {</span></span>
<span class="line"><span>    console.log(`${this.name} moved ${distance} meters.`);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Dog extends Animal {</span></span>
<span class="line"><span>  bark(): void {</span></span>
<span class="line"><span>    console.log(&quot;Woof! Woof!&quot;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const dog = new Dog(&quot;Hate&quot;);</span></span>
<span class="line"><span>dog.move(10);   // 调用继承来自父类的方法 输出：Hate moved 10 meters.</span></span>
<span class="line"><span>dog.bark();     // 调用子类自己定义的方法 输出：Woof! Woof!</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="_4-4-用于继承接口" tabindex="-1">4.4. 用于继承接口 <a class="header-anchor" href="#_4-4-用于继承接口" aria-label="Permalink to &quot;4.4. 用于继承接口&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Shape {</span></span>
<span class="line"><span>  color: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface Square extends Shape {</span></span>
<span class="line"><span>  sideLength: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let square = &lt;Square&gt;{};</span></span>
<span class="line"><span>square.color = &quot;blue&quot;;</span></span>
<span class="line"><span>square.sideLength = 10;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_4-5-用于类型约束" tabindex="-1">4.5. 用于类型约束 <a class="header-anchor" href="#_4-5-用于类型约束" aria-label="Permalink to &quot;4.5. 用于类型约束&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface ILength {</span></span>
<span class="line"><span>  length: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function getLength&lt;T extends ILength&gt;(value: T): T {</span></span>
<span class="line"><span>  console.log(value.length);</span></span>
<span class="line"><span>  return value;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>getLength([1, 2, 3])                    // 正确，因为数组有 length 属性</span></span>
<span class="line"><span>getLength(&#39;Echo&#39;) //                    // 正确，因为字符串有 length 属性</span></span>
<span class="line"><span>getLength({ length: 10, name: &#39;Echo&#39; }) // 正确，因为传入的参数有 length 舒心</span></span>
<span class="line"><span>getLength(10)                           // 报错：类型“number”不能赋值给类型“ILength”的参数，因为数字不具有 length 属性</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="_4-6-用于条件类型" tabindex="-1">4.6. 用于条件类型 <a class="header-anchor" href="#_4-6-用于条件类型" aria-label="Permalink to &quot;4.6. 用于条件类型&quot;">​</a></h3><p>TypeScript 2.8 引入了条件类型表达式，类似于三元运算符。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type NoNullAndUndefined&lt;T&gt; = T extends null | undefined ? never : T;  // 如果泛型参数 T 为 null 或 undefined，那么取 never，否则直接返回 T。</span></span>
<span class="line"><span>let k1: NoNullAndUndefined&lt;number&gt;;    // k1 是 number类型，因为 number 不是 null | undefined 的子集</span></span>
<span class="line"><span>let k2: NoNullAndUndefined&lt;undefined&gt;; // k2 是 never类型，因为 undefined 是 null | undefined 的子集</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>条件类型也支持嵌套。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type TypeName&lt;T&gt; =</span></span>
<span class="line"><span>  T extends string ? &quot;string&quot; :</span></span>
<span class="line"><span>  T extends number ? &quot;number&quot; :</span></span>
<span class="line"><span>  T extends boolean ? &quot;boolean&quot; :</span></span>
<span class="line"><span>  T extends undefined ? &quot;undefined&quot; :</span></span>
<span class="line"><span>  T extends Function ? &quot;function&quot; : &quot;object&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type T0 = TypeName&lt;&#39;Echo&#39;&gt;;      // &quot;string&quot;</span></span>
<span class="line"><span>type T1 = TypeName&lt;26&gt;;          // &quot;number&quot;</span></span>
<span class="line"><span>type T2 = TypeName&lt;true&gt;;        // &quot;boolean&quot;</span></span>
<span class="line"><span>type T3 = TypeName&lt;() =&gt; void&gt;;  // &quot;function&quot;</span></span>
<span class="line"><span>type T4 = TypeName&lt;string[]&gt;;    // &quot;object&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="十四、泛型工具类型" tabindex="-1">十四、泛型工具类型 <a class="header-anchor" href="#十四、泛型工具类型" aria-label="Permalink to &quot;十四、泛型工具类型&quot;">​</a></h2><p>泛型工具类型这一章节相关的内容我想放到其它文章中来讲，因为这里涉及到的知识点有点多，一时半会写不完，大家可以持续关注我，精力有限，尽量做到每周 2-3 更！！！</p><h2 id="十五、总结" tabindex="-1">十五、总结 <a class="header-anchor" href="#十五、总结" aria-label="Permalink to &quot;十五、总结&quot;">​</a></h2><p>如果文章有什么错误，欢迎大家在评论区指正，如果觉得本文对您有帮助的话，欢迎 👏<strong>点赞收藏</strong>哦～</p></div></div></main><footer class="VPDocFooter" data-v-6c989021 data-v-9779d5f6><!--[--><!--]--><div class="edit-info" data-v-9779d5f6><!----><div class="last-updated" data-v-9779d5f6><p class="VPLastUpdated" data-v-9779d5f6 data-v-f643710e>上次更新: <time datetime="2024-05-27T01:47:03.000Z" data-v-f643710e></time></p></div></div><nav class="prev-next" data-v-9779d5f6><div class="pager" data-v-9779d5f6><a class="VPLink link pager-link prev" href="/my-note/fe/typescript/base" data-v-9779d5f6><!--[--><span class="desc" data-v-9779d5f6>上一篇</span><span class="title" data-v-9779d5f6>typescript</span><!--]--></a></div><div class="pager" data-v-9779d5f6><!----></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-39b8670e data-v-21a3b793><div class="container" data-v-21a3b793><p class="message" data-v-21a3b793>你相信光吗</p><p class="copyright" data-v-21a3b793>Copyright © 2020-present</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"afterend_node_index.md\":\"oaILWabk\",\"afterend_db_mongodb_index.md\":\"A5iwJuYS\",\"afterend_db_index.md\":\"zWfzdVfJ\",\"afterend_db_mongodb_基础查询.md\":\"pFISSryS\",\"afterend_db_mysql_index.md\":\"niw86ASO\",\"about.md\":\"MNqN9oZ5\",\"afterend_db_mysql_sql查询.md\":\"kR32sKF2\",\"afterend_nginx_index.md\":\"q_C3OS4F\",\"engineering_buildtools_index.md\":\"NNX4Q3Tz\",\"engineering_buildtools_esbuild_esbuild功能使用.md\":\"XPPVsGFC\",\"afterend_db_mongodb_install-mac.md\":\"88jyctAW\",\"engineering_buildtools_vite_index.md\":\"LN-Xsydl\",\"engineering_buildtools_vite_依赖预构建.md\":\"dclYHae2\",\"engineering_buildtools_webpack_index.md\":\"4phYmZ_j\",\"engineering_buildtools_vite_迁移vite.md\":\"vNw31tYo\",\"engineering_buildtools_vite_vite配置多页应用.md\":\"YozlLHkA\",\"engineering_buildtools_vite_代码分割.md\":\"c3jSKOx9\",\"engineering_buildtools_vite_vite首次启动慢.md\":\"3qoslqyH\",\"engineering_buildtools_esbuild_esbuild插件开发.md\":\"els1JnqI\",\"engineering_buildtools_vite_hmr原理.md\":\"zY-g2CK8\",\"engineering_buildtools_vite_常见配置.md\":\"J7LfdiQx\",\"engineering_deploy_githubaction_giteepage.md\":\"s7OHv15H\",\"engineering_deploy_base_免费证书使用指南.md\":\"lbVdXCsi\",\"engineering_buildtools_vite_性能优化.md\":\"mLeUpHyy\",\"engineering_buildtools_vite_vite插件开发.md\":\"C5dfa80b\",\"engineering_buildtools_vite_如何处理css.md\":\"Iqy2QJhg\",\"engineering_buildtools_vite_双引擎架构.md\":\"vcauAotp\",\"engineering_deploy_githubaction_远程ssh链接.md\":\"ixYJizHN\",\"engineering_buildtools_webpack_webpack配置多页应用.md\":\"7LkCapeN\",\"engineering_buildtools_vite_语法降级与polyfill.md\":\"BFSej1rB\",\"engineering_deploy_docker_docker部署express和mysql.md\":\"QaSfYKx6\",\"engineering_deploy_docker_docker部署express和mysql和redis.md\":\"syVAeZl6\",\"engineering_deploy_docker_docker部署node-env.md\":\"4tPCfdPG\",\"engineering_deploy_docker_docker使用.md\":\"iSYglVK7\",\"engineering_deploy_docker_docker部署node-volume.md\":\"0tDnUXNK\",\"engineering_deploy_docker_docker安装.md\":\"64JAYUfT\",\"engineering_deploy_docker_简介.md\":\"Jzedtqh-\",\"engineering_deploy_docker_index.md\":\"0MUPzNow\",\"engineering_deploy_index.md\":\"ta6lD-GP\",\"engineering_deploy_jenkins_jenkins安装.md\":\"7TeHAdNk\",\"engineering_deploy_nginx_nginx配置https.md\":\"tOaPp_Hr\",\"engineering_deploy_project_初级版docker部署前后端.md\":\"1dIYvReD\",\"engineering_package_index.md\":\"C9Bl9MaM\",\"engineering_deploy_project_github-action.md\":\"e2SjgdUR\",\"engineering_package_npm link.md\":\"7dMeonGI\",\"engineering_deploy_project_使用shell部署前端静态资源.md\":\"hOCOwkEN\",\"engineering_package_npm.md\":\"ZR33I5nz\",\"engineering_deploy_jenkins_jenkins配置.md\":\"U0OT-np5\",\"engineering_package_packagesjson常用的配置字段.md\":\"vd1eiVOj\",\"engineering_deploy_project_使用js脚本.md\":\"_NikunVI\",\"engineering_deploy_project_pm2部署前后端项目.md\":\"z1OpJ_lP\",\"engineering_package_符号.md\":\"2hDgMY99\",\"engineering_deploy_project_jenkins部署前端项目.md\":\"Pm9TNd1c\",\"engineering_package_npm转pnpm.md\":\"ObxSKtFI\",\"engineering_deploy_docker_docker部署node-基础版.md\":\"RmH8zNNO\",\"engineering_deploy_githubaction_githubpage.md\":\"c4F_PkWu\",\"engineering_standard_vue3项目代码规范.md\":\"mSL1LT00\",\"engineering_deploy_githubaction_简介.md\":\"USHbrdfK\",\"engineering_deploy_githubaction_index.md\":\"X8c_EWv_\",\"engineering_deploy_githubaction_部署阿里云.md\":\"00csohJs\",\"engineering_deploy_base_ubuntu20.4.md\":\"RHAfpoqm\",\"engineering_buildtools_rollup_rollup使用.md\":\"dbnzZTeY\",\"engineering_buildtools_vite_模块化.md\":\"Ul50pFdu\",\"engineering_buildtools_rollup_rollup插件机制.md\":\"BsFc3iw9\",\"engineering_deploy_docker_docker部署vue项目.md\":\"Pe5MrA2g\",\"engineering_buildtools_vite_如何处理静态资源.md\":\"eAe_uOkT\",\"engineering_deploy_base_服务器配置ssh.md\":\"hiwiG_VV\",\"engineering_deploy_base_服务器拉取仓库代码.md\":\"yKUTptYB\",\"engineering_deploy_base_centos安装nginx.md\":\"-8HtrcHZ\",\"engineering_standard_代码规范.md\":\"bkUhP0FC\",\"engineering_deploy_jenkins_前端项目配置.md\":\"42pHONw0\",\"fe_css_position.md\":\"QmFeJxg4\",\"fe_css_responsive.md\":\"lz4M6NbZ\",\"fe_css_selector.md\":\"umPNX5vb\",\"fe_javascript_event_beforeunload.md\":\"CJ4KZZeP\",\"fe_basicknowledge_concept_编程范式.md\":\"z2vyYCLU\",\"fe_basicknowledge_video_index.md\":\"tOONPrSD\",\"fe_css_flex.md\":\"s5tHxsbf\",\"fe_css_graphictextstyles.md\":\"Kpy4RfKN\",\"engineering_standard_index.md\":\"EYpyK21H\",\"fe_basicknowledge_audio_index.md\":\"_gZxwtAH\",\"fe_basicknowledge_image_index.md\":\"5CuLLm6w\",\"fe_html_index.md\":\"zAx-cUkE\",\"fe_basicknowledge_browser_页面渲染方式.md\":\"JmGzPY9i\",\"fe_css_css3.md\":\"vabbYJMk\",\"fe_javascript_clone.md\":\"hMDcwJ6K\",\"fe_basicknowledge_network_tcp.md\":\"ohg9fomf\",\"fe_css_tricks.md\":\"QWbwDAUx\",\"fe_javascript_base.md\":\"WoThqDj4\",\"fe_javascript_conversions.md\":\"SW6fjzY2\",\"fe_javascript_event_事件流.md\":\"1ADf4sC_\",\"fe_basicknowledge_network_http.md\":\"IR5G7738\",\"fe_javascript_promise_案例.md\":\"_pIm5uHW\",\"fe_javascript_webstorage_webstorage.md\":\"e6PCWWSU\",\"fe_javascript_webapi_webworker.md\":\"gdM5u2HT\",\"frame_react_ts_08-react与ts配合之基础props限制.md\":\"zGf4YgI7\",\"frame_react_ts_10-react与ts配合之style与component限制.md\":\"xUJAsifs\",\"fe_coding_index.md\":\"Ig-vgmYZ\",\"fe_typescript_advance_07-映射类型与内置工具类型.md\":\"YPWJIi6X\",\"fe_typescript_advance_08-条件类型和infer关键字.md\":\"-YVkY4bL\",\"fe_typescript_advance_10-模板字符串类型.md\":\"5ZTbZosW\",\"fe_typescript_advance_@types和definitelytyped仓库.md\":\"2mmHNnwM\",\"fe_typescript_advance_d点ts声明文件和declare关键字.md\":\"pEi7xgne\",\"tools_software_windows.md\":\"1cPZAOhb\",\"tools_template_h5.md\":\"WAH8PyC5\",\"fe_typescript_advance_lib_d_ts和global_d_ts.md\":\"HuqQ-VJN\",\"interview_node框架.md\":\"PjmSRVx0\",\"interview_构建.md\":\"iz6Nu8xl\",\"interview_问题预设.md\":\"S99wBHBd\",\"interview_项目难点.md\":\"MZmmOhse\",\"tools_terminal_shell.md\":\"J39Cqb5f\",\"fe_javascript_xhr_cors.md\":\"HOkf7U0w\",\"fe_css_layout.md\":\"DcseBDCj\",\"fe_typescript_advance_配置你的typescript.md\":\"QOdiv7Ps\",\"frame_vue_路由_03-路由的基本搭建与嵌套路由模式.md\":\"8MLCp_xq\",\"frame_vue_路由_04-动态路由模式与编程式路由模式.md\":\"juLKlBeX\",\"frame_react_ts_11-react与ts配合之use函数限制.md\":\"Nw-LXqov\",\"frame_vue_路由_05-命名路由与命名视图与路由元信息.md\":\"RTfHU6iL\",\"frame_vue_路由_06-路由传递参数的多种方式及应用场景.md\":\"_7KaMqPl\",\"index.md\":\"uJD-4BxE\",\"fe_javascript_xhr_xhr.md\":\"mXBfVM1e\",\"fe_typescript_base_05-类型分类与联合类型与交叉类型.md\":\"paiho4oC\",\"fe_typescript_base_04-类型注解与类型推断.md\":\"rlvWD5Vg\",\"fe_typescript_advance_04-类型保护与自定义类型保护.md\":\"RQHS1ZRo\",\"fe_javascript_types.md\":\"zEmNGTFJ\",\"fe_es6_index.md\":\"bhhOf2FC\",\"interview_vue2响应式.md\":\"qkO5giVu\",\"interview_vue.md\":\"MhtK-TZD\",\"interview_房地产.md\":\"SqMR7NU-\",\"interview_webpack1.md\":\"LMcXuPdJ\",\"interview_小程序.md\":\"6q0xOOvS\",\"interview_专业技能和工作经验.md\":\"rQDSngKT\",\"frame_react_reactrouter_07-自定义全局守卫与自定义元信息.md\":\"XhYQh5FU\",\"frame_react_base_02-虚拟dom与react18新的渲染写法.md\":\"p0LGuEEc\",\"frame_react_base_03-什么是jsx及jsx详细使用方式.md\":\"Iq3lvYX9\",\"frame_vue_路由_08-路由守卫详解及应用场景.md\":\"eonL9xkp\",\"interview_index.md\":\"zH46guUA\",\"frame_react_base_05-如何进行条件渲染与列表渲染.md\":\"LK7yCMz1\",\"interview_ai.md\":\"Jm-NPYlk\",\"interview_http.md\":\"Geaxro4V\",\"interview_css_css-2.md\":\"Nt29E8rV\",\"fe_typescript_base_03-类型声明空间与变量声明空间.md\":\"Y7B9Ljyr\",\"fe_javascript_数据类型检测原理.md\":\"vnlwPl1C\",\"fe_javascript_调用栈.md\":\"4U304wMH\",\"fe_javascript_数组方法.md\":\"TIa2F41U\",\"fe_javascript_块级作用域.md\":\"A2G5NsWk\",\"frame_react_base_09-类组件响应式视图实现与原理.md\":\"qzq_m-9t\",\"frame_react_base_10-state细节详解及react18的自动批处理.md\":\"PZM6zVko\",\"fe_javascript_变量提升.md\":\"FWzZXra5\",\"fe_sass_index.md\":\"owGeN15m\",\"frame_react_base_08-类组件中事件的使用详解.md\":\"JpnmKhu1\",\"fe_javascript_webstorage_cookie.md\":\"Hnv7dnvz\",\"fe_typescript_advance_02-详解接口与类型别名之间区别.md\":\"UEzcWisF\",\"frame_react_base_11-purecomponent与shouldcomponentupdate.md\":\"HXkaqOkS\",\"frame_react_base_12-immutablejs不可变数据集合.md\":\"2FJo_QG2\",\"frame_react_base_13-refs操作dom及操作类组件.md\":\"QMptM7y3\",\"fe_typescript_base_06-never类型与any类型与unknown类型.md\":\"o-_TPtjO\",\"frame_react_base_14-详解受控组件及各种表单中的使用.md\":\"aZNYkspg\",\"frame_react_ts_14-redux toolkit状态管理如何使用ts进行开发.md\":\"wc4GpJA6\",\"fe_css_index.md\":\"A7-frPzy\",\"frame_react_reactrouter_05-默认路由展示与重定向路由与404处理.md\":\"eU7vhXXE\",\"fe_typescript_base_09-对象类型与索引签名.md\":\"3XGR6ywL\",\"fe_typescript_base_10-函数类型与void类型.md\":\"oefsyjyj\",\"fe_typescript_base_08-数组类型与元组类型.md\":\"xMB_GWWf\",\"fe_javascript_promise_index.md\":\"mFHfubPk\",\"fe_typescript_base.md\":\"HCLKo-WX\",\"fe_typescript_tool_内置工具类型-1.md\":\"SMPtaiDT\",\"fe_typescript_base_11-函数重载与可调用注解.md\":\"xqHdTF-h\",\"interview_css_css-3.md\":\"igmTuLph\",\"fe_typescript_base_12-枚举类型与const枚举.md\":\"6Ggq81ur\",\"fe_typescript_tool_内置工具类型-2.md\":\"BrIC9YxZ\",\"frame_react_reactrouter_06-路由loader函数与redirect方法.md\":\"nNkD8sak\",\"fe_typescript_index.md\":\"j_bupr78\",\"interview_react.md\":\"6f_iP5GS\",\"tools_terminal_toolkit.md\":\"JHOpDGos\",\"interview_node.md\":\"pfu-EAO6\",\"frame_vue_vuex_12-vuex计算属性和辅助函数的使用.md\":\"CoLejPs7\",\"frame_different_02-react18与vue3对比之编程风格与视图风格.md\":\"FIh2u4nf\",\"fe_javascript_this.md\":\"f2NY_JTf\",\"frame_different_03-react18与vue3对比之组件_路由_状态管理等风格.md\":\"7xQgTuE2\",\"frame_different_04-react18与vue3对比之模板_样式_事件_表单等功能.md\":\"AEBJV5aX\",\"frame_vue_vuex_11-vuex处理异步状态及应用场景.md\":\"qg8X50Vy\",\"fe_typescript_advance_05-定义泛型和泛型常见操作.md\":\"yBBehPOZ\",\"frame_different_05-react18与vue3对比之组件通信_逻辑复用_内容分发_dom操作等功能.md\":\"asFL6eMO\",\"tools_terminal_xhcli.md\":\"uvhBcxKq\",\"tools_whistle.md\":\"pBnCeVm7\",\"fe_typescript_advance_06-类型兼容性详解.md\":\"ClJqBGt9\",\"tools_terminal_zsh.md\":\"blFcja7g\",\"frame_react_redux_16-类组件中如何使用路由和状态管理.md\":\"8DTD0zvb\",\"frame_react_base_06-类组件基本使用及组件通信.md\":\"Kq5CxrC_\",\"fe_javascript_eventloop.md\":\"z_v6O5vb\",\"frame_vue_资料.md\":\"ceH2S_fQ\",\"frame_react_ts_09-react与ts配合之children与event限制.md\":\"O0PRRiXL\",\"frame_different_06-react18与vue3对比之diff算法的相同策略与不同策略.md\":\"vifyX6mb\",\"fe_javascript_event_事件类型.md\":\"O3I9SsQg\",\"frame_react_ts_12-react与ts配合之类组件类型限制.md\":\"8pnafVUB\",\"fe_javascript_字符串方法.md\":\"saR2z8ty\",\"frame_vue_skill.md\":\"QO6OA2eN\",\"fe_typescript_advance_03-字面量类型和keyof关键字.md\":\"eQCRE5kF\",\"frame_vue_vuex_10-vuex共享状态的基本开发流程.md\":\"NuEXv963\",\"fe_typescript_advance_详解tsconfigjson配置文件.md\":\"1WWovNKt\",\"fe_javascript_webstorage_jwt.md\":\"tWaNFN0J\",\"frame_vue_vuex_13-vuex-persist对数据进行持久化处理.md\":\"qgvo60TN\",\"frame_vue_index.md\":\"tShR8Xsf\",\"frame_vue_base_05-vue3组合式api详解.md\":\"wXQ3Q65k\",\"frame_react_reactrouter_03-动态路由模式与编程式路由模式.md\":\"mcgnBf5z\",\"frame_react_reactrouter_04-usesearchparams与uselocation函数.md\":\"TXTBjBCk\",\"frame_different_index.md\":\"3OJyVaU-\",\"frame_different_07-react18与vue3对比之响应式_生命周期_副作用等功能.md\":\"WqGFfLaj\",\"frame_react_base_15-详解非受控组件的实现方案.md\":\"KnaP8QSd\",\"frame_react_umi_15-umi4框架介绍与基本使用.md\":\"lO-0QkNw\",\"frame_react_base_16-详解常见生命周期钩子函数.md\":\"Xr4-pLsG\",\"frame_react_base_17-详解不常见生命周期钩子函数.md\":\"Ek_38FwL\",\"frame_react_reactrouter_02-reactrouterv6基础路由搭建.md\":\"wt_7SidM\",\"frame_react_base_19-复用组件功能之render props模式.md\":\"9z09XSk5\",\"frame_react_base_20-复用组件功能之hoc高阶组件模式.md\":\"KE3zkAHH\",\"frame_react_base_21-组件跨层级通信方案context.md\":\"D3CMhPfn\",\"frame_react_base_23-章节总结.md\":\"aXXakynw\",\"frame_react_hook_02-函数组件基本使用及点标记组件写法.md\":\"iYei89KU\",\"frame_react_hook_03-hook概念及hook之usestate函数.md\":\"d3eAvZSS\",\"frame_react_base_18-组件内容的组合模式.md\":\"FGiT7J5v\",\"frame_react_ts_13-react router路由如何使用ts进行开发.md\":\"mIWiIoMg\",\"fe_typescript_base_07-类型断言与非空断言.md\":\"m8ggUW6w\",\"frame_react_hook_06-详解hook之usecontext函数.md\":\"aX-Lfa7V\",\"frame_react_hook_07-函数组件性能优化之react memo.md\":\"Li3otufY\",\"frame_react_hook_08-详解hook之usecallback与usememo函数.md\":\"iflxvz9m\",\"frame_react_hook_05-详解hook之useref函数.md\":\"UOQtwUwJ\",\"frame_react_hook_09-详解hook之usereducer函数.md\":\"8Y5y9b2t\",\"frame_react_hook_10-react18之并发模式与starttransition.md\":\"nZhpgT-y\",\"frame_react_index.md\":\"Y7YhLm61\",\"frame_vue_vuex_14-vuex分割模块及多状态管理.md\":\"meP1_48_\",\"frame_react_redux_08-redux状态管理的基本流程.md\":\"W_I2wfpb\",\"frame_react_redux_09-react-redux简化对redux的使用.md\":\"XiRmceEy\",\"frame_react_hook_04-详解hook之useeffect函数.md\":\"h4Tu6YzW\",\"fe_typescript_base_02-为什么使用ts和ts运行环境搭建.md\":\"gcZyLCEz\",\"subject_datastructure_array_topic.md\":\"CRMhqY2m\",\"frame_react_redux_10-如何处理多个reducer函数及redux模块化.md\":\"RPklEbkE\",\"fe_basicknowledge_browser_浏览器知识.md\":\"7LGdMdAs\",\"frame_react_redux_12-redux-toolkit(rtk)改善redux使用体验.md\":\"dbcJepTk\",\"frame_react_redux_14-通过redux-persist进行数据持久化处理.md\":\"hSpV_ghu\",\"frame_react_redux_13-redux-toolkit(rtk)如何处理异步任务.md\":\"qDKEpuM3\",\"frame_react_redux_11-redux-thunk中间件处理异步操作.md\":\"08b601P1\",\"fe_javascript_event_事件处理程序.md\":\"4E4yDcB9\",\"fe_javascript_event_事件对象.md\":\"CLxbVQ7z\",\"fe_javascript_promise_输出题.md\":\"jyNri9RN\",\"fe_javascript_promise_迭代器.md\":\"YLxurPrf\",\"frame_different_对比学习.md\":\"zkWC4x2K\",\"fe_javascript_inherit.md\":\"g9-A3TQZ\",\"tools_software_vscode.md\":\"onwyQjCe\",\"tools_software_webstorm.md\":\"edB0NJo1\",\"frame_react_hook_13-简易购物车的hook版本.md\":\"BtYyAvaq\",\"subject_datastructure_linkedlist_index.md\":\"XQI28o3F\",\"frame_react_hook_14-章节总结.md\":\"fgzLuU1I\",\"subject_datastructure_array_index.md\":\"aHPl0zoQ\",\"fe_javascript_xhr_缓存.md\":\"L5ZflkUg\",\"subject_datastructure_linkedlist_topic.md\":\"Jshae1o3\",\"frame_vue_源码_index.md\":\"TCFti8hU\",\"interview_javascript.md\":\"y2ke7MlY\",\"frame_vue_路由_07-详解route对象与router对象.md\":\"FxLwPG0y\",\"frame_react_hook_11-react18之usetransition与usedeferredvalue.md\":\"ybcnad8q\",\"frame_react_hook_12-函数组件功能复用之自定义hook.md\":\"ONdkeNfa\",\"interview_css_css-1.md\":\"CeUMszOc\",\"frame_react_redux_15-路由加状态管理的登录拦截综合案例.md\":\"sLljbq1y\",\"subject_datastructure_queue_topic.md\":\"oDvKp4H9\",\"subject_datastructure_map_topic.md\":\"x3lJPM1-\",\"subject_datastructure_queue_priorityqueue.md\":\"JEdYk0Do\",\"subject_datastructure_queue_index.md\":\"cY8MI4AQ\",\"subject_datastructure_set_topic.md\":\"lMLwPRCX\",\"subject_datastructure_searchsort_index.md\":\"YUGdBYR5\",\"subject_datastructure_stack_index.md\":\"0WI9_aHC\",\"subject_datastructure_stack_topic.md\":\"KUw2Ij89\",\"subject_datastructure_set_index.md\":\"4bEsxOEI\",\"subject_datastructure_tree_index.md\":\"Z6vrUsBd\",\"subject_datastructure_tree_binarytree.md\":\"jrxYh1h8\",\"subject_datastructure_tree_topic.md\":\"lK_JSenZ\",\"subject_harmonyos_index.md\":\"T_Ssn0sg\",\"subject_mobile_h5唤起app.md\":\"JU53xEjY\",\"subject_mobile_index.md\":\"9NuAjD1T\",\"subject_mobile_微信端外h5跳转小程序方案汇总.md\":\"Z8CvFS4n\",\"subject_datastructure_tree_binarysearchtree.md\":\"NGrLeMq7\",\"subject_mobile_移动端兼容性问题.md\":\"sidVMMTs\",\"subject_performance_index.md\":\"Eow00buU\",\"subject_weixin_index.md\":\"z7GuUZMD\",\"subject_weixin_miniprogram_index.md\":\"KCd5g1Pa\",\"subject_datastructure_tree_traverse.md\":\"jhoTPU2I\",\"subject_weixin_common.md\":\"DVnXE4cv\",\"subject_weixin_gzh_index.md\":\"3M2fYU5A\",\"subject_weixin_miniprogram_小程序扫码登录.md\":\"KNh1ZRhR\",\"tools_doc_vitepress配置algolia.md\":\"qBnE2_D-\",\"tools_git_command.md\":\"Zx_Hr-KT\",\"tools_doc_index.md\":\"v9z4H1Jv\",\"tools_index.md\":\"D4jrqwnI\",\"tools_git_index.md\":\"b2njpWy6\",\"tools_library.md\":\"9cbWTiZR\",\"tools_onlinetools.md\":\"EYDkzTfv\",\"tools_software_browser.md\":\"oCJKkUqG\",\"tools_software_cross-platform.md\":\"qtlDM0vl\",\"tools_regexp.md\":\"0aPCvBEt\",\"fe_javascript_prototype.md\":\"gQPlImPr\",\"fe_basicknowledge_network_index.md\":\"rbUa6WRy\",\"tools_software_mac.md\":\"ca79J9Zk\",\"fe_javascript_promise_任务执行.md\":\"c2E9a77o\",\"subject_chatgpt_use_搭建openai的api代理.md\":\"-8yGcNsW\",\"subject_chatgpt_develop_index.md\":\"frhElptJ\",\"subject_chatgpt_develop_sse服务端实时推送消息.md\":\"0beqPNc4\",\"frame_react_umi_17-umi max之antd组件库_发起请求_共享数据流.md\":\"abcffjL4\",\"subject_chatgpt_index.md\":\"N0AabfgT\",\"frame_vue_provide和inject.md\":\"2fkWQfwR\",\"subject_chatgpt_openai_gpt.md\":\"ZNntjvX_\",\"subject_chatgpt_openai_models.md\":\"pat9K__E\",\"subject_chatgpt_openai_index.md\":\"sKCTJrtD\",\"subject_chatgpt_study_ai 学习资源.md\":\"hWWOMQtA\",\"subject_chatgpt_use_prompt.md\":\"4_AxKFRi\",\"frame_vue_base_02-vue3核心概念及选项式api.md\":\"iW9FLD4T\",\"frame_react_umi_16-umi4之mock数据_路由数据加载_路由包装组件.md\":\"_z5aoz-T\",\"subject_chatgpt_use_prompt资源.md\":\"1ZCJIxDk\",\"subject_chatgpt_use_使用资源.md\":\"2aG12a2z\",\"subject_datastructure_hashtable_topic.md\":\"MkMYofC3\",\"pit_commoneffect_index.md\":\"P_iiSAC_\",\"frame_react_base_07-props细节详解及注意事项.md\":\"iNYg7y-A\",\"subject_datastructure_linkedlist_doublelinkedlist.md\":\"9sLOulKk\",\"fe_typescript_advance_09-类中如何使用类型.md\":\"D83nE-Hu\",\"pit_debug_vue.md\":\"8kZcV-YA\",\"pit_debug_调试方法.md\":\"hbsquTG_\",\"frame_vue_base_03-vue3组件应用及单文件组件.md\":\"D6fJ1_zp\",\"subject_datastructure_graph_index.md\":\"5b-MYQEG\",\"subject_datastructure_graph_topic.md\":\"qQm_2p9v\",\"pit_debug_远程调试.md\":\"Tuv9DavR\",\"pit_h5 copy.md\":\"bYm4PvLZ\",\"pit_import排序.md\":\"-gO7xZjd\",\"pit_index.md\":\"eYLqxvgA\",\"subject_datastructure_hashtable_index.md\":\"9kV0Ldf5\",\"pit_h5.md\":\"Haom1G6b\",\"pit_npm.md\":\"FHEs29HX\",\"subject_datastructure_index.md\":\"FFScX8wC\",\"pit_pc copy.md\":\"Iht7g0YF\",\"fe_javascript_作用域链和闭包.md\":\"4ETEMREE\",\"fe_javascript_xhr_fetch.md\":\"Ge5W3xpd\",\"subject_datastructure_map_index.md\":\"AlnlTotX\",\"frame_react_base_22-简易购物车的综合案例.md\":\"rshLby_N\",\"login.md\":\"mhFR10q1\",\"interview_webpack2.md\":\"zg_nzE0h\",\"interview_hr篇.md\":\"6_wwBiKx\",\"fe_javascript_数据类型.md\":\"ClEmTa2-\",\"nav.md\":\"S6PTnals\",\"fe_javascript_promise_生成器.md\":\"iun1LDsk\",\"fe_javascript_xhr_跨域.md\":\"a2k2-HuR\",\"pit_pc.md\":\"BHU7K48n\",\"fe_javascript_module.md\":\"aKqhQMph\",\"subject_performance_工具.md\":\"uuvMuFG2\",\"subject_performance_资源.md\":\"idlqwxX3\",\"fe_javascript_promise_手写实现.md\":\"nphB8xNg\",\"pit_commonfunc_处理url.md\":\"gdXjFpS6\",\"pit_commoneffect_弹幕效果.md\":\"uiw8I8aV\",\"frame_vue_base_04-vue3语法系统进阶.md\":\"wYFz9qGe\",\"fe_typescript_ts-study.md\":\"vHTDiOl4\",\"subject_performance_vue性能优化-1.md\":\"BufKXFRk\",\"pit_commonfunc_禁止浏览器快捷键保存页面.md\":\"_vhYzpMY\",\"subject_performance_vue性能优化-2.md\":\"UjhlgSuq\",\"subject_performance_性能优化指标.md\":\"uO4wXT4I\",\"subject_performance_性能优化策略.md\":\"JT4NtNwp\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"MY-NOTE\",\"description\":\"成长之路，包含前端常用知识、源码阅读笔记、各种奇淫技巧、日常提效工具等\",\"base\":\"/my-note/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"i18nRouting\":false,\"logo\":\"/logo.png\",\"nav\":[{\"text\":\"项目\",\"link\":\"/nav\",\"activeMatch\":\"^/nav\"},{\"text\":\"基础\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/fe/basicknowledge/concept/编程范式\"},{\"text\":\"html\",\"link\":\"/fe/html/index\"},{\"text\":\"CSS\",\"link\":\"/fe/css/index\"},{\"text\":\"JavaScript\",\"link\":\"/fe/javascript/types\"},{\"text\":\"ECMAScript 6\",\"link\":\"/fe/es6/\"},{\"text\":\"TypeScript\",\"link\":\"/fe/typescript/base\"}],\"activeMatch\":\"^/fe\"},{\"text\":\"框架\",\"items\":[{\"text\":\"vue\",\"link\":\"/frame/vue/index\"},{\"text\":\"react\",\"link\":\"/frame/react/index\"},{\"text\":\"区别\",\"link\":\"/frame/different/index\"}],\"activeMatch\":\"^/frame\"},{\"text\":\"工程化\",\"items\":[{\"text\":\"包管理工具\",\"link\":\"/engineering/package/index\"},{\"text\":\"项目规范\",\"link\":\"/engineering/standard/index\"},{\"text\":\"构建\",\"link\":\"/engineering/buildTools/index\"},{\"text\":\"部署\",\"link\":\"/engineering/deploy/index\"}],\"activeMatch\":\"^/engineering\"},{\"text\":\"服务端\",\"items\":[{\"text\":\"Node\",\"link\":\"/afterEnd/node/index\"},{\"text\":\"数据库\",\"link\":\"/afterEnd/db/index\"},{\"text\":\"Nginx\",\"link\":\"/afterEnd/nginx/index\"}],\"activeMatch\":\"^/db\"},{\"text\":\"专题\",\"items\":[{\"text\":\"AI\",\"link\":\"/subject/chatGPT/index\"},{\"text\":\"移动端\",\"link\":\"/subject/mobile/index\"},{\"text\":\"鸿蒙开发\",\"link\":\"/subject/harmonyOS/index\"},{\"text\":\"微信相关\",\"link\":\"/subject/weixin/index\"},{\"text\":\"性能优化\",\"link\":\"/subject/performance/index\"},{\"text\":\"数据结构与算法\",\"link\":\"/subject/dataStructure/index\"}],\"activeMatch\":\"^/subject\"},{\"text\":\"Me\",\"items\":[{\"text\":\"语雀\",\"link\":\"https://www.yuque.com/jarvis-zzzhw/frontend?# 《Front-End》\"},{\"text\":\"掘金\",\"link\":\"https://juejin.cn/user/2084329779636094/posts\"},{\"text\":\"经验\",\"link\":\"/pit/index\",\"activeMatch\":\"^/pit\"},{\"text\":\"工具\",\"link\":\"/tools/index\",\"activeMatch\":\"^/tools\"},{\"text\":\"🔒\",\"link\":\"/interview/index\",\"activeMatch\":\"^/interview\"}]}],\"sidebar\":{\"/fe/basicknowledge/\":[{\"text\":\"概念\",\"collapsed\":false,\"items\":[{\"text\":\"编程范式\",\"link\":\"/fe/basicknowledge/concept/编程范式\"}]},{\"text\":\"浏览器相关\",\"collapsed\":false,\"items\":[{\"text\":\"浏览器知识\",\"link\":\"/fe/basicknowledge/browser/浏览器知识\"},{\"text\":\"页面渲染方式\",\"link\":\"/fe/basicknowledge/browser/页面渲染方式\"}]},{\"text\":\"网络知识\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/fe/basicknowledge/network/index.md\"},{\"text\":\"tcp\",\"link\":\"/fe/basicknowledge/network/tcp.md\"},{\"text\":\"http\",\"link\":\"/fe/basicknowledge/network/http.md\"}]},{\"text\":\"图片相关\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/fe/basicknowledge/image/index\"}]},{\"text\":\"音频相关\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/fe/basicknowledge/audio/index\"}]},{\"text\":\"视频相关\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/fe/basicknowledge/video/index\"}]}],\"/fe/html/\":[{\"text\":\"html\",\"collapsed\":false,\"items\":[{\"text\":\"html\",\"link\":\"/fe/html/\"}]}],\"/fe/css/\":[{\"text\":\"css\",\"collapsed\":false,\"items\":[{\"text\":\"基础\",\"link\":\"/fe/css/\"},{\"text\":\"选择器\",\"link\":\"/fe/css/selector\"},{\"text\":\"flex\",\"link\":\"/fe/css/flex\"},{\"text\":\"布局\",\"link\":\"/fe/css/layout\"},{\"text\":\"定位\",\"link\":\"/fe/css/position\"},{\"text\":\"图文样式\",\"link\":\"/fe/css/graphicTextStyles\"},{\"text\":\"响应式\",\"link\":\"/fe/css/responsive\"},{\"text\":\"CSS3\",\"link\":\"/fe/css/css3\"},{\"text\":\"技巧\",\"link\":\"/fe/css/tricks\"}]},{\"text\":\"less\",\"collapsed\":false,\"items\":[{\"text\":\"基础\",\"link\":\"/fe/sass/index\"}]},{\"text\":\"scss\",\"collapsed\":false,\"items\":[{\"text\":\"基础\",\"link\":\"/fe/sass/index\"}]}],\"/fe/javascript/\":[{\"text\":\"基础\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/fe/javascript/base\"},{\"text\":\"数据类型\",\"link\":\"/fe/javascript/数据类型\"},{\"text\":\"数据类型检测原理\",\"link\":\"/fe/javascript/数据类型检测原理\"},{\"text\":\"引用类型的拷贝\",\"link\":\"/fe/javascript/clone\"},{\"text\":\"类型转换\",\"link\":\"/fe/javascript/conversions\"},{\"text\":\"原型和原型链\",\"link\":\"/fe/javascript/prototype\"},{\"text\":\"继承\",\"link\":\"/fe/javascript/inherit\"},{\"text\":\"变量提升\",\"link\":\"/fe/javascript/变量提升\"},{\"text\":\"调用栈\",\"link\":\"/fe/javascript/调用栈\"},{\"text\":\"块级作用域\",\"link\":\"/fe/javascript/块级作用域\"},{\"text\":\"作用域链和闭包\",\"link\":\"/fe/javascript/作用域链和闭包\"},{\"text\":\"this\",\"link\":\"/fe/javascript/this\"},{\"text\":\"event loop\",\"link\":\"/fe/javascript/eventloop\"},{\"text\":\"模块化\",\"link\":\"/fe/javascript/module\"},{\"text\":\"编程题\",\"link\":\"/fe/coding/\"},{\"text\":\"字符串方法\",\"link\":\"/fe/javascript/字符串方法\"},{\"text\":\"数组方法\",\"link\":\"/fe/javascript/数组方法\"}]},{\"text\":\"事件\",\"collapsed\":false,\"items\":[{\"text\":\"事件流\",\"link\":\"/fe/javascript/event/事件流\"},{\"text\":\"事件处理程序\",\"link\":\"/fe/javascript/event/事件处理程序\"},{\"text\":\"事件对象\",\"link\":\"/fe/javascript/event/事件对象\"},{\"text\":\"事件类型\",\"link\":\"/fe/javascript/event/事件类型\"},{\"text\":\"beforeunload\",\"link\":\"/fe/javascript/event/beforeunload\"}]},{\"text\":\"网络\",\"collapsed\":false,\"items\":[{\"text\":\"xhr\",\"link\":\"/fe/javascript/xhr/xhr\"},{\"text\":\"Fetch\",\"link\":\"/fe/javascript/xhr/Fetch\"},{\"text\":\"跨域\",\"link\":\"/fe/javascript/xhr/跨域\"},{\"text\":\"CORS\",\"link\":\"/fe/javascript/xhr/CORS\"},{\"text\":\"缓存\",\"link\":\"/fe/javascript/xhr/缓存\"}]},{\"text\":\"Promise\",\"collapsed\":false,\"items\":[{\"text\":\"Promise\",\"link\":\"/fe/javascript/promise/index\"},{\"text\":\"手写实现\",\"link\":\"/fe/javascript/promise/手写实现\"},{\"text\":\"技巧\",\"link\":\"/fe/javascript/promise/案例\"},{\"text\":\"输出题\",\"link\":\"/fe/javascript/promise/输出题\"},{\"text\":\"迭代器\",\"link\":\"/fe/javascript/promise/迭代器\"},{\"text\":\"生成器\",\"link\":\"/fe/javascript/promise/生成器\"}]},{\"text\":\"webStorage\",\"collapsed\":false,\"items\":[{\"text\":\"cookie\",\"link\":\"/fe/javascript/webStorage/cookie\"},{\"text\":\"webStorage\",\"link\":\"/fe/javascript/webStorage/webStorage\"},{\"text\":\"jwt\",\"link\":\"/fe/javascript/webStorage/jwt\"}]},{\"text\":\"web API\",\"collapsed\":false,\"items\":[{\"text\":\"WebWorker\",\"link\":\"/fe/javascript/webapi/WebWorker\"}]}],\"/fe/es6/\":[{\"text\":\"ECMAScript 6\",\"collapsed\":false,\"items\":[{\"text\":\"ECMAScript 6\",\"link\":\"/fe/es6/\"}]}],\"/fe/typescript/\":[{\"text\":\"基础\",\"collapsed\":false,\"items\":[{\"text\":\"为什么使用TS和TS运行环境搭建\",\"link\":\"/fe/typescript/base/02-为什么使用TS和TS运行环境搭建.md\"},{\"text\":\"类型声明空间与变量声明空间\",\"link\":\"/fe/typescript/base/03-类型声明空间与变量声明空间.md\"},{\"text\":\"类型注解与类型推断\",\"link\":\"/fe/typescript/base/04-类型注解与类型推断.md\"},{\"text\":\"类型分类与联合类型与交叉类型\",\"link\":\"/fe/typescript/base/05-类型分类与联合类型与交叉类型.md\"},{\"text\":\"never类型与any类型与unknown类型\",\"link\":\"/fe/typescript/base/06-never类型与any类型与unknown类型.md\"},{\"text\":\"类型断言与非空断言\",\"link\":\"/fe/typescript/base/07-类型断言与非空断言.md\"},{\"text\":\"数组类型与元组类型\",\"link\":\"/fe/typescript/base/08-数组类型与元组类型.md\"},{\"text\":\"对象类型与索引签名\",\"link\":\"/fe/typescript/base/09-对象类型与索引签名.md\"},{\"text\":\"函数类型与void类型\",\"link\":\"/fe/typescript/base/10-函数类型与void类型.md\"},{\"text\":\"函数重载与可调用注解\",\"link\":\"/fe/typescript/base/11-函数重载与可调用注解.md\"},{\"text\":\"枚举类型与const枚举\",\"link\":\"/fe/typescript/base/12-枚举类型与const枚举.md\"}]},{\"text\":\"进阶\",\"collapsed\":true,\"items\":[{\"text\":\"详解接口与类型别名之间区别\",\"link\":\"/fe/typescript/advance/02-详解接口与类型别名之间区别.md\"},{\"text\":\"字面量类型和keyof关键字\",\"link\":\"/fe/typescript/advance/03-字面量类型和keyof关键字.md\"},{\"text\":\"类型保护与自定义类型保护\",\"link\":\"/fe/typescript/advance/04-类型保护与自定义类型保护.md\"},{\"text\":\"定义泛型和泛型常见操作\",\"link\":\"/fe/typescript/advance/05-定义泛型和泛型常见操作.md\"},{\"text\":\"类型兼容性详解\",\"link\":\"/fe/typescript/advance/06-类型兼容性详解.md\"},{\"text\":\"映射类型与内置工具类型\",\"link\":\"/fe/typescript/advance/07-映射类型与内置工具类型.md\"},{\"text\":\"条件类型和infer关键字\",\"link\":\"/fe/typescript/advance/08-条件类型和infer关键字.md\"},{\"text\":\"类中如何使用类型\",\"link\":\"/fe/typescript/advance/09-类中如何使用类型.md\"},{\"text\":\"模板字符串类型\",\"link\":\"/fe/typescript/advance/10-模板字符串类型.md\"},{\"text\":\"d.ts声明文件和declare关键字\",\"link\":\"/fe/typescript/advance/d点ts声明文件和declare关键字.md\"},{\"text\":\"@types和DefinitelyTyped仓库\",\"link\":\"/fe/typescript/advance/@types和DefinitelyTyped仓库.md\"},{\"text\":\"lib.d.ts和global.d.ts\",\"link\":\"/fe/typescript/advance/lib_d_ts和global_d_ts.md\"},{\"text\":\"详解tsconfigjson配置文件\",\"link\":\"/fe/typescript/advance/详解tsconfigjson配置文件.md\"},{\"text\":\"配置你的TypeScript\",\"link\":\"/fe/typescript/advance/配置你的TypeScript.md\"}]},{\"text\":\"内置工具类型\",\"collapsed\":false,\"items\":[{\"text\":\"内置工具类型-1\",\"link\":\"/fe/typescript/tool/内置工具类型-1\"},{\"text\":\"内置工具类型-2\",\"link\":\"/fe/typescript/tool/内置工具类型-2\"}]},{\"text\":\"其他\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/fe/typescript/index\"},{\"text\":\"typescript\",\"link\":\"/fe/typescript/base\"},{\"text\":\"ts-study\",\"link\":\"/fe/typescript/ts-study\"}]}],\"/fe/network/\":[{\"text\":\"浏览器与网络\",\"collapsed\":false,\"items\":[{\"text\":\"TCP\",\"link\":\"/fe/network/tcp\"},{\"text\":\"HTTP\",\"link\":\"/fe/network/http\"}]}],\"/frame/vue/\":[{\"text\":\"基础\",\"collapsed\":false,\"items\":[{\"text\":\"核心概念及选项式API\",\"link\":\"/frame/vue/base/02-Vue3核心概念及选项式API.md\"},{\"text\":\"组件应用及单文件组件\",\"link\":\"/frame/vue/base/03-Vue3组件应用及单文件组件.md\"},{\"text\":\"语法系统进阶\",\"link\":\"/frame/vue/base/04-Vue3语法系统进阶.md\"},{\"text\":\"Vue3组合式API详解\",\"link\":\"/frame/vue/base/05-Vue3组合式API详解.md\"}]},{\"text\":\"路由\",\"collapsed\":true,\"items\":[{\"text\":\"路由的基本搭建与嵌套路由模式\",\"link\":\"/frame/vue/路由/03-路由的基本搭建与嵌套路由模式.md\"},{\"text\":\"动态路由模式与编程式路由模式\",\"link\":\"/frame/vue/路由/04-动态路由模式与编程式路由模式.md\"},{\"text\":\"命名路由与命名视图与路由元信息\",\"link\":\"/frame/vue/路由/05-命名路由与命名视图与路由元信息.md\"},{\"text\":\"路由传递参数的多种方式及应用场景\",\"link\":\"/frame/vue/路由/06-路由传递参数的多种方式及应用场景.md\"},{\"text\":\"详解route对象与router对象\",\"link\":\"/frame/vue/路由/07-详解route对象与router对象.md\"},{\"text\":\"路由守卫详解及应用场景\",\"link\":\"/frame/vue/路由/08-路由守卫详解及应用场景.md\"}]},{\"text\":\"vuex\",\"collapsed\":true,\"items\":[{\"text\":\"Vuex共享状态的基本开发流程\",\"link\":\"/frame/vue/vuex/10-Vuex共享状态的基本开发流程.md\"},{\"text\":\"Vuex处理异步状态及应用场景\",\"link\":\"/frame/vue/vuex/11-Vuex处理异步状态及应用场景.md\"},{\"text\":\"Vuex计算属性和辅助函数的使用\",\"link\":\"/frame/vue/vuex/12-Vuex计算属性和辅助函数的使用.md\"},{\"text\":\"Vuex-persist对数据进行持久化处理\",\"link\":\"/frame/vue/vuex/13-Vuex-persist对数据进行持久化处理.md\"},{\"text\":\"Vuex分割模块及多状态管理\",\"link\":\"/frame/vue/vuex/14-Vuex分割模块及多状态管理.md\"}]},{\"text\":\"pinia\",\"collapsed\":true,\"items\":[{\"text\":\"核心概念及选项式API\",\"link\":\"/frame/vue/base/02-Vue3核心概念及选项式API.md\"}]},{\"text\":\"源码\",\"collapsed\":true,\"items\":[{\"text\":\"源码\",\"link\":\"/frame/vue/源码/index\"}]},{\"text\":\"其他\",\"collapsed\":true,\"items\":[{\"text\":\"vue 基础\",\"link\":\"/frame/vue/index\"},{\"text\":\"vue 小技巧\",\"link\":\"/frame/vue/skill\"},{\"text\":\"Provide和Inject使用\",\"link\":\"/frame/vue/Provide和Inject\"},{\"text\":\"学习参考\",\"link\":\"/frame/vue/资料\"}]}],\"/frame/react/\":[{\"text\":\"基础\",\"collapsed\":true,\"items\":[{\"text\":\"虚拟DOM与React18新的渲染写法\",\"link\":\"/frame/react/base/02-虚拟DOM与React18新的渲染写法.md\"},{\"text\":\"什么是JSX及JSX详细使用方式\",\"link\":\"/frame/react/base/03-什么是JSX及JSX详细使用方式.md\"},{\"text\":\"如何进行条件渲染与列表渲染\",\"link\":\"/frame/react/base/05-如何进行条件渲染与列表渲染.md\"},{\"text\":\"类组件基本使用及组件通信\",\"link\":\"/frame/react/base/06-类组件基本使用及组件通信.md\"},{\"text\":\"props细节详解及注意事项\",\"link\":\"/frame/react/base/07-props细节详解及注意事项.md\"},{\"text\":\"类组件中事件的使用详解\",\"link\":\"/frame/react/base/08-类组件中事件的使用详解.md\"},{\"text\":\"类组件响应式视图实现与原理\",\"link\":\"/frame/react/base/09-类组件响应式视图实现与原理.md\"},{\"text\":\"state细节详解及React18的自动批处理\",\"link\":\"/frame/react/base/10-state细节详解及React18的自动批处理.md\"},{\"text\":\"PureComponent与shouldComponentUpdate\",\"link\":\"/frame/react/base/11-PureComponent与shouldComponentUpdate.md\"},{\"text\":\"immutable.js不可变数据集合\",\"link\":\"/frame/react/base/12-immutablejs不可变数据集合.md\"},{\"text\":\"Refs操作DOM及操作类组件\",\"link\":\"/frame/react/base/13-Refs操作DOM及操作类组件.md\"},{\"text\":\"详解受控组件及各种表单中的使用\",\"link\":\"/frame/react/base/14-详解受控组件及各种表单中的使用.md\"},{\"text\":\"详解非受控组件的实现方案\",\"link\":\"/frame/react/base/15-详解非受控组件的实现方案.md\"},{\"text\":\"详解常见生命周期钩子函数\",\"link\":\"/frame/react/base/16-详解常见生命周期钩子函数.md\"},{\"text\":\"详解不常见生命周期钩子函数\",\"link\":\"/frame/react/base/17-详解不常见生命周期钩子函数.md\"},{\"text\":\"组件内容的组合模式\",\"link\":\"/frame/react/base/18-组件内容的组合模式.md\"},{\"text\":\"复用组件功能之Render Props模式\",\"link\":\"/frame/react/base/19-复用组件功能之Render Props模式.md\"},{\"text\":\"复用组件功能之HOC高阶组件模式\",\"link\":\"/frame/react/base/20-复用组件功能之HOC高阶组件模式.md\"},{\"text\":\"组件跨层级通信方案Context\",\"link\":\"/frame/react/base/21-组件跨层级通信方案Context.md\"}]},{\"text\":\"hooks\",\"collapsed\":true,\"items\":[{\"text\":\"函数组件基本使用及点标记组件写法\",\"link\":\"/frame/react/hook/02-函数组件基本使用及点标记组件写法.md\"},{\"text\":\"Hook概念及Hook之useState函数\",\"link\":\"/frame/react/hook/03-Hook概念及Hook之useState函数.md\"},{\"text\":\"如何进行条件渲染与列表渲染\",\"link\":\"/frame/react/hook/04-详解Hook之useEffect函数.md\"},{\"text\":\"详解Hook之useRef函数\",\"link\":\"/frame/react/hook/05-详解Hook之useRef函数.md\"},{\"text\":\"详解Hook之useContext函数\",\"link\":\"/frame/react/hook/06-详解Hook之useContext函数.md\"},{\"text\":\"函数组件性能优化之React.memo\",\"link\":\"/frame/react/hook/07-函数组件性能优化之React memo.md\"},{\"text\":\"详解Hook之useCallback与useMemo函数\",\"link\":\"/frame/react/hook/08-详解Hook之useCallback与useMemo函数.md\"},{\"text\":\"详解Hook之useReducer函数\",\"link\":\"/frame/react/hook/09-详解Hook之useReducer函数.md\"},{\"text\":\"React18之useTransition与useDeferredValue\",\"link\":\"/frame/react/hook/11-React18之useTransition与useDeferredValue.md\"},{\"text\":\"函数组件功能复用之自定义Hook\",\"link\":\"/frame/react/hook/12-函数组件功能复用之自定义Hook.md\"},{\"text\":\"简易购物车的Hook版本\",\"link\":\"/frame/react/hook/13-简易购物车的Hook版本.md\"}]},{\"text\":\"路由\",\"collapsed\":true,\"items\":[{\"text\":\"ReactRouterV6基础路由搭建\",\"link\":\"/frame/react/ReactRouter/02-ReactRouterV6基础路由搭建.md\"},{\"text\":\"动态路由模式与编程式路由模式\",\"link\":\"/frame/react/ReactRouter/03-动态路由模式与编程式路由模式.md\"},{\"text\":\"useSearchParams与useLocation函数\",\"link\":\"/frame/react/ReactRouter/04-useSearchParams与useLocation函数.md\"},{\"text\":\"默认路由展示与重定向路由与404处理\",\"link\":\"/frame/react/ReactRouter/05-默认路由展示与重定向路由与404处理.md\"},{\"text\":\"路由loader函数与redirect方法\",\"link\":\"/frame/react/ReactRouter/06-路由loader函数与redirect方法.md\"},{\"text\":\"自定义全局守卫与自定义元信息\",\"link\":\"/frame/react/ReactRouter/07-自定义全局守卫与自定义元信息.md\"}]},{\"text\":\"状态管理\",\"collapsed\":true,\"items\":[{\"text\":\"Redux状态管理的基本流程\",\"link\":\"/frame/react/redux/08-Redux状态管理的基本流程.md\"},{\"text\":\"react-redux简化对Redux的使用\",\"link\":\"/frame/react/redux/09-react-redux简化对Redux的使用.md\"},{\"text\":\"如何处理多个reducer函数及Redux模块化\",\"link\":\"/frame/react/redux/10-如何处理多个reducer函数及Redux模块化.md\"},{\"text\":\"redux-thunk中间件处理异步操作\",\"link\":\"/frame/react/redux/11-redux-thunk中间件处理异步操作.md\"},{\"text\":\"Redux-Toolkit(RTK)改善Redux使用体验\",\"link\":\"/frame/react/redux/12-Redux-Toolkit(RTK)改善Redux使用体验.md\"},{\"text\":\"Redux-Toolkit(RTK)如何处理异步任务\",\"link\":\"/frame/react/redux/13-Redux-Toolkit(RTK)如何处理异步任务.md\"},{\"text\":\"通过redux-persist进行数据持久化处理\",\"link\":\"/frame/react/redux/14-通过redux-persist进行数据持久化处理.md\"},{\"text\":\"路由加状态管理的登录拦截综合案例\",\"link\":\"/frame/react/redux/15-路由加状态管理的登录拦截综合案例.md\"},{\"text\":\"类组件中如何使用路由和状态管理\",\"link\":\"/frame/react/redux/16-类组件中如何使用路由和状态管理.md\"}]},{\"text\":\"Typescript\",\"collapsed\":true,\"items\":[{\"text\":\"props类型\",\"link\":\"/frame/react/ts/08-React与TS配合之基础props限制.md\"},{\"text\":\"children与event类型\",\"link\":\"/frame/react/ts/09-React与TS配合之children与event限制.md\"},{\"text\":\"style与component类型\",\"link\":\"/frame/react/ts/10-React与TS配合之style与component限制.md\"},{\"text\":\"use函数类型\",\"link\":\"/frame/react/ts/11-React与TS配合之use函数限制.md\"},{\"text\":\"类组件类型\",\"link\":\"/frame/react/ts/12-React与TS配合之类组件类型限制.md\"},{\"text\":\"Router路由类型\",\"link\":\"/frame/react/ts/13-React Router路由如何使用TS进行开发.md\"},{\"text\":\"Redux Toolkit状态管理类型\",\"link\":\"/frame/react/ts/14-Redux Toolkit状态管理如何使用TS进行开发.md\"}]},{\"text\":\"Umi\",\"collapsed\":true,\"items\":[{\"text\":\"Umi4框架介绍与基本使用\",\"link\":\"/frame/react/umi/15-Umi4框架介绍与基本使用.md\"},{\"text\":\"Umi4之mock数据_路由数据加载_路由包装组件\",\"link\":\"/frame/react/umi/16-Umi4之mock数据_路由数据加载_路由包装组件.md\"},{\"text\":\"Umi Max之antd组件库_发起请求_共享数据流\",\"link\":\"/frame/react/umi/17-Umi Max之antd组件库_发起请求_共享数据流.md\"}]}],\"/frame/different/\":[{\"text\":\"区别\",\"collapsed\":false,\"items\":[{\"text\":\"对比学习\",\"link\":\"/frame/different/对比学习.md\"},{\"text\":\"编程风格与视图风格\",\"link\":\"/frame/different/02-React18与Vue3对比之编程风格与视图风格.md\"},{\"text\":\"组件_路由_状态管理等风格\",\"link\":\"/frame/different/03-React18与Vue3对比之组件_路由_状态管理等风格.md\"},{\"text\":\"模板_样式_事件_表单等功能\",\"link\":\"/frame/different/04-React18与Vue3对比之模板_样式_事件_表单等功能.md\"},{\"text\":\"diff算法的相同策略与不同策略\",\"link\":\"/frame/different/06-React18与Vue3对比之diff算法的相同策略与不同策略.md\"},{\"text\":\"响应式_生命周期_副作用等功能\",\"link\":\"/frame/different/07-React18与Vue3对比之响应式_生命周期_副作用等功能.md\"}]}],\"/engineering/package/\":[{\"text\":\"包管理工具\",\"collapsed\":false,\"items\":[{\"text\":\"npm\",\"link\":\"/engineering/package/npm\"},{\"text\":\"npm link\",\"link\":\"/engineering/package/npm link\"},{\"text\":\"常用字段\",\"link\":\"/engineering/package/packagesjson常用的配置字段\"},{\"text\":\"符号\",\"link\":\"/engineering/package/符号\"},{\"text\":\"npm转pnpm\",\"link\":\"/engineering/package/npm转pnpm\"}]}],\"/engineering/standard/\":[{\"text\":\"项目规范\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/engineering/standard/index\"},{\"text\":\"代码规范\",\"link\":\"/engineering/standard/代码规范\"},{\"text\":\"Vue3项目代码规范\",\"link\":\"/engineering/standard/Vue3项目代码规范\"}]}],\"/engineering/buildTools/\":[{\"text\":\"esbuild\",\"collapsed\":false,\"items\":[{\"text\":\"使用\",\"link\":\"/engineering/buildTools/esbuild/Esbuild功能使用\"},{\"text\":\"插件开发\",\"link\":\"/engineering/buildTools/esbuild/Esbuild插件开发\"}]},{\"text\":\"rollup\",\"collapsed\":false,\"items\":[{\"text\":\"使用\",\"link\":\"/engineering/buildTools/rollup/Rollup使用\"},{\"text\":\"插件机制\",\"link\":\"/engineering/buildTools/rollup/Rollup插件机制\"}]},{\"text\":\"vite\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/engineering/buildTools/vite/index\"},{\"text\":\"模块化知识\",\"link\":\"/engineering/buildTools/vite/模块化\"},{\"text\":\"如何处理css\",\"link\":\"/engineering/buildTools/vite/如何处理css\"},{\"text\":\"如何处理静态资源\",\"link\":\"/engineering/buildTools/vite/如何处理静态资源\"},{\"text\":\"依赖预构建\",\"link\":\"/engineering/buildTools/vite/依赖预构建\"},{\"text\":\"双引擎架构\",\"link\":\"/engineering/buildTools/vite/双引擎架构\"},{\"text\":\"插件开发\",\"link\":\"/engineering/buildTools/vite/vite插件开发\"},{\"text\":\"HMR原理\",\"link\":\"/engineering/buildTools/vite/HMR原理\"},{\"text\":\"代码分割\",\"link\":\"/engineering/buildTools/vite/代码分割\"},{\"text\":\"语法降级与Polyfill\",\"link\":\"/engineering/buildTools/vite/语法降级与Polyfill\"},{\"text\":\"性能优化\",\"link\":\"/engineering/buildTools/vite/性能优化\"},{\"text\":\"迁移vite\",\"link\":\"/engineering/buildTools/vite/迁移vite\"},{\"text\":\"首次启动慢\",\"link\":\"/engineering/buildTools/vite/vite首次启动慢\"},{\"text\":\"常见配置\",\"link\":\"/engineering/buildTools/vite/常见配置\"},{\"text\":\"配置多页应用\",\"link\":\"/engineering/buildTools/vite/vite配置多页应用\"}]},{\"text\":\"webpack\",\"collapsed\":false,\"items\":[{\"text\":\"webpack\",\"link\":\"/engineering/buildTools/webpack/\"},{\"text\":\"配置多页应用\",\"link\":\"/engineering/buildTools/webpack/webpack配置多页应用\"}]}],\"/engineering/deploy/\":[{\"text\":\"基础知识\",\"collapsed\":false,\"items\":[{\"text\":\"免费证书使用指南\",\"link\":\"/engineering/deploy/base/免费证书使用指南\"},{\"text\":\"服务器配置SSH\",\"link\":\"/engineering/deploy/base/服务器配置SSH\"},{\"text\":\"服务器拉取仓库代码\",\"link\":\"/engineering/deploy/base/服务器拉取仓库代码\"},{\"text\":\"centos安装nginx\",\"link\":\"/engineering/deploy/base/centos安装nginx\"},{\"text\":\"Ubuntu安装环境\",\"link\":\"/engineering/deploy/base/Ubuntu20.4\"}]},{\"text\":\"Nginx\",\"collapsed\":false,\"items\":[{\"text\":\"配置https\",\"link\":\"/engineering/deploy/nginx/nginx配置https\"}]},{\"text\":\"Github Action\",\"collapsed\":false,\"items\":[{\"text\":\"Github Action 简介\",\"link\":\"/engineering/deploy/GithubAction/简介\"},{\"text\":\"自动部署 Github Page\",\"link\":\"/engineering/deploy/GithubAction/githubpage\"},{\"text\":\"自动部署 Gitee Page\",\"link\":\"/engineering/deploy/GithubAction/giteepage\"},{\"text\":\"部署阿里云\",\"link\":\"/engineering/deploy/GithubAction/部署阿里云\"}]},{\"text\":\"Docker\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/engineering/deploy/docker/简介\"},{\"text\":\"安装\",\"link\":\"/engineering/deploy/docker/docker安装\"},{\"text\":\"使用\",\"link\":\"/engineering/deploy/docker/docker使用\"},{\"text\":\"部署Vue项目\",\"link\":\"/engineering/deploy/docker/Docker部署Vue项目\"},{\"text\":\"部署node-基础版\",\"link\":\"/engineering/deploy/docker/Docker部署node-基础版\"},{\"text\":\"部署node-环境变量\",\"link\":\"/engineering/deploy/docker/Docker部署node-env\"},{\"text\":\"部署node-挂载\",\"link\":\"/engineering/deploy/docker/Docker部署node-volume\"},{\"text\":\"部署express和MySQL\",\"link\":\"/engineering/deploy/docker/Docker部署express和MySQL\"},{\"text\":\"部署express和MySQL和Redis\",\"link\":\"/engineering/deploy/docker/Docker部署express和MySQL和Redis\"}]},{\"text\":\"Jenkins\",\"collapsed\":false,\"items\":[{\"text\":\"安装\",\"link\":\"/engineering/deploy/jenkins/Jenkins安装\"},{\"text\":\"配置\",\"link\":\"/engineering/deploy/jenkins/Jenkins配置\"},{\"text\":\"前端项目配置\",\"link\":\"/engineering/deploy/jenkins/前端项目配置\"}]},{\"text\":\"部署项目\",\"collapsed\":false,\"items\":[{\"text\":\"Github Action部署项目\",\"link\":\"/engineering/deploy/project/github-action\"},{\"text\":\"jenkins部署前端项目\",\"link\":\"/engineering/deploy/project/jenkins部署前端项目\"},{\"text\":\"初级版docker部署前后端\",\"link\":\"/engineering/deploy/project/初级版docker部署前后端\"},{\"text\":\"pm2部署前后端项目\",\"link\":\"/engineering/deploy/project/pm2部署前后端项目\"},{\"text\":\"使用js脚本\",\"link\":\"/engineering/deploy/project/使用js脚本\"},{\"text\":\"使用shell部署前端静态资源\",\"link\":\"/engineering/deploy/project/使用shell部署前端静态资源\"}]}],\"/pit/\":[{\"text\":\"开发经验\",\"items\":[{\"text\":\"npm 踩坑记录\",\"link\":\"/pit/npm\"},{\"text\":\"PC 踩坑记录\",\"link\":\"/pit/pc\"},{\"text\":\"H5 踩坑记录\",\"link\":\"/pit/h5\"},{\"text\":\"import排序\",\"link\":\"/pit/import排序\"}]},{\"text\":\"调试方法\",\"items\":[{\"text\":\"调试方法\",\"link\":\"/pit/debug/调试方法\"},{\"text\":\"远程调试\",\"link\":\"/pit/debug/远程调试\"}]},{\"text\":\"常见效果\",\"collapsed\":false,\"items\":[{\"text\":\"目录\",\"link\":\"/pit/commonEffect/index\"},{\"text\":\"弹幕效果\",\"link\":\"/pit/commonEffect/弹幕效果\"}]},{\"text\":\"常用功能\",\"collapsed\":false,\"items\":[{\"text\":\"禁止浏览器快捷键保存页面\",\"link\":\"/pit/commonFunc/禁止浏览器快捷键保存页面\"}]}],\"/subject/mobile/\":[{\"text\":\"移动端开发\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/subject/mobile/index\"},{\"text\":\"H5唤起小程序\",\"link\":\"/subject/mobile/微信端外H5跳转小程序方案汇总\"},{\"text\":\"H5唤起APP\",\"link\":\"/subject/mobile/H5唤起APP\"}]}],\"/subject/chatGPT/\":[{\"text\":\"openai\",\"collapsed\":false,\"items\":[{\"text\":\"官网\",\"link\":\"https://platform.openai.com/\"},{\"text\":\"我的GPT\",\"link\":\"https://ask.vuejs.news/#/\"},{\"text\":\"文档\",\"link\":\"/subject/chatGPT/openai/index\"},{\"text\":\"Models\",\"link\":\"/subject/chatGPT/openai/Models\"},{\"text\":\"GPT\",\"link\":\"/subject/chatGPT/openai/GPT\"}]},{\"text\":\"使用\",\"collapsed\":false,\"items\":[{\"text\":\"chatGPT平台\",\"link\":\"/subject/chatGPT/use/使用资源\"},{\"text\":\"Prompt编写\",\"link\":\"/subject/chatGPT/use/Prompt\"},{\"text\":\"Prompt资源\",\"link\":\"/subject/chatGPT/use/Prompt资源\"},{\"text\":\"搭建OpenAI的API代理\",\"link\":\"/subject/chatGPT/use/搭建OpenAI的API代理\"}]},{\"text\":\"开发\",\"collapsed\":false,\"items\":[{\"text\":\"开发指南\",\"link\":\"/subject/chatGPT/develop/index\"},{\"text\":\"SSE\",\"link\":\"/subject/chatGPT/develop/SSE服务端实时推送消息\"}]},{\"text\":\"学习\",\"collapsed\":false,\"items\":[{\"text\":\"AI 学习资源\",\"link\":\"/subject/chatGPT/study/AI 学习资源\"}]}],\"/subject/dataStructure/\":[{\"text\":\"数组\",\"collapsed\":false,\"items\":[{\"text\":\"概念\",\"link\":\"/subject/dataStructure/array/index\"},{\"text\":\"题目\",\"link\":\"/subject/dataStructure/array/topic\"}]},{\"text\":\"栈\",\"collapsed\":false,\"items\":[{\"text\":\"概念\",\"link\":\"/subject/dataStructure/stack/index\"},{\"text\":\"题目\",\"link\":\"/subject/dataStructure/stack/topic\"}]},{\"text\":\"队列\",\"collapsed\":false,\"items\":[{\"text\":\"普通队列\",\"link\":\"/subject/dataStructure/queue/index\"},{\"text\":\"优先队列\",\"link\":\"/subject/dataStructure/queue/priorityQueue\"},{\"text\":\"题目\",\"link\":\"/subject/dataStructure/queue/topic\"}]},{\"text\":\"链表\",\"collapsed\":false,\"items\":[{\"text\":\"单向链表\",\"link\":\"/subject/dataStructure/LinkedList/index\"},{\"text\":\"双向链表\",\"link\":\"/subject/dataStructure/LinkedList/doubleLinkedList\"},{\"text\":\"题目\",\"link\":\"/subject/dataStructure/LinkedList/topic\"}]},{\"text\":\"集合\",\"collapsed\":false,\"items\":[{\"text\":\"概念\",\"link\":\"/subject/dataStructure/set/index\"},{\"text\":\"题目\",\"link\":\"/subject/dataStructure/set/topic\"}]},{\"text\":\"字典\",\"collapsed\":false,\"items\":[{\"text\":\"概念\",\"link\":\"/subject/dataStructure/map/index\"},{\"text\":\"题目\",\"link\":\"/subject/dataStructure/map/topic\"}]},{\"text\":\"哈希表\",\"collapsed\":false,\"items\":[{\"text\":\"概念\",\"link\":\"/subject/dataStructure/hashTable/index\"},{\"text\":\"题目\",\"link\":\"/subject/dataStructure/hashTable/topic\"}]},{\"text\":\"树\",\"collapsed\":false,\"items\":[{\"text\":\"树\",\"link\":\"/subject/dataStructure/tree/index\"},{\"text\":\"二叉树\",\"link\":\"/subject/dataStructure/tree/binaryTree\"},{\"text\":\"二叉搜索树\",\"link\":\"/subject/dataStructure/tree/binarySearchTree\"},{\"text\":\"遍历专题\",\"link\":\"/subject/dataStructure/tree/traverse\"},{\"text\":\"题目\",\"link\":\"/subject/dataStructure/tree/topic\"}]},{\"text\":\"图\",\"collapsed\":false,\"items\":[{\"text\":\"概念\",\"link\":\"/subject/dataStructure/graph/index\"},{\"text\":\"题目\",\"link\":\"/subject/dataStructure/graph/topic\"}]},{\"text\":\"搜索排序\",\"collapsed\":false,\"items\":[{\"text\":\"概念\",\"link\":\"/subject/dataStructure/searchSort/index\"},{\"text\":\"题目\",\"link\":\"/subject/dataStructure/searchSort/index\"}]}],\"/subject/weixin/\":[{\"text\":\"小程序\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/subject/weixin/miniprogram/index\"},{\"text\":\"扫码登录\",\"link\":\"/subject/weixin/miniprogram/小程序扫码登录\"}]},{\"text\":\"公众号\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/subject/weixin/gzh/index\"}]}],\"/subject/performance/\":[{\"text\":\"工具\",\"collapsed\":false,\"items\":[{\"text\":\"性能优化工具\",\"link\":\"/subject/performance/工具.md\"},{\"text\":\"性能优化指标\",\"link\":\"/subject/performance/性能优化指标.md\"}]},{\"text\":\"通用技巧\",\"collapsed\":false,\"items\":[{\"text\":\"性能优化策略\",\"link\":\"/subject/performance/性能优化策略.md\"}]},{\"text\":\"vue\",\"collapsed\":false,\"items\":[{\"text\":\"vue性能优化-1\",\"link\":\"/subject/performance/vue性能优化-1.md\"},{\"text\":\"vue性能优化-2\",\"link\":\"/subject/performance/vue性能优化-2.md\"}]},{\"text\":\"资源\",\"collapsed\":false,\"items\":[{\"text\":\"资源\",\"link\":\"/subject/performance/资源.md\"}]}],\"/subject/harmonyOS/\":[{\"text\":\"鸿蒙开发\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/subject/harmonyOS/index\"}]}],\"/tools/\":[{\"text\":\"Git\",\"items\":[{\"text\":\"Git 相关技巧\",\"link\":\"/tools/git/\"},{\"text\":\"Git 命令清单\",\"link\":\"/tools/git/command\"}]},{\"text\":\"开发常用\",\"collapsed\":false,\"items\":[{\"text\":\"whistle\",\"link\":\"/tools/whistle\"},{\"text\":\"第三方库\",\"link\":\"/tools/library\"},{\"text\":\"在线工具\",\"link\":\"/tools/onlineTools\"},{\"text\":\"常用正则\",\"link\":\"/tools/regexp\"},{\"text\":\"项目模板\",\"link\":\"/tools/template/h5\"}]},{\"text\":\"命令行工具\",\"collapsed\":false,\"items\":[{\"text\":\"zsh配置\",\"link\":\"/tools/terminal/zsh\"},{\"text\":\"命令行工具\",\"link\":\"/tools/terminal/toolkit\"},{\"text\":\"shell命令\",\"link\":\"/tools/terminal/shell\"}]},{\"text\":\"常用软件\",\"items\":[{\"text\":\"多平台软件\",\"link\":\"/tools/software/cross-platform\"},{\"text\":\"Mac平台\",\"link\":\"/tools/software/mac\"},{\"text\":\"Windows平台\",\"link\":\"/tools/software/windows\"},{\"text\":\"浏览器设置与扩展\",\"link\":\"/tools/software/browser\"},{\"text\":\"Visual Studio Code 配置\",\"link\":\"/tools/software/vscode\"},{\"text\":\"WebStorm配置\",\"link\":\"/tools/software/webstorm\"}]},{\"text\":\"文档搭建\",\"collapsed\":false,\"items\":[{\"text\":\"vitepress\",\"link\":\"/tools/doc/index\"},{\"text\":\"配置Algolia\",\"link\":\"/tools/doc/vitepress配置Algolia\"}]}],\"/interview/\":[{\"text\":\"技术\",\"collapsed\":false,\"items\":[{\"text\":\"HTTP\",\"link\":\"/interview/HTTP\"},{\"text\":\"CSS1\",\"link\":\"/interview/CSS/CSS-1\"},{\"text\":\"CSS2\",\"link\":\"/interview/CSS/CSS-2\"},{\"text\":\"CSS3\",\"link\":\"/interview/CSS/CSS-3\"},{\"text\":\"JavaScript\",\"link\":\"/interview/JavaScript\"},{\"text\":\"vue\",\"link\":\"/interview/vue\"},{\"text\":\"vue2响应式\",\"link\":\"/interview/vue2响应式\"},{\"text\":\"react\",\"link\":\"/interview/react\"},{\"text\":\"构建\",\"link\":\"/interview/构建\"},{\"text\":\"webpack1\",\"link\":\"/interview/webpack1\"},{\"text\":\"webpack2\",\"link\":\"/interview/webpack2\"},{\"text\":\"node\",\"link\":\"/interview/node\"},{\"text\":\"node框架\",\"link\":\"/interview/node框架\"},{\"text\":\"小程序\",\"link\":\"/interview/小程序\"}]},{\"text\":\"软实力\",\"collapsed\":false,\"items\":[{\"text\":\"问题预设\",\"link\":\"/interview/问题预设\"},{\"text\":\"专业技能和工作经验\",\"link\":\"/interview/专业技能和工作经验\"},{\"text\":\"hr篇-我的\",\"link\":\"/interview/hr篇-我的\"},{\"text\":\"hr篇\",\"link\":\"/interview/hr篇\"},{\"text\":\"房地产\",\"link\":\"/interview/房地产\"}]}],\"/afterEnd/node/\":[{\"text\":\"基础\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/afterEnd/node/index\"}]}],\"/afterEnd/db/\":[{\"text\":\"基础\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/afterEnd/db/index\"}]},{\"text\":\"mysql\",\"collapsed\":false,\"items\":[{\"text\":\"SQL查询\",\"link\":\"/afterEnd/db/mysql/SQL查询\"}]},{\"text\":\"mongodb\",\"collapsed\":false,\"items\":[{\"text\":\"安装\",\"link\":\"/afterEnd/db/mongodb/install-mac.md\"},{\"text\":\"基础查询\",\"link\":\"/afterEnd/db/mongodb/基础查询.md\"}]}],\"/afterEnd/nginx/\":[{\"text\":\"基础\",\"collapsed\":false,\"items\":[{\"text\":\"简介\",\"link\":\"/afterEnd/nginx/index\"}]}]},\"outline\":{\"level\":\"deep\",\"label\":\"本页目录\"},\"footer\":{\"message\":\"你相信光吗\",\"copyright\":\"Copyright © 2020-present\"},\"darkModeSwitchLabel\":\"外观\",\"returnToTopLabel\":\"返回顶部\",\"lastUpdatedText\":\"上次更新\",\"algolia\":{\"appId\":\"B2QT7C52N9\",\"apiKey\":\"5b813dda077cdf3d74357201ad3f29b4\",\"indexName\":\"suyxh\",\"placeholder\":\"搜索\",\"translations\":{\"button\":{\"buttonText\":\"搜索\",\"buttonAriaLabel\":\"搜索\"},\"modal\":{\"searchBox\":{\"resetButtonTitle\":\"清除查询条件\",\"resetButtonAriaLabel\":\"清除查询条件\",\"cancelButtonText\":\"取消\",\"cancelButtonAriaLabel\":\"取消\"},\"startScreen\":{\"recentSearchesTitle\":\"搜索历史\",\"noRecentSearchesText\":\"没有搜索历史\",\"saveRecentSearchButtonTitle\":\"保存至搜索历史\",\"removeRecentSearchButtonTitle\":\"从搜索历史中移除\",\"favoriteSearchesTitle\":\"收藏\",\"removeFavoriteSearchButtonTitle\":\"从收藏中移除\"},\"errorScreen\":{\"titleText\":\"无法获取结果\",\"helpText\":\"你可能需要检查你的网络连接\"},\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\",\"searchByText\":\"搜索提供者\"},\"noResultsScreen\":{\"noResultsText\":\"无法找到相关结果\",\"suggestedQueryText\":\"你可以尝试查询\",\"reportMissingResultsText\":\"你认为该查询应该有结果？\",\"reportMissingResultsLinkText\":\"点击反馈\"}}}},\"docFooter\":{\"prev\":\"上一篇\",\"next\":\"下一篇\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>